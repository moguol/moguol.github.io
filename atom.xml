<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hexo]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-10-27T15:11:34.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[John Doe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[GitLab搭建记]]></title>
    <link href="http://yoursite.com/2015/10/05/GitLab-build/"/>
    <id>http://yoursite.com/2015/10/05/GitLab-build/</id>
    <published>2015-10-05T08:35:38.000Z</published>
    <updated>2015-10-27T15:11:34.000Z</updated>
    <content type="html"><![CDATA[<p>&emsp;最近在系统的学习<strong>Git</strong>，需要用到远程仓库，于是想搭个<strong>GitLab</strong>玩玩。没想到想玩好GitLab也不是件容易的事情，即便是按照教程来搭都折腾了挺久，GitLab对各软件版本的要求比较苛刻，所以搭建起来也比较麻烦，在此记录一下搭建的过程以便备忘，其实如果不想折腾可直接使用<a href="https://github.com/" target="_blank" rel="external">GitHub</a>。<br>&emsp;本文记录在<strong>CentOS6.4 64bit</strong>上搭建<strong>GitLab</strong>的过程，搭建<strong>GitLab</strong>需要涉及到如下软件：</p>
<ul>
<li>Git</li>
<li>Ruby</li>
<li>MySQL</li>
<li>Redis</li>
<li>GitLab</li>
<li>GitLab-shell</li>
<li>Gem</li>
<li>Nginx</li>
</ul>
<h3 id="安装依赖"><strong>安装依赖</strong></h3><p>&emsp;添加EPEL源<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; wget -O <span class="regexp">/etc/</span>pki<span class="regexp">/rpm-gpg/</span>RPM-GPG-KEY-EPEL-<span class="number">6</span> <span class="string">https:</span><span class="comment">//www.fedoraproject.org/static/0608B895.txt --no-check-certificate</span></span><br><span class="line">shell&gt; rpm --<span class="keyword">import</span> <span class="regexp">/etc/</span>pki<span class="regexp">/rpm-gpg/</span>RPM-GPG-KEY-EPEL-<span class="number">6</span></span><br><span class="line">shell&gt; rpm -Uvh <span class="string">http:</span><span class="comment">//dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span></span><br><span class="line"></span><br><span class="line">#验证安装</span><br><span class="line">shell&gt; rpm -qa gpg-pubkey</span><br><span class="line">gpg-pubkey-<span class="number">0608</span>b895-<span class="number">4</span>bd22942</span><br></pre></td></tr></table></figure></p>
<p>&emsp;添加puias源<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; wget -O <span class="regexp">/etc/</span>yum.repos.d<span class="regexp">/PUIAS_6_computational.repo https:/</span><span class="regexp">/gitlab.com/</span>gitlab-org<span class="regexp">/gitlab-recipes/</span>raw<span class="regexp">/master/</span>install<span class="regexp">/centos/</span>PUIAS_6_computational.repo</span><br><span class="line">shell&gt; wget -O <span class="regexp">/etc/</span>pki<span class="regexp">/rpm-gpg/</span>RPM-GPG-KEY-puias <span class="string">http:</span><span class="comment">//springdale.math.ias.edu/data/puias/6/x86_64/os/RPM-GPG-KEY-puias</span></span><br><span class="line">shell&gt; rpm --<span class="keyword">import</span> <span class="regexp">/etc/</span>pki<span class="regexp">/rpm-gpg/</span>RPM-GPG-KEY-puias</span><br><span class="line"></span><br><span class="line">#验证安装</span><br><span class="line">shell&gt; rpm -qa gpg-pubkey</span><br><span class="line">gpg-pubkey-<span class="number">41</span>a40948-<span class="number">4</span>ce19266</span><br></pre></td></tr></table></figure></p>
<p>&emsp;查看以上添加的EPEL和puias源<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; yum repolist</span><br><span class="line">Loaded <span class="string">plugins:</span> fastestmirror, refresh-packagekit, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * <span class="string">PUIAS_6_computational:</span> puias.math.ias.edu</span><br><span class="line"> * <span class="string">base:</span> ftp.sjtu.edu.cn</span><br><span class="line"> * <span class="string">extras:</span> mirrors.nwsuaf.edu.cn</span><br><span class="line"> * <span class="string">updates:</span> ftp.sjtu.edu.cn</span><br><span class="line">PUIAS_6_computational                                                                                                   | <span class="number">3.3</span> kB     <span class="number">00</span>:<span class="number">00</span></span><br><span class="line">PUIAS_6_computational/primary_db                                                                                        | <span class="number">1.9</span> MB     <span class="number">00</span>:<span class="number">15</span></span><br><span class="line">repo id                                                 repo name                                                                        status</span><br><span class="line">PUIAS_6_computational                                   PUIAS computational Base <span class="number">6</span> - x86_64                                               <span class="number">2</span>,<span class="number">837</span></span><br><span class="line">base                                                    CentOS-<span class="number">6</span> - Base                                                                   <span class="number">6</span>,<span class="number">575</span></span><br><span class="line">epel                                                    Extra Packages <span class="keyword">for</span> Enterprise Linux <span class="number">6</span> - x86_64                                   <span class="number">11</span>,<span class="number">764</span></span><br><span class="line">extras                                                  CentOS-<span class="number">6</span> - Extras                                                                    <span class="number">35</span></span><br><span class="line">treasuredata                                            TreasureData                                                                         <span class="number">14</span></span><br><span class="line">updates                                                 CentOS-<span class="number">6</span> - Updates                                                                  <span class="number">298</span></span><br><span class="line"><span class="string">repolist:</span> <span class="number">21</span>,<span class="number">523</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;安装依赖包<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y groupinstall <span class="string">'Development Tools'</span></span><br><span class="line">yum -y install gcc-c++ readline-devel zlib-devel libffi-devel openssl-devel <span class="built_in">make</span> autoconf automake libtool bison libxml2-devel libxslt-devel libyaml-devel</span><br></pre></td></tr></table></figure></p>
<h3 id="添加Git系统用户"><strong>添加Git系统用户</strong></h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; adduser --system --shell /bin/bash --comment <span class="string">'GitLab'</span> --create-home --home-dir /home/git/ git</span><br><span class="line"><span class="comment">#将/usr/local/bin添加到系统默认路径</span></span><br><span class="line">shell&gt; visudo</span><br><span class="line">	<span class="constant">Defaults </span>   secure_path = <span class="regexp">/sbin:/bin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/usr/local/bin</span></span><br></pre></td></tr></table></figure>
<h3 id="编译安装Git"><strong>编译安装Git</strong></h3><p>&emsp;需要确保<code>Git</code>的版本在<strong><code>1.7.10</code></strong>或以上，CentOS6.4通过<code>yum</code>的版本是<strong><code>1.7.1</code></strong>，要手动编译安装更高版本<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#如果通过yum安装过Git，需要先删除</span><br><span class="line"><span class="keyword">shell</span>&gt; yum <span class="built_in">remove</span> git</span><br><span class="line"><span class="keyword">shell</span>&gt; yum install zlib-devel <span class="keyword">perl</span>-CPAN gettext curl-devel expat-devel gettext-devel openssl-devel</span><br><span class="line"><span class="keyword">shell</span>&gt; wget http<span class="variable">s:</span>//www.kernel.org/pub/software/scm/git/git-<span class="number">2.5</span>.<span class="number">3</span>.tar.gz</span><br><span class="line"><span class="keyword">shell</span>&gt; tar -zxf git-<span class="number">2.5</span>.<span class="number">3</span>.tar.gz &amp;&amp; <span class="keyword">cd</span> git-<span class="number">2.5</span>.<span class="number">3</span></span><br><span class="line"><span class="keyword">shell</span>&gt; ./configure &amp;&amp; <span class="keyword">make</span> &amp;&amp; <span class="keyword">make</span> prefix=/usr/local install</span><br><span class="line"><span class="keyword">shell</span>&gt; git --<span class="keyword">version</span></span><br><span class="line">git <span class="keyword">version</span> <span class="number">2.5</span>.<span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="编译安装ruby"><strong>编译安装ruby</strong></h3><p>&emsp;<strong><code>ruby</code></strong>需要<strong><code>2.0+</code></strong>的版本，CentOS6.4通过<code>yum</code>安装的版本是<strong><code>1.8</code></strong><br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果通过yum安装过ruby，需要先删除</span></span><br><span class="line"><span class="built_in">shell</span>&gt; yum remove ruby</span><br><span class="line"><span class="built_in">shell</span>&gt; wget <span class="keyword">ftp</span>://<span class="keyword">ftp</span>.ruby-lang.org/pub/ruby/<span class="number">2.1</span>/ruby-<span class="number">2.1</span><span class="number">.2</span>.tar.gz</span><br><span class="line"><span class="built_in">shell</span>&gt; tar -zxf ruby-<span class="number">2.1</span><span class="number">.2</span>.tar.gz &amp;&amp; cd ruby-<span class="number">2.1</span><span class="number">.2</span></span><br><span class="line"><span class="built_in">shell</span>&gt; ./configure <span class="comment">--disable-install-rdoc &amp;&amp; make &amp;&amp; make prefix=/usr/local install</span></span><br><span class="line"><span class="built_in">shell</span>&gt; ruby -v</span><br><span class="line">ruby <span class="number">2.1</span><span class="number">.2</span>p95 (<span class="number">2014</span>-<span class="number">05</span>-<span class="number">08</span> revision <span class="number">45877</span>) [x86_64-linux]</span><br></pre></td></tr></table></figure></p>
<p>&emsp;安装bundler，由于<code>https://rubygems.org/</code>被墙，需要修改ruby源<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span>&gt; gem sources --<span class="built_in">remove</span> http<span class="variable">s:</span>//rubygems.org/</span><br><span class="line"><span class="keyword">shell</span>&gt; gem sources -<span class="keyword">a</span> http<span class="variable">s:</span>//<span class="keyword">ruby</span>.taobao.org/</span><br><span class="line"><span class="keyword">shell</span>&gt; gem sources -<span class="keyword">l</span></span><br><span class="line"><span class="keyword">shell</span>&gt; gem install bundler --<span class="keyword">no</span>-doc</span><br></pre></td></tr></table></figure></p>
<h3 id="安装MySQL数据库"><strong>安装MySQL数据库</strong></h3><p>&emsp;官方推荐使用<strong>MySQL</strong>或<strong>PostgreSQL</strong>作为数据库，如果使用MySQL版本需要高于<strong><code>5.5.14</code></strong>，CentOS6.4通过<code>yum</code>默认安装版本为<strong><code>5.1.73</code></strong>，这里使用<code>yum</code>安装<strong><code>5.5.45</code></strong><br>&emsp;安装MySQL 5.5.45<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shell</span>&gt; rpm -Uvh <span class="keyword">http</span>://dl.fedoraproject.org/pub/epel/<span class="number">6</span>/i386/epel-release-<span class="number">6</span>-<span class="number">8.</span>noarch.rpm</span><br><span class="line"><span class="built_in">shell</span>&gt; rpm -Uvh <span class="keyword">http</span>://rpms.famillecollet.com/enterprise/remi-release-<span class="number">6.</span>rpm</span><br><span class="line"><span class="built_in">shell</span>&gt; yum <span class="comment">--enablerepo=remi,remi-test install mysql mysql-server mysql-devel</span></span><br><span class="line"><span class="built_in">shell</span>&gt; mysql <span class="comment">--version</span></span><br><span class="line">mysql  Ver <span class="number">14.14</span> Distrib <span class="number">5.5</span><span class="number">.45</span>, <span class="keyword">for</span> Linux (x86_64) <span class="keyword">using</span> readline <span class="number">5.1</span></span><br><span class="line"><span class="built_in">shell</span>&gt; /etc/init.d/mysqld start</span><br><span class="line"><span class="built_in">shell</span>&gt; mysql_secure_installation</span><br><span class="line"><span class="comment">#mysql_secure_installation作用</span></span><br><span class="line">	<span class="comment">#为root用户设置密码</span></span><br><span class="line">	<span class="comment">#删除匿名账号</span></span><br><span class="line">	<span class="comment">#取消root用户远程登录</span></span><br><span class="line">	<span class="comment">#删除test库和对test库的访问权限</span></span><br><span class="line">	<span class="comment">#刷新授权表使修改生效</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;创建GitLab所需数据库用户<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell &gt; mysql -uroot -p</span><br><span class="line">		mysql&gt; <span class="keyword">CREATE</span> USER <span class="string">'git'</span>@<span class="string">'localhost'</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">'gitlab'</span>;</span><br><span class="line">		mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;GitLab需要用INNODB，设置默认存储引擎为INNODB<br>&emsp;&emsp;配置文件设置my.cnf<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="default"><span class="keyword">default</span>-storage-engine = innodb</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;命令行设置<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET storage<span class="emphasis">_engine=INNODB;</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE '%engine';</span><br><span class="line">+------------------------+---------+</span><br><span class="line">| Variable_</span>name          | Value   |</span><br><span class="line">|------------------------+---------|</span><br><span class="line">| default<span class="emphasis">_storage_</span>engine | InnoDB  |</span><br><span class="line"><span class="header">| storage_engine         | InnoDB  |</span><br><span class="line">+------------------------+---------+</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;创建GitLab相关数据库及授权<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="subst">&gt;</span> CREATE DATABASE <span class="keyword">IF</span> <span class="literal">NOT</span> EXISTS <span class="string">`gitlabhq_production`</span> DEFAULT CHARACTER <span class="built_in">SET</span> <span class="string">`utf8`</span> COLLATE <span class="string">`utf8_unicode_ci`</span>;</span><br><span class="line">mysql<span class="subst">&gt;</span> GRANT <span class="keyword">SELECT</span>, LOCK TABLES, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER <span class="keyword">ON</span> <span class="string">`gitlabhq_production`</span><span class="built_in">.</span><span class="subst">*</span> <span class="keyword">TO</span> <span class="string">'git'</span>@<span class="string">'localhost'</span>;</span><br><span class="line">mysql<span class="subst">&gt;</span> FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;登陆验证<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span>&gt; mysql -ugit -p -<span class="keyword">D</span> gitlabhq_production</span><br></pre></td></tr></table></figure></p>
<h3 id="安装Redis"><strong>安装Redis</strong></h3><p>&emsp;使用<code>yum</code>安装<strong>Redis</strong>，完全按照官方文档配置无任何优化<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span>&gt; yum install redis</span><br><span class="line"><span class="keyword">shell</span>&gt; cp /etc/redis.<span class="keyword">conf</span> /etc/redis.<span class="keyword">conf</span>.org</span><br><span class="line"><span class="keyword">shell</span>&gt; sed 's/^port .*/port 0/' /etc/redis.<span class="keyword">conf</span>.org |tee /etc/redis.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">shell</span>&gt; echo 'unixsocket /<span class="keyword">var</span>/<span class="keyword">run</span>/redis/redis.sock' |tee -a /etc/redis.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">shell</span>&gt; echo -<span class="keyword">e</span> 'unixsocketperm 0770' |tee -a /etc/redis.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">shell</span>&gt; chown redis:redis /<span class="keyword">var</span>/<span class="keyword">run</span>/redis</span><br><span class="line"><span class="keyword">shell</span>&gt; chmod 755 /<span class="keyword">var</span>/<span class="keyword">run</span>/redis</span><br><span class="line"><span class="keyword">shell</span>&gt; usermod -aG redis git</span><br><span class="line"><span class="keyword">shell</span>&gt; /etc/init.<span class="keyword">d</span>/redis start</span><br></pre></td></tr></table></figure></p>
<h3 id="安装GitLab"><strong>安装GitLab</strong></h3><h4 id="GitLab配置"><strong>GitLab配置</strong></h4><p>&emsp;在配置文件<code>config/unicorn.rb</code>时中有个<strong><code>timeout</code></strong>设置，若机器性能差需要将<strong><code>timeout</code></strong>值设置大些，否则<code>GitLab</code>在初始化时可能超时<br>&emsp;<code>host</code>最好填域名，此处使用HTTPS<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span>&gt; <span class="keyword">cd</span> /home/git</span><br><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> git clone https:<span class="comment">//gitlab.com/gitlab-org/gitlab-ce.git -b 7-4-stable gitlab</span></span><br><span class="line"><span class="keyword">shell</span>&gt; <span class="keyword">cd</span> gitlab/</span><br><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> cp config/gitlab.yml.example config/gitlab.yml</span><br><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> vim config/gitlab.yml</span><br><span class="line">			  gitlab:</span><br><span class="line">				host: yourdomain</span><br><span class="line">				port: 443</span><br><span class="line">				https: true</span><br><span class="line"><span class="keyword">shell</span>&gt; chown -R git <span class="keyword">log</span>/</span><br><span class="line"><span class="keyword">shell</span>&gt; chown -R git tmp/</span><br><span class="line"><span class="keyword">shell</span>&gt; chmod -R <span class="keyword">u</span>+rwX <span class="keyword">log</span>/</span><br><span class="line"><span class="keyword">shell</span>&gt; chmod -R <span class="keyword">u</span>+rwX tmp/</span><br><span class="line"><span class="keyword">shell</span>&gt; chmod -R <span class="keyword">u</span>+rwX tmp/pids/</span><br><span class="line"><span class="keyword">shell</span>&gt; chmod -R <span class="keyword">u</span>+rwX tmp/sockets/</span><br><span class="line"><span class="keyword">shell</span>&gt; chmod -R <span class="keyword">u</span>+rwX  public/uploads</span><br><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> <span class="keyword">mkdir</span> /home/git/gitlab-satellites</span><br><span class="line"><span class="keyword">shell</span>&gt; chmod <span class="keyword">u</span>+rwx,<span class="keyword">g</span>=rx,o-rwx /home/git/gitlab-satellites</span><br><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> cp config/unicorn.rb.example config/unicorn.rb</span><br><span class="line">#查看系统核心数</span><br><span class="line"><span class="keyword">shell</span>&gt; nproc</span><br><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> vim config/unicorn.rb</span><br><span class="line">			worker_processes 核心数</span><br></pre></td></tr></table></figure></p>
<h4 id="配置全局用户及邮箱"><strong>配置全局用户及邮箱</strong></h4><p>&emsp;此处使用163邮箱作为GitLab的发送邮箱<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> cp config/initializers/rack_attack.rb.example config/initializers/rack_attack.rb</span><br><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> git config --<span class="keyword">global</span> user.name <span class="string">"GitLab"</span></span><br><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> git config --<span class="keyword">global</span> user.email <span class="string">"username@163.com"</span></span><br><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> git config --<span class="keyword">global</span> core.autocrlf <span class="keyword">input</span></span><br></pre></td></tr></table></figure></p>
<h4 id="GitLab_SMTP设置"><strong>GitLab SMTP设置</strong></h4><p>&emsp;<code>GitLab</code>默认使用<strong>Sendmail</strong>进行邮件的发送，邮件发送配置比较重要，当新建用户时<code>GitLab</code>会发送一封邮件给用户并要求重置密码，若要使用<strong>SMTP</strong>发送邮件则需如下配置(此处用的是163邮箱)。<br>&emsp;编辑配置文件<strong><code>sudo -u git -H vim /home/git/gitlab/config/environments/production.rb</code></strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config<span class="class">.action_mailer</span><span class="class">.delivery_method</span>= :smtp</span><br></pre></td></tr></table></figure></p>
<p>&emsp;编辑配置文件<strong><code>sudo -u git -H vim /home/git/gitlab/config/initializers/smtp_settings.rb</code></strong><br>&emsp;<strong><code>domain</code></strong>选项用于重置密码时访问的<code>GitLab</code>域名，根据自身情况配置，如<code>domain: &quot;test.com:8080&quot;</code><br>&emsp;<strong><code>enable_starttls_auto</code></strong>假若SMTP没有开启加密连接则此值设置为<code>false</code><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; cp <span class="regexp">/home/</span>git<span class="regexp">/gitlab/</span>config<span class="regexp">/initializers/</span>smtp_settings.rb.sample <span class="regexp">/home/</span>git<span class="regexp">/gitlab/</span>config<span class="regexp">/initializers/</span>smtp_settings.rb</span><br><span class="line">#smtp_settings.rb</span><br><span class="line">	<span class="keyword">if</span> Rails.env.production?</span><br><span class="line">	  Gitlab::Application.config.action_mailer.delivery_method = :smtp</span><br><span class="line"><span class="label"></span><br><span class="line">	  ActionMailer:</span>:Base.smtp_settings = &#123;</span><br><span class="line"><span class="label">		address:</span> <span class="string">"smtp.163.com"</span>,</span><br><span class="line"><span class="label">		port:</span> <span class="number">25</span>,</span><br><span class="line"><span class="label">		user_name:</span> <span class="string">"username@163.com"</span>,</span><br><span class="line"><span class="label">		password:</span> <span class="string">"password"</span>,</span><br><span class="line"><span class="label">		domain:</span> <span class="string">"domain.com"</span>,</span><br><span class="line"><span class="label">		authentication:</span> :login,</span><br><span class="line"><span class="label">		enable_starttls_auto:</span> <span class="literal">false</span></span><br><span class="line">	  &#125;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;假若SMTP服务器只允许以用登陆方式发送邮件，则还需要配置<strong><code>sudo -u git -H vim /home/git/gitlab/config/gitlab.yml</code></strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">email_from</span>: username<span class="variable">@163</span>.com</span><br></pre></td></tr></table></figure></p>
<h3 id="GitLab连接Redis配置"><strong>GitLab连接Redis配置</strong></h3><p>&emsp;假若redis有自定义优化配置，则按自身需求修改配置文件<code>sudo -u git -H vim /home/git/gitlab/config/resque.yml</code>，否则按照默然配置(此处按照默认)<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; sudo -u git -H cp <span class="regexp">/home/gi</span>t<span class="regexp">/gitlab/</span>config<span class="regexp">/resque.yml.example /</span>home<span class="regexp">/git/gi</span>tlab<span class="regexp">/config/</span>resque.yml</span><br></pre></td></tr></table></figure></p>
<h3 id="GitLab连接MySQL配置"><strong>GitLab连接MySQL配置</strong></h3><p>&emsp;根据自身MySQL配置修改文件<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; sudo -u git cp <span class="regexp">/home/</span>git<span class="regexp">/gitlab/</span>config<span class="regexp">/database.yml.mysql /</span>home<span class="regexp">/git/</span>gitlab<span class="regexp">/config/</span>database.yml</span><br><span class="line">shell&gt; sudo -u git -H vim <span class="regexp">/home/</span>git<span class="regexp">/gitlab/</span>config/database.yml</span><br><span class="line"><span class="label">			production:</span></span><br><span class="line"><span class="label">				adapter:</span> mysql2</span><br><span class="line"><span class="label">				encoding:</span> utf8</span><br><span class="line"><span class="label">				collation:</span> utf8_general_ci</span><br><span class="line"><span class="label">				reconnect:</span> <span class="literal">false</span></span><br><span class="line"><span class="label">				database:</span> gitlabhq_production</span><br><span class="line"><span class="label">				pool:</span> <span class="number">10</span></span><br><span class="line"><span class="label">				username:</span> git</span><br><span class="line"><span class="label">				password:</span> <span class="string">"gitlab"</span></span><br><span class="line"><span class="label">				host:</span> localhost</span><br><span class="line"><span class="label">				socket:</span> <span class="regexp">/var/</span>lib<span class="regexp">/mysql/</span>mysql.sock</span><br></pre></td></tr></table></figure></p>
<h3 id="安装Gem"><strong>安装Gem</strong></h3><p>&emsp;如果太慢或根本无法下载安装，则可把<strong><code>/home/git/gitlab/Gemfile</code></strong>中的源需要改成淘宝的源<br>&emsp;安装前需要先安装libicu-devel及cmake，否则会报错<code>An error occurred while installing charlock_holmes (0.6.9.4)/rugged (0.21.2), and Bundler cannot continue.</code><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span>&gt; yum -y install libicu-devel cmake</span><br><span class="line"></span><br><span class="line">#修改源</span><br><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> vim /home/git/gitlab/Gemfile</span><br><span class="line">			source 'https:<span class="comment">//ruby.taobao.org/'</span></span><br><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> bundle install --deployment --without development <span class="keyword">test</span> postgres aws</span><br></pre></td></tr></table></figure></p>
<h3 id="安装GitLat_shell"><strong>安装GitLat shell</strong></h3><p>&emsp;根据自身情况可修改<code>GitLab shell</code>的配置文件<strong><code>sudo -u git -H vim /home/git/gitlab-shell/config.yml</code></strong><br>&emsp;<code>GitLab-shell</code>的版本使用<strong><code>2.0.1</code></strong>，原本使用<strong><code>2.2.0</code></strong>版本但在<code>git push</code>的时候会报错，此为GitLab-shell版本的问题导致。可以通过<strong><code>sudo -u git -H bundle exec rake gitlab:check RAILS_ENV=production</code></strong>该命令检查<code>GitLab-shell</code>是否正确<br>&emsp;<code>git push</code>时报错内容如下：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Check GitLab API access: /home/git/gitlab-shell/<span class="keyword">lib</span>/gitlab_net.rb:<span class="number">122</span>:<span class="keyword">in</span> `read<span class="comment">': No such file or directory @ rb_sysopen - /home/git/gitlab-shell/.gitlab_shell_secret (Errno::ENOENT)</span></span><br><span class="line">        <span class="keyword">from</span> /home/git/gitlab-shell/<span class="keyword">lib</span>/gitlab_net.rb:<span class="number">122</span>:<span class="keyword">in</span> `secret_token<span class="comment">'</span></span><br><span class="line">        <span class="keyword">from</span> /home/git/gitlab-shell/<span class="keyword">lib</span>/gitlab_net.rb:<span class="number">79</span>:<span class="keyword">in</span> `<span class="keyword">get</span><span class="comment">'</span></span><br><span class="line">        <span class="keyword">from</span> /home/git/gitlab-shell/<span class="keyword">lib</span>/gitlab_net.rb:<span class="number">39</span>:<span class="keyword">in</span> `check<span class="comment">'</span></span><br><span class="line">        <span class="keyword">from</span> /home/git/gitlab-shell/bin/check:<span class="number">11</span>:<span class="keyword">in</span> `&lt;main&gt;<span class="comment">''</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;<del>2.2.0</del>版本试过有问题，git push报错，请使用2.0.1版本<br><del>shell&gt; sudo -u git -H bundle exec rake gitlab:shell:install[v2.2.0] REDIS_URL=unix:/var/run/redis/redis.sock RAILS_ENV=production</del><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> bundle exec rake gitlab:<span class="keyword">shell</span>:install[v2.0.1] REDIS_URL=unix:/<span class="keyword">var</span>/<span class="keyword">run</span>/redis/redis.sock RAILS_ENV=production</span><br></pre></td></tr></table></figure></p>
<p>&emsp;<strong><code>/home/git/gitlab-shell/config.yml</code></strong>的配置，是否使用HTTPS决定某些配置项的细微差别(以下是使用HTTPS)<br>&emsp;<strong><code>gitlab_url</code></strong>和<strong><code>self_signed_cert</code></strong>的配置必须匹配，否则在<strong><code>git push</code></strong>的时候会报错<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="string">user:</span> git</span><br><span class="line"><span class="string">gitlab_url:</span> <span class="string">https:</span><span class="comment">//yourdomain/</span></span><br><span class="line"><span class="string">http_settings:</span></span><br><span class="line"><span class="label">  self_signed_cert:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">repos_path:</span> <span class="string">"/home/git/repositories/"</span></span><br><span class="line"><span class="string">auth_file:</span> <span class="string">"/home/git/.ssh/authorized_keys"</span></span><br><span class="line"><span class="string">redis:</span></span><br><span class="line"><span class="label">  bin:</span> <span class="string">"/usr/bin/redis-cli"</span></span><br><span class="line"><span class="label">  namespace:</span> <span class="string">resque:</span>gitlab</span><br><span class="line"><span class="label">  socket:</span> <span class="string">"/var/run/redis/redis.sock"</span></span><br><span class="line"><span class="string">log_level:</span> INFO</span><br><span class="line"><span class="string">audit_usernames:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="初始化数据库"><strong>初始化数据库</strong></h3><p>&emsp;设置<code>GitLab</code>的root用户密码并初始化数据库<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span>&gt; sudo -<span class="keyword">u</span> git -<span class="keyword">H</span> bundle exec rake gitlab:setup RAILS_ENV=production GITLAB_ROOT_PASSWORD=your_gitlab_root_passwd</span><br></pre></td></tr></table></figure></p>
<h3 id="下载GitLab脚本"><strong>下载GitLab脚本</strong></h3><p>&emsp;下载管理<code>GitLab</code>的脚本，设置<code>logrotate</code>，检查应用状态<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; wget -O <span class="regexp">/etc/</span>init.d<span class="regexp">/gitlab https:/</span><span class="regexp">/gitlab.com/</span>gitlab-org<span class="regexp">/gitlab-recipes/</span>raw<span class="regexp">/master/</span>init<span class="regexp">/sysvinit/</span>centos/gitlab-unicorn --no-check-certificate</span><br><span class="line">shell&gt; chmod a+x <span class="regexp">/etc/</span>init.d/gitlab</span><br><span class="line">shell&gt; cp lib<span class="regexp">/support/</span>logrotate<span class="regexp">/gitlab /</span>etc<span class="regexp">/logrotate.d/</span>gitlab</span><br><span class="line">shell&gt; sudo -u git -H bundle exec rake <span class="string">gitlab:</span><span class="string">env:</span>info RAILS_ENV=production</span><br><span class="line">			System information</span><br><span class="line"><span class="label">			System:</span>         CentOS <span class="number">6.4</span></span><br><span class="line">			Current <span class="string">User:</span>   git</span><br><span class="line">			Using <span class="string">RVM:</span>      no</span><br><span class="line">			Ruby <span class="string">Version:</span>   <span class="number">2.1</span><span class="number">.2</span>p95</span><br><span class="line">			Gem <span class="string">Version:</span>    <span class="number">2.2</span><span class="number">.2</span></span><br><span class="line">			Bundler <span class="string">Version:</span><span class="number">1.10</span><span class="number">.6</span></span><br><span class="line">			Rake <span class="string">Version:</span>   <span class="number">10.3</span><span class="number">.2</span></span><br><span class="line">			Sidekiq <span class="string">Version:</span><span class="number">2.17</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">			GitLab information</span><br><span class="line"><span class="label">			Version:</span>        <span class="number">7.4</span><span class="number">.5</span></span><br><span class="line"><span class="label">			Revision:</span>       <span class="number">19</span>d572e</span><br><span class="line"><span class="label">			Directory:</span>      <span class="regexp">/home/</span>git/gitlab</span><br><span class="line">			DB <span class="string">Adapter:</span>     mysql2</span><br><span class="line"><span class="label">			URL:</span>            <span class="string">http:</span><span class="comment">//yourdomain</span></span><br><span class="line">			HTTP Clone <span class="string">URL:</span> <span class="string">http:</span><span class="comment">//yourdomain/some-project.git</span></span><br><span class="line">			SSH Clone <span class="string">URL:</span>  git<span class="annotation">@yourdomain</span>:some-project.git</span><br><span class="line">			Using <span class="string">LDAP:</span>     no</span><br><span class="line">			Using <span class="string">Omniauth:</span> no</span><br><span class="line"></span><br><span class="line">			GitLab Shell</span><br><span class="line"><span class="label">			Version:</span>        <span class="number">2.0</span><span class="number">.1</span></span><br><span class="line"><span class="label">			Repositories:</span>   <span class="regexp">/home/</span>git<span class="regexp">/repositories/</span></span><br><span class="line"><span class="label">			Hooks:</span>          <span class="regexp">/home/</span>git<span class="regexp">/gitlab-shell/</span>hooks/</span><br><span class="line"><span class="label">			Git:</span>            <span class="regexp">/usr/</span>bin/git</span><br><span class="line">shell&gt; sudo -u git -H bundle exec rake <span class="string">assets:</span>precompile RAILS_ENV=production</span><br><span class="line">shell&gt; <span class="regexp">/etc/</span>init.d/gitlab start</span><br></pre></td></tr></table></figure></p>
<h3 id="配置Nginx"><strong>配置Nginx</strong></h3><p>&emsp;要通过web访问需要配置web服务器，这里选择Nginx。<br>&emsp;配置主要是修改<strong><code>server_name</code></strong>，自定义日志路径等。可适当调大<strong><code>client_max_body_size</code></strong>的值(防止推送时数据过大而出错)<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#使用SSL</span><br><span class="line"><span class="keyword">shell</span>&gt; wget -O /usr/local/nginx/<span class="keyword">conf</span>/vhosts/gitlab.<span class="keyword">conf</span> http<span class="variable">s:</span>//gitlab.<span class="keyword">com</span>/gitlab-org/gitlab-<span class="keyword">ce</span>/raw/master/lib/support/nginx/gitlab-ssl --<span class="keyword">no</span>-check-certificate</span><br><span class="line"></span><br><span class="line">#不使用SSL</span><br><span class="line"><span class="keyword">shell</span>&gt; wget -O /usr/local/nginx/<span class="keyword">conf</span>/vhosts/gitlab.<span class="keyword">conf</span> http<span class="variable">s:</span>//gitlab.<span class="keyword">com</span>/gitlab-org/gitlab-<span class="keyword">ce</span>/raw/master/lib/support/nginx/gitlab --<span class="keyword">no</span>-check-certificate</span><br><span class="line"></span><br><span class="line">#生成证书，将gitlab.crt和gitlab.key放到Nginx配置文件gitlab.<span class="keyword">conf</span>中ssl指定的目录下</span><br><span class="line"><span class="keyword">shell</span>&gt; openssl req -<span class="keyword">new</span> -x509 -nodes -days <span class="number">3560</span> -out gitlab.crt -keyout gitlab.key</span><br><span class="line"></span><br><span class="line"><span class="keyword">shell</span>&gt; usermod -<span class="keyword">a</span> -G git nginx &amp;&amp; chmod <span class="keyword">g</span>+rx /home/git/</span><br></pre></td></tr></table></figure></p>
<h3 id="关于git_clone"><strong>关于git clone</strong></h3><p>&emsp;一般从远程库克隆仓库到本地使用<code>git clone</code>命令，克隆有两种方式<strong>SSH</strong>(<code>git clone git@gitlab_server:username/repo_name.git</code>)和<strong>HTTPS</strong>(<code>git clone https://gitlab_server/username/repo_name.git</code>)。假若添加了<strong>SSH KEY</strong>就使用<strong>SSH</strong>即可，但为了使用<strong>HTTPS</strong>方式克隆，折腾了很久！又是安装<strong>gitlab-git-http-server</strong>又是安装<strong>GO</strong>，网上搜索折腾了很久都无果，最后灵机一动搞定了！</p>
<p>&emsp;假若<strong>HTTPS</strong>方式克隆报错<strong><code>Peer certificate cannot be authenticated with known CA certificates</code></strong>，则在需要克隆的机器上的<strong><code>~/.bash_profile</code></strong>添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GIT_SSL_NO_VERIFY=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加后重新加载</span></span><br><span class="line">shell&gt; <span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></p>
<p>&emsp;CentOS上使用<code>yum</code>安装的<code>git</code>版本为<strong><code>1.7.1</code></strong>，在使用<strong><code>git clone</code></strong>克隆GitLab仓库时若出现如下报错则需要手动编译<strong>2.0</strong>版本以上的<strong>git</strong>(编译安装详见上文)<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">error:</span>  <span class="keyword">while</span> accessing <span class="string">https:</span><span class="comment">//gitlab_server/username/repo_name.git/info/refs</span></span><br><span class="line"><span class="string">fatal:</span> HTTP request failed</span><br></pre></td></tr></table></figure></p>
<p>&emsp;GitLab默认的Nginx配置文件中定义了规则，将<strong>HTTPS</strong>方式克隆的请求转到<code>gitlab-git-http-server.socket</code>，问题是GitLab默认并没有启用<strong>gitlab-git-http-server</strong>。若要安装<code>gitlab-git-http-server</code>则需先安装<code>Go</code>，当安装好<code>gitlab-git-http-server</code>后发现仍然无法使用。最后抱着试试看的心态将<code>upstream</code>转到<code>gitlab.socket</code>而非<code>gitlab-git-http-server.socket</code>，然后<strong>HTTPS</strong>方式的克隆就搞定了！<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">upstream gitlab-git-http-server </span><span class="expression">&#123;</span><br><span class="line">  #默认配置</span><br><span class="line">  <span class="begin-block">#server unix</span>:<span class="end-block">/home</span><span class="end-block">/git</span><span class="end-block">/gitlab</span><span class="end-block">/tmp</span><span class="end-block">/sockets</span><span class="end-block">/gitlab-git-http-server.socket fail</span>_<span class="variable">timeout</span>=0;</span><br><span class="line"></span><br><span class="line">  #修改后</span><br><span class="line">  <span class="variable">server</span> <span class="variable">unix</span>:<span class="end-block">/home</span><span class="end-block">/git</span><span class="end-block">/gitlab</span><span class="end-block">/tmp</span><span class="end-block">/sockets</span><span class="end-block">/gitlab.socket fail</span>_<span class="variable">timeout</span>=0;</span><br><span class="line">&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location ~ [-\/\w\.]+\.git\/ </span><span class="expression">&#123;</span><br><span class="line">	#其余详细配置省略</span><br><span class="line">	<span class="variable">proxy</span>_<span class="variable">pass</span> <span class="variable">http</span>:/<span class="end-block">/gitlab-git-http-server</span>;</span><br><span class="line">&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;最近在系统的学习<strong>Git</strong>，需要用到远程仓库，于是想搭个<strong>GitLab</strong>玩玩。没想到想玩好GitLab也不是件容易的事情，即便是按照教程来搭都折腾了挺久，GitLab对各软件版本的要求比较苛刻，所以搭建]]>
    </summary>
    
      <category term="GitLab" scheme="http://yoursite.com/tags/GitLab/"/>
    
      <category term="OPS" scheme="http://yoursite.com/categories/OPS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HAProxy]]></title>
    <link href="http://yoursite.com/2015/09/28/haproxy/"/>
    <id>http://yoursite.com/2015/09/28/haproxy/</id>
    <published>2015-09-28T02:38:07.000Z</published>
    <updated>2015-09-28T02:49:50.000Z</updated>
    <content type="html"><![CDATA[<p>&emsp;HAProxy能用做负载均衡服务器，也可以用于做四层(TCP)、七层(HTTP)代理</p>
<h2 id="HAProxy安装"><strong>HAProxy安装</strong></h2><p>&emsp;从<a href="http://www.haproxy.org/#down" target="_blank" rel="external">这里</a>下载HAProxy的源码包，此处用的是：</p>
<ul>
<li>CentOS6.4 64bit</li>
<li>haproxy-1.5.14</li>
</ul>
<p>&emsp;确认内核版本<code>uname -r</code>(此机器内核信息：<code>2.6.32-358.el6.x86_64</code>)，编译参数<strong><code>TARGET</code></strong>可用值<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> linux22     <span class="keyword">for</span> <span class="constant">Linux</span> <span class="number">2.2</span></span><br><span class="line"></span>-<span class="ruby"> linux24     <span class="keyword">for</span> <span class="constant">Linux</span> <span class="number">2.4</span> <span class="keyword">and</span> above (default)</span><br><span class="line"></span>-<span class="ruby"> linux24e    <span class="keyword">for</span> <span class="constant">Linux</span> <span class="number">2.4</span> with support <span class="keyword">for</span> a working epoll (&gt; <span class="number">0</span>.<span class="number">21</span>)</span><br><span class="line"></span>-<span class="ruby"> linux26     <span class="keyword">for</span> <span class="constant">Linux</span> <span class="number">2.6</span> <span class="keyword">and</span> above</span><br><span class="line"></span>-<span class="ruby"> linux2628   <span class="keyword">for</span> <span class="constant">Linux</span> <span class="number">2.6</span>.<span class="number">28</span>, <span class="number">3</span>.x, <span class="keyword">and</span> above (enables splice <span class="keyword">and</span> tproxy)</span><br><span class="line"></span>-<span class="ruby"> solaris     <span class="keyword">for</span> <span class="constant">Solaris</span> <span class="number">8</span> <span class="keyword">or</span> <span class="number">10</span> (others untested)</span><br><span class="line"></span>-<span class="ruby"> freebsd     <span class="keyword">for</span> <span class="constant">FreeBSD</span> <span class="number">5</span> to <span class="number">10</span> (others untested)</span><br><span class="line"></span>-<span class="ruby"> osx         <span class="keyword">for</span> <span class="constant">Mac</span> <span class="constant">OS</span>/<span class="constant">X</span></span><br><span class="line"></span>-<span class="ruby"> openbsd     <span class="keyword">for</span> <span class="constant">OpenBSD</span> <span class="number">3.1</span> to <span class="number">5.2</span> (others untested)</span><br><span class="line"></span>-<span class="ruby"> aix51       <span class="keyword">for</span> <span class="constant">AIX</span> <span class="number">5.1</span></span><br><span class="line"></span>-<span class="ruby"> aix52       <span class="keyword">for</span> <span class="constant">AIX</span> <span class="number">5.2</span></span><br><span class="line"></span>-<span class="ruby"> cygwin      <span class="keyword">for</span> <span class="constant">Cygwin</span></span><br><span class="line"></span>-<span class="ruby"> generic     <span class="keyword">for</span> any other <span class="constant">OS</span> <span class="keyword">or</span> version.</span><br><span class="line"></span>-<span class="ruby"> custom      to manually adjust every setting</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;确定<code>TARGET</code>参数后编译安装HAProxy<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf haproxy-1.5.14.tar.gz</span><br><span class="line"><span class="keyword">cd</span> haproxy-1.5.14</span><br><span class="line">make TARGET=linux26 PREFIX=/usr/<span class="keyword">local</span>/haproxy</span><br><span class="line">make install PREFIX=/usr/<span class="keyword">local</span>/haproxy</span><br><span class="line"><span class="keyword">mkdir</span> -p /usr/<span class="keyword">local</span>/haproxy/&#123;etc,<span class="keyword">log</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;如果不需要编译安装，可以使用<code>yum</code>进行安装(haproxy版本会比较旧)<br>&emsp;&emsp;<strong><code>yum -y install haproxy</code></strong></p>
<h2 id="日志配置"><strong>日志配置</strong></h2><p>&emsp;HAProxy默认无日志输出功能，需要相关日志配置。在CentOS6.4中通过配置<code>rsyslog</code>实现记录日志功能</p>
<ol>
<li><p>创建<strong><code>/etc/rsyslog.d/haproxy.conf</code></strong>配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ModLoad</span> imudp</span><br><span class="line"><span class="variable">$UDPServerRun</span> <span class="number">514</span></span><br><span class="line"><span class="built_in">local</span>3.* /usr/<span class="built_in">local</span>/haproxy/<span class="built_in">log</span>/haproxy.log</span><br><span class="line">&amp; ~</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>$ModLoad imudp</strong>：imudp是模块名，支持UDP协议</li>
<li><strong>$UDPServerRun 514</strong>：允许514端口接收使用UDP和TCP协议转发过来的日志，rsyslog默认在514端口监听UDP</li>
<li><strong>local3</strong>：此为facility参数，描述提交的日志信息的应用程序或进程。如邮件、内核和FTP等，local0~7为用户自定义。详细请查看<a href="https://en.wikipedia.org/wiki/Syslog#Facility" target="_blank" rel="external">这里</a></li>
<li><code>&amp; ~</code>：停止对日志消息的进一步处理，并且不要在本地写入。如果没有此重定向规则，日志消息会被重复写入到本地<code>/var/log/message</code>文件</li>
</ul>
</li>
<li><p>修改rsyslog配置文件<strong><code>/etc/sysconfig/rsyslog</code></strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">SYSLOGD_OPTIONS=<span class="value"><span class="string">"-c 2 -r -m 0"</span></span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>-c</code></strong>：指定模式，SYSLOGD_OPTIONS选项在rsyslog v3版本被弃用，需要使用切换到模式2</li>
<li><strong><code>-r</code></strong>：接受远程日志</li>
<li><strong><code>-m</code></strong>：标记时间戳，0表示禁用</li>
</ul>
</li>
</ol>
<h2 id="HAProxy配置"><strong>HAProxy配置</strong></h2><p>&emsp;HAProxy配置文件<strong><code>/usr/local/haproxy/etc/haproxy.cfg</code></strong>(若是<code>yum</code>安装则是<strong><code>/etc/haproxy/haproxy.cfg</code></strong>)<br>&emsp;HAProxy的配置文件主要由以下几个部分组成，官方1.5版本详细配置说明请查看<a href="http://www.haproxy.org/download/1.5/doc/configuration.txt" target="_blank" rel="external">这里</a></p>
<ul>
<li><strong>global</strong>：全局配置，配置涉及进程管理及安全相关内容。</li>
<li><strong>defaults</strong>：默认参数配置，配置后的参数可用于<code>listen</code>、<code>frontend</code>、<code>backend</code></li>
<li><strong>frontend</strong>：定义前端接受请求的监听节点</li>
<li><strong>backend</strong>：定义后端服务器节点，类似于Nginx的<code>upstream</code></li>
<li><strong>listen</strong>：关联<code>frontend</code>和<code>backend</code>组成一个完整的代理节点</li>
</ul>
<p>&emsp;接下来逐个分析每个部分的详细配置</p>
<h3 id="global"><strong>global</strong></h3><p>&emsp;如上所述，<strong>global</strong>为全局配置参数，主要是进程管理及安全的参数。可设置的参数非常多，详细查看官方配置说明文档，这里仅说明较常用的几个参数</p>
<ul>
<li><strong>chroot</strong>：修改HAProxy的工作目录并在放弃权限之前执行 chroot()操作</li>
<li><strong>daemon</strong>：以守护进程方式启动</li>
<li><strong>log</strong>：定义日志。log ip facility [level]，Example：log 127.0.0.1 local3 info</li>
<li><strong>nbproc</strong>：设置HAProxy启动进程数，默认一个进程。nbproc 1</li>
<li><strong>uid</strong>：指定以UID用户运行HAProxy</li>
<li><strong>maxconn</strong>：设置每个HAProxy进程能接受的最大并发数</li>
<li><strong>debug</strong>：开启debug，生产环节禁用</li>
<li><strong>quiet</strong>：启动HAProxy时不显示任何信息</li>
</ul>
<p>&emsp;常见<strong>global</strong>配置实例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    log <span class="number">127.0</span>.<span class="number">0.1</span> local3</span><br><span class="line">    maxconn <span class="number">4096</span></span><br><span class="line">    chroot /usr/local/haproxy</span><br><span class="line">    pidfile /usr/local/haproxy/haproxy<span class="class">.pid</span></span><br><span class="line">    uid <span class="number">99</span></span><br><span class="line">    gid <span class="number">99</span></span><br><span class="line">    daemon</span><br><span class="line">    <span class="id">#quiet</span></span><br><span class="line">    <span class="hexcolor">#deb</span>ug</span><br></pre></td></tr></table></figure></p>
<h3 id="defaults"><strong>defaults</strong></h3><p>&emsp;<strong>defaults</strong>用于统一设置<code>listen</code>、<code>frontend</code>、<code>backend</code>的默认参数</p>
<ul>
<li><strong>log</strong>：设置日志，如果<strong>global</strong>已经配置好日志，就直接写<code>log global</code></li>
<li><strong>mode</strong>：工作模式，<strong><code>mode {tcp|http|health}</code></strong>。设置HAProxy实例运行的模式或协议，<code>frontend</code>和<code>backend</code>需要运行在同一模式<ul>
<li><code>tcp</code>：纯TCP工作模式，在client和server之间建立一个TCP连接代理，仅用作4层代理转发，常用于SSH、SMTP、POP3等代理。</li>
<li><code>http</code>：HTTP工作模式，HAProxy能对客户端的7层请求进行分析进而过滤、处理及转发等动作。</li>
<li><code>health</code>：health模式，对进入HAProxy的连接仅回复’OK’并关闭连接。</li>
</ul>
</li>
<li><strong>option httplog [clf]</strong>：记录HTTP请求、会话状态和计时器。clf格式记录</li>
<li><strong>option dontlognull</strong>：不记录null日志</li>
<li><strong>option logasap</strong>：提前将 HTTP 请求记入日志，而不等待 HTTP 报文传输完毕</li>
<li><strong>option forwardfor</strong>：在发往服务器的请求中插入<code>X-Forwarded-For</code>首部用于记录客户端的IP。<code>option forwardfor except 127.0.0.0/8</code>不记录本机转发日志</li>
<li><strong>retries <integer></integer></strong>：设置对某个服务器连接失败后重试的次数</li>
<li><strong>option redispatch</strong>：连接失败时重新分发会话</li>
<li><strong>option http-keep-alive <time></time></strong>：设置http keepalive时间，既允许空闲连接的时间</li>
<li><strong>option http-server-close</strong>：每次请求完毕后主动关闭http连接</li>
<li><strong>timeout http-request <time></time></strong>：http请求超时时间</li>
</ul>
<p>&emsp;常见<strong>defaults</strong>配置实例：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defaults</span><br><span class="line">    <span class="command">log</span>     <span class="keyword">global</span></span><br><span class="line">    mode	http</span><br><span class="line">    option	httplog</span><br><span class="line">    option	dontlognull</span><br><span class="line">    retries	<span class="number">3</span></span><br><span class="line">    maxconn	<span class="number">2000</span></span><br><span class="line">    <span class="comment">#option forwardfor</span></span><br><span class="line">    <span class="comment">#option http-keep-alive 10s</span></span><br><span class="line">    <span class="comment">#timeout http-request 10s</span></span><br><span class="line">    <span class="keyword">timeout</span> connect <span class="number">5000</span></span><br><span class="line">    <span class="keyword">timeout</span> client <span class="number">50000</span></span><br><span class="line">    <span class="keyword">timeout</span> server <span class="number">50000</span></span><br></pre></td></tr></table></figure></p>
<h3 id="listen_frontend_backend"><strong>listen    frontend backend</strong></h3><p>&emsp;<code>listen</code>、<code>frontend</code>、<code>backend</code>通过实例详细解释相关参数以及用法</p>
<h4 id="HAProxy状态统计"><strong>HAProxy状态统计</strong></h4><p>&emsp;<code>listen</code>常见用法<strong><code>listen &lt;name&gt; ip:port</code></strong>，也可以先只指定<code>listen &lt;name&gt;</code>然后在内部用<code>bind ip:port</code><br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listen <span class="literal">status</span> *:<span class="number">8000</span>					<span class="comment">#绑定ip及port</span></span><br><span class="line">    stats <span class="literal">enable</span>						<span class="comment">#开启状态输出页面</span></span><br><span class="line">    stats hide-version					<span class="comment">#隐藏HAProxy版本号</span></span><br><span class="line">    stats uri   /haproxy?stats			<span class="comment">#访问url</span></span><br><span class="line">    stats realm  <span class="constant">H</span>AProxy\ <span class="constant">Statistics</span>		<span class="comment">#提示信息</span></span><br><span class="line">    stats auth  admin:<span class="literal">password</span>		<span class="comment">#验证的用户及密码</span></span><br></pre></td></tr></table></figure></p>
<h3 id="SMTP_代理"><strong>SMTP 代理</strong></h3><p>&emsp;利用HAProxy做简单的SMTP邮件代理<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen smtp *:<span class="number">25</span></span><br><span class="line">    <span class="built_in">log</span>  global</span><br><span class="line">    mode tcp	</span><br><span class="line">    <span class="keyword">option</span> tcplog</span><br><span class="line">    <span class="built_in">server</span> smtp <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">25</span> check</span><br></pre></td></tr></table></figure></p>
<h3 id="HTTP代理+健康检测"><strong>HTTP代理+健康检测</strong></h3><p>&emsp;简单的HTTP代理及基础检测<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">listen http_proxy *:80</span><br><span class="line">    mode http</span><br><span class="line">    cookie SERVERID					<span class="comment">#允许cookie记录serverid</span></span><br><span class="line">    balance roundrobin				<span class="comment">#负载均衡算法</span></span><br><span class="line">    option forwardfor</span><br><span class="line">    option httplog clf				<span class="comment">#使用httplog并使用clf日志格式</span></span><br><span class="line">    option httpchk GET /index.html	<span class="comment">#健康检测，使用HTTP请求通过HTTP CODE判断健康状态，2xx 和 3xx 的响应码表示健康状态，其他响应码或无响应表示服务器故障。</span></span><br><span class="line">    <span class="comment">#option httpchk HEAD /index.jsp HTTP/1.1\r\nHost:\ www.test.com		#更精确的健康检测，对HTTP头部进行检测</span></span><br><span class="line">    server web1 192.168.1.1:80 cookie server_id_1<span class="instruction"> check</span><br><span class="line"></span>    server web2 192.168.1.2:80 cookie server_id_2<span class="instruction"> check </span>inter 500 rise 1 fall 2 backup</span><br></pre></td></tr></table></figure></p>
<p>&emsp;重点解释一下<code>server web2 192.168.1.2:80 cookie server_id_2 check inter 500 rise 1 fall 2</code></p>
<ul>
<li><strong>server web2 192.168.1.2:80</strong>：定义server的名称、IP及端口</li>
<li><strong>cookie server_id_2</strong>：设定每个server的cookie serverid(前面已经允许cookie记录serverid)</li>
<li><strong>check</strong>：启用健康检查</li>
<li><strong>inter 500</strong>：检查的时间间隔，500毫秒</li>
<li><strong>rise 1</strong>：server需要被检查X次正常后才认为可用</li>
<li><strong>fall 2</strong>：server需要被检查X次失败后才认为不可用</li>
<li><strong>backup</strong>：作为备份，类似Nginx upstream中的backup。web1不可用后才使用web2</li>
<li><strong>weight</strong>：设置server权重，上面例子没用到</li>
<li><strong>balance</strong>：指定HAProxy的负载均衡算法<ul>
<li>roundrobin：基于权重的轮询算法。假若服务器处理时间均匀的情况下，此算法是最平衡及公平的，权重值动态调整，但每个后端服务器限制接受4095个活动链接</li>
<li>static-rr：基于权重的轮询算法。和roundrobin类似，不同的是权重值为静态方法，不会进行动态调整，但后端服务器无连接限制</li>
<li>leastconn：将新请求转发到最少连接数的后端服务器上。推荐在长会话中使用(LDAP/SQL/TSE)，短会话(HTTP)不太适合。算法是动态的，可在运行时调整权重</li>
<li>first：此算法将所有请求都转发到backend的第一台服务器上，当该服务器达到最大连接数后则转发到下一台服务器。</li>
<li>source：此算法将源IP进行hash，并由后端服务器的权重总数相除后决定转发。使得相同IP的请求能被转发到后端的同一台服务器上，但当后端服务器权重改变时很可能会重新分配转发。常用于基于TCP的无cookies场景</li>
<li>uri：将URI左边部分(?之前)或整个URI进行hash，并由后端服务器的权重总数相除后决定转发。使得相同URI的请求能被转发到后端同一台服务器上，但当后端服务器权重改变时很可能会重新分配转发。常用于代理缓存或反病毒代理，此算法仅用于HTTP后端服务器场景</li>
<li>url_param：通过检索HTTP GET请求中URL指定的参数进行转发。可使得具有相同URL参数的请求(如userid)能被转发到后端同一台服务器上，除非权重发生变化。</li>
<li>hdr(header parament)：对HTTP HEADER进行检索决定转发。</li>
<li>rdp-cookie：根据cookie锁定并hash每个TCP请求</li>
</ul>
</li>
</ul>
<h3 id="HTTP代理+ACL规则"><strong>HTTP代理+ACL规则</strong></h3><p>&emsp;不使用<code>listen</code>而是使用<code>frontend</code>和<code>backend</code>再加上ACL规则进行HTTP代理<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frontend http_acl *:5000</span><br><span class="line">    mode http</span><br><span class="line">    option forwardfor</span><br><span class="line">    option httplog clf</span><br><span class="line">    acl<span class="keyword"> static</span>_resource path_beg -i /static /images</span><br><span class="line">    acl<span class="keyword"> static</span>_resource	path_end -i .jpg .gif .png</span><br><span class="line">    use_backend backend_res_server<span class="instruction"> if </span>static_resource</span><br><span class="line">    default_backend backend_app_server</span><br><span class="line"></span><br><span class="line">backend backend_res_server</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server<span class="keyword"> static</span>_server_1.155 10.0.1.155:80<span class="instruction"> check</span><br><span class="line"></span></span><br><span class="line">backend backend_app_server</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server ap<span class="variable">p1</span> 10.0.6.5:8888<span class="instruction"> check</span><br><span class="line"></span>    server ap<span class="variable">p2</span> 10.0.6.6:8888 check</span><br></pre></td></tr></table></figure></p>
<p>逐个分析配置语句，之前提过的省略</p>
<ul>
<li><strong><code>frontend http_acl *:5000</code></strong>：创建名为<code>http_acl</code>的<code>frontend</code>，监听<code>5000</code>端口</li>
<li><strong><code>acl static_resource path_end -i .jpg .gif .png</code></strong>：<ul>
<li><code>acl static_resource</code>：创建ACL规则，此规则名为<code>static_resource</code></li>
<li><code>path_beg/path_end -i .jpg</code>：匹配URL路径中开始/结束字符，例子中以<code>.jpg .gif .png</code>结束的字符，<code>-i</code>忽略大小写</li>
</ul>
</li>
<li><strong><code>use_backend</code></strong>：指定满足ACL规则的后端服务器。<code>use_backend &lt;backend&gt; &lt;if | unless&gt; &lt;condition&gt;</code></li>
<li><strong><code>default_backend</code></strong>：默认的后端服务器</li>
<li><strong>backend <backend_name></backend_name></strong>：创建后端服务器组</li>
</ul>
<p>ACL规则还有很多应用，列举一些简单例子：</p>
<ul>
<li><code>acl acl_name hdr_reg(host) -i ^(www.google.com|www.google.com.hk)$</code> <ul>
<li><code>hdr_reg(host)</code>：指定匹配HTTP HEADER中的<strong>host</strong>，<strong><code>hdr_reg</code></strong>使用正则匹配</li>
</ul>
</li>
<li><code>acl acl_name hdr_dom(host) -i www.google.com</code>、<code>acl acl_name hdr(host) -i www.google.com</code><ul>
<li><code>hdr_dom(host)/hdr(host)</code>：HTTP HEADER的域名匹配</li>
</ul>
</li>
<li><code>acl acl_name hdr_cnt(Content-length) eq 0</code><ul>
<li><code>hdr_cnt(Content-length)</code>：HTTP HEADER内容的<code>Content-length</code>等于0</li>
</ul>
</li>
<li><code>acl acl_name url_sub -i acl_test</code><ul>
<li><code>url_sub</code>：URL请求地址中包含<code>acl_test</code></li>
</ul>
</li>
<li><code>acl acl_name url_dir -i acltest</code><ul>
<li><code>url_dir</code>：URL路径中包含<code>acltest</code>，例如：<code>http://www.google.com.hk/acltest/chrome.png</code></li>
<li><code>path_dir</code>：除<code>url_dir</code>外<code>path_dir</code>也可用于判断URL中路径</li>
</ul>
</li>
</ul>
<p>创建ACL规则后，便是使用规则</p>
<ul>
<li>跳转<ul>
<li><code>redirect prefix http://www.google.com.hk code 301 if acl_name</code>：满足名为<code>acl_name</code>ACL规则的请求，301跳转到<code>http://www.google.com.hk</code>后续参数不变</li>
</ul>
</li>
<li>选择<code>backend</code>服务器<ul>
<li><code>use_backend backend_name if acl_name</code></li>
</ul>
</li>
<li>阻止<ul>
<li><code>block if acl_name1||acl_name2</code>：满足<code>acl_name1</code>或<code>acl_name2</code>的请求返回<code>403</code></li>
</ul>
</li>
</ul>
<h3 id="req_+_rsp操作"><strong>req + rsp操作</strong></h3><p>&emsp;HAProxy还有一系列的<code>req</code>操作，这部分了解甚少，以后再补吧<br><code>reqadd reqallow reqdel reqdeny reqiallow reqidel reqideny reqipass reqirep reqisetbe reqitarpit reqpass reqrep</code><br><code>rspadd rspdel rspdeny rspidel rspideny rspirep rsprep</code></p>
<h2 id="启动/重启"><strong>启动/重启</strong></h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#启动</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/haproxy/</span>sbin<span class="regexp">/haproxy -f /u</span>sr<span class="regexp">/local/</span>haproxy<span class="regexp">/etc/</span>haproxy.cfg</span><br><span class="line"></span><br><span class="line">#重启</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/haproxy/</span>sbin<span class="regexp">/haproxy -f /u</span>sr<span class="regexp">/local/</span>haproxy<span class="regexp">/etc/</span>haproxy.cfg -st `cat <span class="regexp">/usr/</span>local<span class="regexp">/haproxy/</span>haproxy.pid`</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;HAProxy能用做负载均衡服务器，也可以用于做四层(TCP)、七层(HTTP)代理</p>
<h2 id="HAProxy安装"><strong>HAProxy安装</strong></h2><p>&emsp;从<a href="http://www.hapr]]>
    </summary>
    
      <category term="haproxy" scheme="http://yoursite.com/tags/haproxy/"/>
    
      <category term="OPS" scheme="http://yoursite.com/categories/OPS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenVPN使用小记]]></title>
    <link href="http://yoursite.com/2015/08/30/openvpn/"/>
    <id>http://yoursite.com/2015/08/30/openvpn/</id>
    <published>2015-08-30T13:07:14.000Z</published>
    <updated>2015-08-30T14:07:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="安装OpenVPN"><strong>安装OpenVPN</strong></h2><p>&emsp;这里使用<code>yum</code>安装，先安装依赖。需要编译安装可到<a href="https://openvpn.net/index.php/download.html" target="_blank" rel="external">这里</a>下载源码包<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> -y openssl openssl-devel lzo lzo-devel pam pam-devel automake pkgconfig</span><br><span class="line">yum -y <span class="keyword">install</span> openvpn</span><br></pre></td></tr></table></figure></p>
<h2 id="生成证书"><strong>生成证书</strong></h2><h3 id="安装easy-rsa"><strong>安装easy-rsa</strong></h3><p>&emsp;OpenVPN2.3(此处用2.3.7)后的版本需要独立下载<strong>easy-rsa</strong>用于生成证书，目前<strong>easy-rsa</strong>最新版本为3.x(此处用3.x版本)，网上教程多为<code>2.x</code>版本。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/openvpn</span><br><span class="line">wget -c -O easy-rsa<span class="class">.zip</span> https:<span class="comment">//github.com/OpenVPN/easy-rsa/archive/master.zip</span></span><br><span class="line">unzip easy-rsa<span class="class">.zip</span></span><br><span class="line">mv easy-rsa-master easy-rsa</span><br></pre></td></tr></table></figure></p>
<h3 id="配置PKI_与_生成服务端证书"><strong>配置PKI 与 生成服务端证书</strong></h3><p>&emsp;根据自身情况配置PKI——public key infrastructure(公钥基础设施)相关信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/openvpn/easy-rsa/easyrsa3/</span><br><span class="line">cp vars.example vars</span><br><span class="line">  <span class="built_in">export</span> <span class="built_in">set</span>_var EASYRSA_REQ_COUNTRY <span class="string">"CN"</span></span><br><span class="line">  <span class="built_in">export</span> <span class="built_in">set</span>_var EASYRSA_REQ_PROVINCE    <span class="string">"GuangDong"</span></span><br><span class="line">  <span class="built_in">export</span> <span class="built_in">set</span>_var EASYRSA_REQ_CITY    <span class="string">"XXXXX"</span></span><br><span class="line">  <span class="built_in">export</span> <span class="built_in">set</span>_var EASYRSA_REQ_ORG <span class="string">"Company"</span></span><br><span class="line">  <span class="built_in">set</span>_var EASYRSA_REQ_EMAIL   <span class="string">"XXXXX@gmail.com"</span></span><br><span class="line">  <span class="built_in">export</span> <span class="built_in">set</span>_var EASYRSA_REQ_OU      <span class="string">"YunWeiBu"</span></span><br><span class="line">  <span class="comment">#easy-rsa3已经不支持nsCertType设置，若需要则设置EASYRSA_NS_SUPPORT</span></span><br><span class="line">  <span class="built_in">export</span> <span class="built_in">set</span>_var EASYRSA_NS_SUPPORT     <span class="string">"yes"</span></span><br><span class="line">./easyrsa init-pki		<span class="comment">#初始化PKI</span></span><br><span class="line">./easyrsa build-ca		<span class="comment">#创建CA，输入PEM密码(签发证书使用)，其余一律回车</span></span><br><span class="line">./easyrsa gen-req server nopass	<span class="comment">#创建服务端证书。 设置一下common name后其余一律回车 </span></span><br><span class="line">./easyrsa sign server server		<span class="comment">#签发服务端证书。输入yes，输入创建CA的PEM密码</span></span><br><span class="line">./easyrsa gen-dh 		<span class="comment">#创建Diffie-Hellman，增强OpenVPN安全性，确保key穿越不安全网络的命令</span></span><br></pre></td></tr></table></figure></p>
<h3 id="生成及签发客户端证书"><strong>生成及签发客户端证书</strong></h3><p>&emsp;生成客户端所需的证书。如果是使用证书认证方式则需此步(生成客户端证书)，假若是使用User/Passwd认证则无需此步骤。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/openvpn_client &amp;&amp; cd /home/openvpn_client</span><br><span class="line">cp -a /etc/openvpn/easy-rsa/easyrsa3/ <span class="regexp">/home/openvpn</span>_client/easyrsa3_client &amp;&amp; cd /home/openvpn_client/easyrsa3_client/</span><br><span class="line">mv pki/ <span class="string">"/tmp/pki_`date "</span>+%<span class="constant">F_</span>%<span class="constant">H</span><span class="symbol">:%M</span><span class="symbol">:%S<span class="string">"`"</span></span></span><br><span class="line">./easyrsa init-pki			<span class="comment">#初始化PKI</span></span><br><span class="line">./easyrsa gen-req mogl		<span class="comment">#为用户生成证书，输入密码，此后改key则使用该密码，其余默认回车</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;签发客户端证书<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/etc/</span>openvpn<span class="regexp">/easy-rsa/</span>easyrsa3/</span><br><span class="line">.<span class="regexp">/easyrsa import-req /</span>home<span class="regexp">/openvpn_client/</span>easyrsa3_client<span class="regexp">/pki/</span>reqs/mogl.req mogl		#导入用户的req</span><br><span class="line">./easyrsa sign client mogl			#用户签约，输入yes，输入服务端PEM密码</span><br></pre></td></tr></table></figure></p>
<p>&emsp;最终服务端的<strong>easyrsa3</strong>的<code>pki</code>目录如下所示：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@openvpn easyrsa3]<span class="preprocessor"># cd /etc/openvpn/easy-rsa/easyrsa3</span></span><br><span class="line">[root@openvpn easyrsa3]<span class="preprocessor"># tree pki</span></span><br><span class="line">pki</span><br><span class="line">├── ca.crt</span><br><span class="line">├── certs_by_serial</span><br><span class="line">│   ├── <span class="number">01.</span>pem</span><br><span class="line">│   └── <span class="number">02.</span>pem</span><br><span class="line">├── dh.pem</span><br><span class="line">├── <span class="keyword">index</span>.txt</span><br><span class="line">├── <span class="keyword">index</span>.txt.attr</span><br><span class="line">├── <span class="keyword">index</span>.txt.attr.old</span><br><span class="line">├── <span class="keyword">index</span>.txt.old</span><br><span class="line">├── issued</span><br><span class="line">│   ├── mogl.crt</span><br><span class="line">│   └── <span class="keyword">server</span>.crt</span><br><span class="line">├── <span class="keyword">private</span></span><br><span class="line">│   ├── ca.key</span><br><span class="line">│   └── <span class="keyword">server</span>.key</span><br><span class="line">├── reqs</span><br><span class="line">│   ├── mogl.req</span><br><span class="line">│   └── <span class="keyword">server</span>.req</span><br><span class="line">├── serial</span><br><span class="line">└── serial.old</span><br><span class="line"><span class="number">4</span> directories, <span class="number">16</span> files</span><br></pre></td></tr></table></figure></p>
<h3 id="证书整理"><strong>证书整理</strong></h3><p>&emsp;将服务端和客户端证书集中，方便管理以及查找<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="regexp">/etc/</span>openvpn/keys</span><br><span class="line">#服务端证书</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easy-rsa/</span>easyrsa3<span class="regexp">/pki/</span>ca.crt <span class="regexp">/etc/</span>openvpn/keys</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easy-rsa/</span>easyrsa3<span class="regexp">/pki/</span><span class="keyword">private</span><span class="regexp">/ca.key /</span>etc<span class="regexp">/openvpn/</span>keys</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easy-rsa/</span>easyrsa3<span class="regexp">/pki/</span><span class="keyword">private</span><span class="regexp">/server.key /</span>etc<span class="regexp">/openvpn/</span>keys</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easy-rsa/</span>easyrsa3<span class="regexp">/pki/</span>issued<span class="regexp">/server.crt /</span>etc<span class="regexp">/openvpn/</span>keys</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easy-rsa/</span>easyrsa3<span class="regexp">/pki/</span>dh.pem <span class="regexp">/etc/</span>openvpn<span class="regexp">/keys/</span>dh2048.pem</span><br><span class="line"></span><br><span class="line">#客户端证书</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easy-rsa/</span>easyrsa3<span class="regexp">/pki/</span>issued<span class="regexp">/mogl.crt /</span>etc<span class="regexp">/openvpn/</span>keys</span><br><span class="line">cp <span class="regexp">/home/</span>openvpn_client<span class="regexp">/easyrsa3_client/</span>pki<span class="regexp">/private/</span>mogl.key <span class="regexp">/etc/</span>openvpn/keys</span><br></pre></td></tr></table></figure></p>
<h2 id="OpenVPN服务端配置"><strong>OpenVPN服务端配置</strong></h2><h3 id="服务端配置文件"><strong>服务端配置文件</strong></h3><p>&emsp;对配置文件<code>/etc/openvpn/server.conf</code>进行修改，<code>local</code>可不配置，默认监听<code>0.0.0.0</code><br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#指定OpenVPN监听的ip</span></span><br><span class="line">;local xxx.xxx.xxx.xxx</span><br><span class="line"><span class="preprocessor">#指定OpenVPN监听的端口</span></span><br><span class="line">port <span class="number">1194</span></span><br><span class="line"><span class="preprocessor">#指定OpenVPN使用的协议(TCP/UDP)</span></span><br><span class="line">proto udp</span><br><span class="line"><span class="preprocessor">#指定通信隧道类型(tun/tap)，tap链路层协议，tun网络层点对点协议</span></span><br><span class="line">dev tun</span><br><span class="line"><span class="preprocessor">#指定ca cert key dh文件路径</span></span><br><span class="line">ca /etc/openvpn/keys/ca.crt</span><br><span class="line">cert /etc/openvpn/keys/server.crt</span><br><span class="line">key /etc/openvpn/keys/server.key</span><br><span class="line">dh /etc/openvpn/keys/dh2048.pem</span><br><span class="line"><span class="preprocessor">#指定client分配的IP段</span></span><br><span class="line">server <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line"><span class="preprocessor">#指定client使用的ip地址</span></span><br><span class="line">ifconfig-pool-persist /etc/openvpn/ipp.txt</span><br><span class="line"><span class="preprocessor">#指定client默认网关为VPN，既使所有流量都走VPN隧道</span></span><br><span class="line">push <span class="string">"redirect-gateway def1 bypass-dhcp"</span></span><br><span class="line"><span class="preprocessor">#指定client的DHCP选项(DNS)</span></span><br><span class="line">push <span class="string">"dhcp-option DNS 223.5.5.5"</span></span><br><span class="line"><span class="preprocessor">#每10秒检查存活，连续120秒无响应则认为连接丢失并重新启动VPN和重连</span></span><br><span class="line">keepalive <span class="number">10</span> <span class="number">120</span></span><br><span class="line"><span class="preprocessor">#对数据进行压缩(server和client都设置才有效)</span></span><br><span class="line">comp-lzo</span><br><span class="line"><span class="preprocessor">#指定最大client数目</span></span><br><span class="line">max-clients <span class="number">100</span></span><br><span class="line"><span class="preprocessor">#设定连接保持密钥功能。在由于keepalive检测超时后而重新启动VPN的情况，不重新读取keys，而保留第一次使用的keys</span></span><br><span class="line">persist-key</span><br><span class="line"><span class="preprocessor">#设定连接保持在线功能。由于keepalive检测超时后而重新启动VPN，一直保持tun/tap是linkup，否则连接会先linkdown然后linkup</span></span><br><span class="line">persist-tun</span><br><span class="line"><span class="preprocessor">#日志相关设置</span></span><br><span class="line">status /<span class="keyword">var</span>/log/openvpn-status.log</span><br><span class="line">log    /<span class="keyword">var</span>/log/openvpn.log</span><br><span class="line"><span class="preprocessor">#指定日志记录级别(0-9)</span></span><br><span class="line">verb <span class="number">3</span></span><br><span class="line"><span class="preprocessor">#指定脚本安全级别，当前客户端设置需要要将此值设置大于3，否则客户端连接时会报错</span></span><br><span class="line">script-security <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="内核参数及iptables配置"><strong>内核参数及iptables配置</strong></h3><p>&emsp;允许本机ip转发<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"net.ipv4.ip_forward = 1"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo <span class="number">1</span> &gt; /<span class="keyword">proc</span>/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></p>
<p>&emsp;iptables允许连接OpenVPN，注意自己添加开机启动。网卡设备<code>eth0</code>根据自身服务器上为准<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -<span class="literal">A</span> INPUT -p udp --dport <span class="number">1194</span> -j ACCEPT</span><br><span class="line">iptables -t nat -<span class="literal">A</span> POSTROUTING -s <span class="number">192.168</span>.<span class="number">10.0</span>/<span class="number">24</span> -o eth0 -j MASQUERADE</span><br><span class="line">iptables -<span class="literal">A</span> INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<h2 id="客户端配置"><strong>客户端配置</strong></h2><p>&emsp;下载Windows客户端，安装程序点击<a href="https://openvpn.net/index.php/open-source/downloads.html" target="_blank" rel="external">这里</a><br>将<code>ca.crt</code>、<code>mogl.crt</code>、<code>mogl.key</code>、<code>client.ovpn</code>四个文件放到OpenVPN安装目录下的<strong>config</strong>目录，<code>client.ovpn</code>文件内容如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">client</span><br><span class="line">dev tun</span><br><span class="line">proto udp</span><br><span class="line">remote 服务器主机IP <span class="number">1194</span></span><br><span class="line">resolv-retry infinite</span><br><span class="line">nobind</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">ca ca<span class="class">.crt</span></span><br><span class="line">cert mogl<span class="class">.crt</span></span><br><span class="line">key mogl<span class="class">.key</span></span><br><span class="line"><span class="id">#ns-cert-type</span> server	#假若客户端报错<span class="string">'VERIFY nsCertType ERROR: require nsCertType=SERVER'</span>，则将此行注释</span><br><span class="line">comp-lzo</span><br><span class="line">verb <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="User/Pass认证方式"><strong>User/Pass认证方式</strong></h2><h3 id="服务端配置"><strong>服务端配置</strong></h3><p>&emsp;以上配置客户端是通过证书的验证方式，OpenVPN可以配置成通过<strong>User/Pass</strong>认证方式<br>&emsp;在保持配置文件<code>/etc/openvpn/server.conf</code>不变的基础上添加如下内容：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#User/Pass认证方式</span></span><br><span class="line">auth-user-pass-verify /etc/openvpn/checkpsw.sh via-env</span><br><span class="line">client-cert-<span class="keyword">not</span>-required  </span><br><span class="line">username-<span class="keyword">as</span>-common-<span class="property">name</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;添加<code>client-cert-not-required</code>则代表只使用用户名密码方式验证登录，如果不加，则代表需要证书和用户名密码双重验证登录！<br>&emsp;<code>/etc/openvpn/checkpsw.sh</code>内容如下所示，也可点击<a href="http://openvpn.se/files/other/checkpsw.sh" target="_blank" rel="external">这里</a>进行下载：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="comment"># checkpsw.sh (C) 2004 Mathias Sundman &lt;mathias@openvpn.se&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script will authenticate OpenVPN users against</span></span><br><span class="line"><span class="comment"># a plain text file. The passfile should simply contain</span></span><br><span class="line"><span class="comment"># one row per user with the username first followed by</span></span><br><span class="line"><span class="comment"># one or more space(s) or tab(s) and then the password.</span></span><br><span class="line"></span><br><span class="line">PASSFILE=<span class="string">"/etc/openvpn/psw-file"</span></span><br><span class="line">LOG_FILE=<span class="string">"/var/log/openvpn-password.log"</span></span><br><span class="line">TIME_STAMP=`date <span class="string">"+%Y-%m-%d %T"</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -r <span class="string">"<span class="variable">$&#123;PASSFILE&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;TIME_STAMP&#125;</span>: Could not open password file \"<span class="variable">$&#123;PASSFILE&#125;</span>\" for reading."</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line">  <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">CORRECT_PASSWORD=`awk <span class="string">'!/^;/&amp;&amp;!/^#/&amp;&amp;$1=="'</span><span class="variable">$&#123;username&#125;</span><span class="string">'"&#123;print $2;exit&#125;'</span> <span class="variable">$&#123;PASSFILE&#125;</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;CORRECT_PASSWORD&#125;</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;TIME_STAMP&#125;</span>: User does not exist: username=\"<span class="variable">$&#123;username&#125;</span>\", password=\"<span class="variable">$&#123;password&#125;</span>\"."</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line">  <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;password&#125;</span>"</span> = <span class="string">"<span class="variable">$&#123;CORRECT_PASSWORD&#125;</span>"</span> ]; <span class="keyword">then</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;TIME_STAMP&#125;</span>: Successful authentication: username=\"<span class="variable">$&#123;username&#125;</span>\"."</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line">  <span class="built_in">exit</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;TIME_STAMP&#125;</span>: Incorrect password: username=\"<span class="variable">$&#123;username&#125;</span>\", password=\"<span class="variable">$&#123;password&#125;</span>\"."</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;默认密码文件在<code>/etc/openvpn/psw-file</code>，用户名和密码用空格隔开，同时确保openvpn启动用户可读取该文件<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> /etc/openvpn/psw-<span class="keyword">file</span></span><br><span class="line">	<span class="keyword">test</span> mogl1002</span><br><span class="line">chmod 600 /etc/openvpn/psw-<span class="keyword">file</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;服务端配置完后需要重启OpenVPN<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/etc/i</span>nit.d<span class="regexp">/openvpn restart</span></span><br></pre></td></tr></table></figure></p>
<h3 id="客户端配置-1"><strong>客户端配置</strong></h3><p>&emsp;客户端<strong>client.ovpn</strong>只需要<code>ca.crt</code>即可，将<code>cert mogl.crt</code>和<code>key mogl.key</code>注释，新增<code>auth-user-pass</code><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">client</span><br><span class="line">auth-user-pass</span><br><span class="line">dev tun</span><br><span class="line">proto udp</span><br><span class="line">remote 服务器主机IP <span class="number">1194</span></span><br><span class="line">resolv-retry infinite</span><br><span class="line">nobind</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line"><span class="keyword">ca</span> <span class="keyword">ca</span>.crt</span><br><span class="line">;cert mogl.crt</span><br><span class="line">;key mogl.key</span><br><span class="line">#ns-cert-<span class="built_in">type</span> server	#假若客户端报错<span class="string">'VERIFY nsCertType ERROR: require nsCertType=SERVER'</span>，则将此行注释</span><br><span class="line"><span class="keyword">comp</span>-lzo</span><br><span class="line"><span class="keyword">verb</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;Linux下的客户端，<code>ca.crt</code>如常放在<code>/etc/openvpn/</code>目录下<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">yum</span> <span class="comment">install</span> <span class="comment">openvpn</span></span><br><span class="line"><span class="comment">openvpn</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">daemon</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">cd</span> <span class="comment">/etc/openvpn</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">config</span> <span class="comment">client</span><span class="string">.</span><span class="comment">ovpn</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;tips1，假若不想每次登录都输入用户名/密码，则可以修改<code>auth-user-pass</code>参数，将用户名/密码明文存到文件中让OpenVPN客户端读取(<strong>安全性会降低</strong>)<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auth-<span class="keyword">user</span>-<span class="literal">pass</span> pwd.txt</span><br><span class="line"><span class="comment">#在config目录下新建文件pwd.txt明文保存用户名/密码</span></span><br><span class="line">username</span><br><span class="line"><span class="literal">password</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;tips2，windows中若想OpenVPN客户端自动连接，则可按以下步骤设置：</p>
<ol>
<li>创建<code>openvpn-gui.exe</code>快捷方式</li>
<li><code>右键</code>——&gt;<code>属性</code>——&gt;<code>高级</code>——<code>以管理员身份运行</code></li>
<li><code>右键</code>——&gt;<code>属性</code>——&gt;<code>目标</code>，添加<strong><code>--connect client.ovpn</code></strong>，例如——“C:\Program Files\OpenVPN\bin\openvpn-gui.exe” —connect client.ovpn</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="安装OpenVPN"><strong>安装OpenVPN</strong></h2><p>&emsp;这里使用<code>yum</code>安装，先安装依赖。需要编译安装可到<a href="https://openvpn.net/index.php/downl]]>
    </summary>
    
      <category term="openvpn" scheme="http://yoursite.com/tags/openvpn/"/>
    
      <category term="OPS" scheme="http://yoursite.com/categories/OPS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重读《TCP/IP详解卷一》之UDP及DNS]]></title>
    <link href="http://yoursite.com/2015/07/30/review-tcp-ip-4/"/>
    <id>http://yoursite.com/2015/07/30/review-tcp-ip-4/</id>
    <published>2015-07-30T14:28:34.000Z</published>
    <updated>2015-08-27T14:19:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="UDP用户数据报协议"><strong>UDP用户数据报协议</strong></h2><p>&emsp;UDP是一种简单的<strong>面向数据报</strong>的传输层协议(TCP是面向数据流)。面向数据报，既当应用层交给UDP的数据，UDP并不会理会数据的大小而是直接在数据上封装UDP首部后直接交给网络层的IP(TCP对数据则会是<code>大割小补</code>，总是以TCP认为适合的数据大小进行传输)。<br>&emsp;UDP不提供可靠性，与IP一样是不可靠协议，数据会有丢失的可能性。<br>&emsp;应用程序必须关系网络层中IP数据报的长度。因为UDP是面向数据报的，不理会数据大小直接将数据交给IP，如果数据大小超过<strong>MTU</strong>则会涉及到<strong>IP分片</strong>的问题。</p>
<h3 id="UDP首部"><strong>UDP首部</strong></h3><p>&emsp;UDP首部结构相比TCP要简单得多，如下图所示：</p>
<center><br><img src="http://7xk64o.com1.z0.glb.clouddn.com/udp-header.jpg" alt="udp-header"><br></center>

<ul>
<li><strong>源端口(16位)</strong>：用于表明发送进程。端口占<strong>16位</strong>表明端口最大为<code>2^16</code>(端口最大为65535)。</li>
<li><strong>目的端口(16位)</strong>：用于表明接收进程。</li>
<li><strong>UDP长度</strong>：UDP首部+UDP数据的总长度。</li>
<li><strong>UDP校验和</strong>：校验和是校验以下三个部分：UDP首部+UDP数据+<strong>UDP伪首部</strong></li>
</ul>
<h2 id="DNS"><strong>DNS</strong></h2><h3 id="基础概念"><strong>基础概念</strong></h3><p>&emsp;域名系统(DNS)提供主机名和IP地址间的转换，是一种TCP/IP应用程序的分布式数据库，具有层次化结构且不区分大小写。<br>&emsp;以<strong>点</strong>结尾的域名称之为<strong>绝对域名</strong>或<strong>完全合格域名——FQDN(Full Qualified Domain Name)</strong>，比如<code>www.google.com.</code>(域名树的根节点即为<strong>点</strong>)<br>&emsp;<strong>顶级域名</strong>分为三部分：</p>
<ul>
<li>arpa是一个用作地址到名字转换的特殊域</li>
<li>7个3字符长的普通域。<code>com edu gov int mil net org</code></li>
<li>所有2字符长的域均是基于ISO3166中定义的国家代码。<code>us cn</code></li>
</ul>
<h3 id="DNS服务器类型"><strong>DNS服务器类型</strong></h3><p>&emsp;DNS服务器大致分成四种类型：</p>
<ul>
<li>主域名服务器：负责维护一个区域的所有域名信息，是特定的所有信息的权威信息源，数据可以修改</li>
<li>辅助域名服务器：辅助域名服务器中区域文件中的数据是从主域名服务器中复制得来，是不可以修改的。辅助域名服务器从主域名服务器复制区域数据的行为称之为<strong>区域传送</strong>(区域传送使用的是<strong>TCP 53端口</strong>)</li>
<li>缓存域名服务器：又称<code>唯缓存域名服务器</code>，将查询过的结果进行缓存以便快速查询，缓存域名服务器不是权威的域名服务器，提供的信息只是间接信息。</li>
<li>转发域名服务器：将所有非本地域名的查询转发到指定的域名服务器中。</li>
</ul>
<h3 id="DNS查询方式"><strong>DNS查询方式</strong></h3><p>&emsp;一般DNS提供本地域名查询，若遇到非本地域名则会采用<strong>递归查询</strong>或<strong>迭代查询</strong>两种方式进行查询：</p>
<ul>
<li>递归查询(最常见的查询方式)：<br>  由本地域名服务器代替客户端向根域名服务器发起查询请求并在域名树中上下分支中进行递归查询，最终将查询结果返回给客户端。<br>  比如客户端发起一个域名查询<code>www.google.com</code>，假设本地域名服务器没有相应记录，则本地域名服务器向根域名服务器发起查询，根域名服务器告知本地域名服务器去问<code>.com</code>域名服务器，以此类推本地域名服务器依次向<code>.com</code>、<code>google.com</code>、<code>www.google.com</code>发起查询请求，最终将结果返回给客户端并存入高速缓存中。</li>
<li>迭代查询：<br>  迭代查询与递归查询不同的是，查询请求都有客户端自己发起。迭代查询时客户端依次向<code>.</code>、<code>.com</code>、<code>google.com</code>、<code>www.google.com</code>发起查询请求，而并非像递归查询由本地服务器发起。</li>
</ul>
<h3 id="DNS资源记录"><strong>DNS资源记录</strong></h3><p>&emsp;DNS资源记录常见的有5种类型，详细请参见<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8B%99%E5%99%A8%E8%A8%98%E9%8C%84%E9%A1%9E%E5%9E%8B%E5%88%97%E8%A1%A8" target="_blank" rel="external">这里</a>：</p>
<ul>
<li>主机（A）：将域名FQND映射到IP  正向解析</li>
<li>别名（CNAME）：将A记录指向的域名 指向 另外一个域名</li>
<li>邮件交换器（MX）：指出当前区域内 SMTP邮件服务器IP</li>
<li>名称服务器（NS）：指出当前区域内有几个DNS服务器在提供服务</li>
<li>反向解析(PRT)：将IP解析为域名(FQND)</li>
</ul>
<h3 id="TCP_or_UDP"><strong>TCP or UDP</strong></h3><p>&emsp;DNS是使用<code>TCP 53</code>端口和<code>UDP 53</code>端口的，那么什么时候使用TCP，什么时候使用UDP呢？<br>&emsp;一般情况下DNS默认都是使用<strong>UDP 53</strong>，但在一些特殊情况下会使用到<strong>TCP 53</strong></p>
<ul>
<li>应答长度超过512字节，使用TCP。DNS在UDP模式下限制报文长度在<code>512</code>字节以下，假若应答报文超过512字节则使用TCP</li>
<li><strong>区域传送</strong>使用TCP。辅助服务器与主服务器在进行<strong>区域传输</strong>时使用TCP</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="UDP用户数据报协议"><strong>UDP用户数据报协议</strong></h2><p>&emsp;UDP是一种简单的<strong>面向数据报</strong>的传输层协议(TCP是面向数据流)。面向数据报，既当应用层交给UDP的数据，UDP并不会理会数据]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重读《TCP/IP详解卷一》之传输层TCP]]></title>
    <link href="http://yoursite.com/2015/07/16/review-tcp-ip-3/"/>
    <id>http://yoursite.com/2015/07/16/review-tcp-ip-3/</id>
    <published>2015-07-16T12:41:29.000Z</published>
    <updated>2015-10-13T14:04:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="TCP传输控制协议"><strong>TCP传输控制协议</strong></h2><p>&emsp;TCP工作在传输层，提供一种面向连接的、可靠的字节流服务。面向连接表示在进行数据传输之前必须先建立一个<strong>TCP连接</strong>，这就有了之后要将的<strong>TCP三次握手</strong>。<br>&emsp;TCP传输的信息单元称之为<strong>段(segment)</strong>。TCP提供<strong>点对点</strong>的服务，不支持多播和组播(UDP支持广播和多播)。<br>&emsp;TCP提供确认重传机制，当TCP发送一个段(segment)后会启动一个定时器，超时后没有等到确认段则超时重传，所以说TCP为可靠的。<br>&emsp;TCP的可靠性还体现在数据校验上，TCP首部会有<code>检验和</code>字段会对<strong>TCP首部和数据</strong>进行检验(IP首部同样有<code>校验和</code>，但仅对<strong>IP首部</strong>进行校验不对其数据部分进行校验，数据的校验交给TCP完成)。<br>&emsp;TCP会对应用数据进行分割或填充，总是以TCP认为最合适的数据块大小进行发送。此外TCP还提供流量控制。</p>
<h3 id="TCP首部结构"><strong>TCP首部结构</strong></h3><p>&emsp;TCP首部如下图所示：<br><img src="http://7xk64o.com1.z0.glb.clouddn.com/tcp-header.png" alt="tcp-header"><br>&emsp;TCP头部如果不包含<code>选项</code>通常是<strong>20字节</strong>(IP头部不含选项也是<strong>20字节</strong>)</p>
<ul>
<li><strong>源端口(16位)</strong>：发送端的端口号。源端口及目的端口主要用于寻找发送端和接收端的应用程序。端口占<strong>16位</strong>表明端口最大为<code>2^16</code>(端口最大为65535)。</li>
<li><strong>目的端口(16位)</strong>： 接收端的端口号。TCP通过<strong><code>src_ip, src_port, dst_ip, dst_port</code></strong>四个元组唯一标识一个TCP连接。</li>
<li><strong>序号(32位)</strong> &amp; <strong>确认序号(32位)</strong>：之所以会有两个序号是因为TCP是全双工的。<code>序号</code>用来表明发送方向上的字节流而<code>确认序号</code>用来表明接收方向上的字节流。<code>数据</code>中的一个字节占用一个序号，若<code>TCP数据</code>有100个字节则<code>序号</code>就<code>+100</code>。当<code>数据</code>为<code>0</code>时(无数据要传输只有IP首部和TCP首部)，只要<code>SYN</code>或<code>FIN</code>标志为<code>1</code>则<code>序号</code>就要<code>+1</code>(<code>ACK</code>位为<code>1</code>序号是不需要+1的)。<br>  &emsp;&emsp;<code>序号</code>和<code>确认序号</code>变化过程：<ul>
<li>假定发送端的开始<code>序号</code>为<code>SN</code></li>
<li>当发送端发送100字节数据，则<code>序号</code>变为<code>SN+100</code></li>
<li>当接收端成功接收100字节数据后，回复的<code>确认序号</code>为<strong><code>SN+100</code></strong>；若发送端发送的是<strong>SYN</strong>或<strong>FIN</strong>的包那么<code>确认序号</code>则变为<strong><code>SN+100+1</code></strong> (<code>SYN</code>/<code>FIN</code>占一个序号)</li>
<li>当发送端收到接收端发来的TCP段，查看<code>确认序号</code>得知之前发送的100字节数据已经成功传输。</li>
</ul>
</li>
<li><strong>首部长度(4位)</strong>：TCP的<code>首部长度</code>字节和IP的<code>首部长度</code>字节完全一致，既<code>TCP首部</code>最大能有<strong><code>60字节</code></strong>(包含<code>选项</code>)，一般正常的<code>TCP首部</code>和<code>IP首部</code>一样为<strong>20字节</strong></li>
<li><strong>保留(6位)</strong>：保留未使用</li>
<li><strong>FLAG(6位)</strong>：有6个flag，若某位被置<code>1</code>则表示使用此flag位<ul>
<li>URG：紧急指针</li>
<li>ACK：确认序号有效(除三次握手的第一个SYN包ACK位没有置1外，其余的所有包都要ACK标志)</li>
<li>PSH：接收端应尽快将段传给应用层(此位用处不大)</li>
<li>RST：重建连接</li>
<li>SYN：同步序号(用于三次握手)</li>
<li>FIN：发送端完成发送任务(主动断开TCP连接)</li>
</ul>
</li>
<li><strong>窗口大小(16位)</strong>：申明窗口大小，用于TCP流量控制(滑动窗口流量控制)。主要作用是让接收端对发送端发送的数据进行控制。因为<code>窗口大小</code>字段占<code>16位</code>所以窗口大小最大为<code>65535</code>，但对于高速网络窗口太小，故在<code>TCP选项</code>中有<strong><code>窗口扩大因子</code></strong>用于扩大窗口大小，需要利用到此值来计算实际的窗口大小(具体见<strong>选项</strong>中的<strong>窗口扩大因子</strong>)。</li>
<li><strong>校验和(16位)</strong>：TCP的校验和是包含<code>TCP首部</code>和<code>TCP数据</code>的校验。</li>
<li><strong>紧急指针(16位)</strong>：当<code>URG</code>被置<code>1</code>时，此字段才有效，用于表明哪一段数据为紧急数据。</li>
<li><strong>选项</strong>：<code>选项</code>字段最大为<code>40字节</code>。<code>选项</code>一般的结构是——<code>|kind(1byte)|length(1byte)|info(n byte)|</code>，不同的<code>kind</code>表示不同的作用，详见<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure" target="_blank" rel="external">TCP选项</a>。选着性挑常见的说明：<ul>
<li><strong><code>kind=2</code>——最大报文段长度 MSS(Maximum Segment Size)</strong>：表明最长报文大小。告诉对方本端能接收的最大长度的段是多少。一般以太网的<code>MTU</code>为<code>1500</code>则TCP的<code>MSS</code>为<code>1460</code>(除去IP首部和TCP首部，1500-20-20)。通常都是在<code>SYN</code>中顺带声明<code>MSS</code>。若应用层交给TCP的数据超过<code>MSS</code>，TCP则会数据进行分割(让数据小于MSS后再传输)，故TCP很少会有IP分片而UDP则会较多IP分片(UDP不会对数据进行分割，应用层传大多数据给UDP，UDP直接加个UDP首部后直接传给IP)</li>
<li><strong><code>kind=3</code>——窗口扩大因子 Window Scale</strong>：用于扩大窗口大小。TCP首部中<code>窗口大小</code>字段占<code>16位</code>最大窗口大小为<code>65535</code>，但在高速网络中此大小可能不够用，需要用到<code>窗口扩大因子</code>选项来增大TCP的窗口大小以便更快的传输数据。<br>  Window Scale中有声明一个<strong><code>Shift count</code></strong>，假设<code>Shift count=n</code>，那么：实际窗口大小 = <strong>窗口大小(16位)</strong> × 2^n</li>
<li><strong><code>kind=4</code>——选择性确认 SACK(Selective Acknowledgment)</strong>：用于优化TCP传输性能。当TCP在传输数据时，如传输<code>1 2 3 4</code>，假若<code>1</code>报文丢失而<code>2 3 4</code>报文顺利到达，TCP会重传<code>1 2 3 4</code>。那么<code>2 3 4</code>就重复传输了从而导致性能降低，使用SACK能使得接收方告诉发送方<code>2 3 4</code>已收到仅重传<code>1</code>即可。<br>  Linux可通过修改<strong><code>/proc/sys/net/ipv4/tcp_window_scaling</code></strong>启用或关闭SACK。</li>
</ul>
</li>
<li><strong>数据</strong>：TCP的<code>数据</code>部分是可选的，既TCP段是可以没有数据的，如三次握手的TCP段就没有<code>数据</code>。</li>
</ul>
<h3 id="TCP连接状态"><strong>TCP连接状态</strong></h3><p>&emsp;TCP是面向连接的，所以在开始传输数据前需要建立连接。而这个建立连接并非是在发送端和接收端创建一个专属的链路，只是发送端和接受端双方来维护一个连接状态，从而使得网络存在一个连接一样。TCP连接状态十分重要，<strong>建立连接(三次握手)</strong>以及<strong>释放连接(四次挥手)</strong>的详细过程如下图所示(<a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">图片来源</a>)</p>
<p><center><br><img src="http://7xk64o.com1.z0.glb.clouddn.com/tcp-open-close.jpeg" alt="tcp-open-close"><br></center></p>
<ul>
<li>当上一次收到的包是<code>SYN</code>或<code>FIN</code>时，此次发送ACK的<code>确认序号</code>为上次收到<code>SYN</code>或<code>FIN</code>包的<strong><code>序号</code>+1</strong>。如图中第一次握手时，Client发送<code>SYN seq=x</code>。当Server收到此<code>SYN</code>包后需要回一个确认ACK包，Server判断由于上次收到的是一个<code>SYN</code>包，所以回复<code>ACK</code>包的<code>确认序号</code>为上次<code>SYN</code>包中的<strong><code>序号</code>+1</strong>既<code>x+1</code></li>
<li>通常在第一、二次握手的<code>SYN</code>包中，<code>TCP首部</code>的<code>选项</code>都会带有<strong><code>MSS</code></strong>选项，分别告诉对方自己的最长报文大小是多少，然后协商用MSS小的为准进行传输。</li>
<li>TCP三次握手其中一个很重要的作用是确定双方的初始化<code>序号</code>，既图中的<strong><code>x</code></strong>及<strong><code>y</code></strong>。借助此<code>序号</code>保证应用层接收数据时不会乱序问题。</li>
<li>四次挥手，其实是两次的<code>FIN+ACK</code>。因为TCP是全双工的，所以当要断开连接时，Client——&gt;Server方向需要一个<code>FIN</code>，Server——&gt;Client方向也需要一个<code>FIN</code></li>
<li>当Client和Server同时断开，既同时发送<code>FIN</code>给对方时，TCP状态则不同于上图，Client和Server的状态都是<code>FIN_WAIT_1——&gt;CLOSING(收到对方的Fin)——&gt;TIME_WAIT</code></li>
<li>在建立连接时，若其中一方发出<code>SYN</code>后对方没有响应，则发送<code>SYN</code>的一方会尝试超时重传。重传采用的是一种称之为<strong>指数退避</strong>的策略，既重传的时间间隔为2的N次幂<code>2^N</code>。第一次重传时间间隔<code>2^0=1</code>(1秒后没收到ACK回应则重传)，第二次重传时间间隔<code>2^1=2</code>(第一次重传后2秒没有收到ACK回应则重传)，第三次重传时间间隔<code>2^2=4</code>(第二次重传后4秒没有收到ACK回应则重传)。至于会重传多少次则根据每个设备不同而不同。</li>
<li>TIME_WAIT状态也被称之为<strong>2MSL等待状态</strong>(Maximum Segment Lifetime)，既TIME_WAIT状态要持续2<em>MSL秒才能到CLOSED状态。之所以要等待2</em>MSL秒有两个主要原因：<ul>
<li>Client发送的最后一个<code>ACK</code>有可能丢失，需要给Server足够的时间重传<code>FIN</code>，一个<code>ACK</code>和一个<code>FIN</code>正好是2个MSL</li>
<li>确保有足够时间使得该连接(src_ip, src_port, dst_ip, dst_port)不能被再次使用，假若不等待2MSL再释放，该连接(src_ip, src_port, dst_ip, dst_port)立马被新的程序所使用，由于网络存在延时上一次连接的数据报在新连接建立后才到达目的端，那么上次连接的数据将会和新连接混淆。</li>
</ul>
</li>
<li>Linux内核中有很多专门针对TCP状态进行调整优化的选项，大多在<strong><code>/proc/sys/net/ipv4/</code></strong>目录下，其中各选项参数涉及复杂改天专门写一篇博客记录。</li>
<li><code>RST</code>复位报文，在TCP首部FLAG字段中有一个<code>RST</code>复位字段，当报文发往基准的连接出现错误时，TCP就会发送一个复位报文。复位报文可以用来释放一个TCP连接，这种称之为<strong>异常释放</strong>(正常的释放都通过发送<code>FIN</code>释放TCP连接的)，正常释放会待双方数据都发送完毕后关闭，而异常释放则会丢弃待发送的数据。</li>
</ul>
<h3 id="TCP流量控制"><strong>TCP流量控制</strong></h3><p>&emsp;TCP需要提供可靠的数据传输服务，那么就必须根据网络的实际情况及接受方数据的处理能力进行发送数据的调整，通过流量控制调整发送速率避免引起网络拥塞导致丢包。TCP是通过<strong>滑动窗口</strong>进行流量控制。</p>
<h4 id="滑动窗口">滑动窗口</h4><p>&emsp;在<code>TCP首部</code>有<code>窗口大小</code>字段，该字段是告诉对方自己的缓冲区还能接受多少数据，发送方根据接收方窗口的大小调整发送速率，防止发送方发送数据过快过多导致接收方缓冲区被占满无法接受处理新的数据。一般我们称接收方缓冲区空间大小的窗口为<strong>通告窗口</strong>。下面通过一个实例来了解TCP是如何利用滑动窗口来实现流量控制的<br><img src="http://7xk64o.com1.z0.glb.clouddn.com/tcp-slide-window.jpg" alt="tcp-slide-window"><br>&emsp;如上图所示，图中大致可分为三部分，框框即为<strong>滑动窗口</strong>：</p>
<ul>
<li><code>1-3</code>部分：发送并已收到<code>ACK</code>确认。这部分为已经成功传输的数据</li>
<li><code>4-9</code>部分：此部分为在<code>滑动窗口</code>中的数据，如图所示目前窗口大小为<strong><code>6</code></strong>。其中又可细分为两部分：<ul>
<li><code>4-6</code>：已发送，但未收到<code>ACK</code>确认</li>
<li><code>7-9</code>：未发送，但接受方缓存区仍有空间，发送方可尽快将此部分数据发给接收方</li>
</ul>
</li>
<li><code>10-11</code>部分：暂时不能发送，由于接受方缓存区空间不足而需要等待<code>滑动窗口</code>移动</li>
</ul>
<p>&emsp;下面来描述一下<code>滑动窗口</code>变化的一些过程：</p>
<ul>
<li>发送方发送完数据<code>1 2 3</code>后，接收方回复<code>ACK=3 window=6</code>，于是有了上图所示的情况，发送方准备再次发送<code>4</code>以后的数据。</li>
<li>发送方发送<code>4 5 6</code>数据(发送方并不一定要一次性发送所有窗口大小的数据)，此时滑动窗口大小为<code>6</code>，窗口中的数据为<code>4-9</code>，<code>4 5 6</code>数据已发送但未确认，<code>7 8 9</code>可选择性尽快发送。</li>
<li>接收方接受到<code>4 5 6</code>数据，根据自身缓冲区大小确定<strong>通告窗口</strong>大小并回复<code>ACK=6 window=X</code></li>
<li>发送方接受到<code>ACK=6 window=X</code>的确认包，确定<code>4 5 6</code>已成功传输，<code>滑动窗口左边缘</code>向右移动到达数据<code>7</code>的位置，根据<code>ACK=6 window=X</code>调整<code>滑动窗口</code>的大小<ul>
<li>若<code>ACK=6 window=3</code>，表明接收方确实已成功收到<code>4 5 6</code>数据但应用程序没有将数据从缓冲区读走，所以窗口大小为<code>3</code>(窗口缩小)。当前<code>滑动窗口</code>中的数据为<code>7 8 9</code></li>
<li>若<code>ACK=6 window=6</code>，表明接收方成功收到<code>4 5 6</code>数据并被应用程序从缓冲区读走，窗口大小保持不变为<code>6</code>。<code>滑动窗口右边缘</code>向右滑动<code>3</code>到达数据<code>12</code>的位置。当前<code>滑动窗口</code>中的数据为<code>7-12</code></li>
</ul>
</li>
<li>假定发送方收到的是<code>ACK=6 window=3</code>的确认包，当前<code>滑动窗口</code>的大小为<code>3</code>其中的数据只有<code>7 8 9</code>，此时发送方一次性将<code>7 8 9</code>全部发出</li>
<li>接收方收到<code>7 8 9</code>数据，缓冲区被填满。于是接收方回复<code>ACK=9 window=0</code>，告诉发送方自身的缓冲区已满不要再发送数据了</li>
<li>发送方收到<code>ACK=9 window=0</code>的确认包，确定<code>7 8 9</code>数据已成功传输，<code>滑动窗口左边缘</code>向右移动到达数据<code>10</code>的位置，发现接收方的窗口大小为<code>0</code>表示已不能再接受数据了，于是停止发送数据并等待。</li>
<li>如果接收方缓冲区中的数据被读走，缓冲区有剩余空间，那么接收方会再次发送一个<code>ACK</code>包通告自己的窗口大小<code>window=X</code>。发送方收到此确认包后调整<code>滑动窗口</code>大小再发送数据，如此重复。</li>
</ul>
<h4 id="零窗口_与_糊涂窗口">零窗口 与 糊涂窗口</h4><p>&emsp;TCP使用<code>滑动窗口</code>来进行流量控制需要注意<strong>零窗口</strong>与<strong>糊涂窗口</strong>：</p>
<ul>
<li><strong>零窗口</strong>：如上面所说，当发送方窗口大小为<code>0</code>且接收方回复的<code>window=0</code>表明无法再接收数据时，发送方会停止发送数据并等待。当接收方缓存区有空间后，接收方会回复一个<code>ACK</code>给发送方告诉发送方自己的窗口大小让发送方发送数据。但如果接收方发送的这个<code>ACK</code>包丢失了，那么发送方就以为接收方窗口一直为<code>0</code>就无止境的等待。<br>&emsp;&emsp;为防止此情况出现，TCP使用<strong>Zero Window Probe技术</strong>。当发送方窗口大小为<code>0</code>时，发送方会向接收方发送<strong>零窗口探测包</strong>，让接收方回复<code>ACK</code>通告它的窗口。有些设计会规定若三次探测包后接收方窗口大小依旧通告为<code>0</code>，则发送方会发一个<code>RST</code>复位报文中断连接。</li>
<li><strong>糊涂窗口综合症</strong>：如上图的例子，当接收方通告自身窗口<code>window=0</code>时，发送方就会停止发送数据并等待。假若过了一段时间，接收方缓冲区有空间但空间很小比如说只有<code>1</code>字节的空间，此时接收方通告自身窗口<code>window=1</code>而发送方为了传输这<code>1字节</code>的数据需要耗费<code>40字节</code>开销(IP首部20字节+TCP首部20字节)，这种花费大开销传输少数据的情况称之为<em>糊涂窗口综合症</em>。<br>&emsp;&emsp;为了解决<em>糊涂窗口综合症</em>，特意针对是发送方引起的还是接收方引起的糊涂窗口分为两种情况的解决方法：<ul>
<li>发送方引起的糊涂窗口：Nagle算法。1)等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS；2)等待时间或是超时200ms。两个条件满足其中一个就发数据，否则一直等待攒数据到满足条件为止。</li>
<li>接收方引起的糊涂窗口：接收方引起的糊涂窗口又可分为两种解决办法<ol>
<li>Clark解决方案：只要有数据到达就回复<code>ACK=X window=0</code>，通告自身窗口为<code>0</code>让发送方停止发送数据，直到接收方<strong>Window Size&gt;=MSS</strong>或<strong>缓冲区有一半空间</strong></li>
<li>延迟确认：当有数据到达时不立即回复<code>ACK</code>，等待缓冲区有足够空间为止，为防止发送方超时重传，延时不能超过500毫秒</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="TCP重传机制"><strong>TCP重传机制</strong></h3><p>&emsp;TCP是一个可靠的传输协议，为了保证数据成功到达接收方就必须有数据丢失后的重传机制，因为1)数据可能在传输过程中丢失，2)即使接收方成功接受到数据，当回复<code>ACK</code>时，这个<code>ACK</code>数据包也可能会丢失。<br>&emsp;TCP重传机制是通过在发送数据时设置<strong>定时器</strong>来解决丢包问题，当<code>定时器</code>溢出时仍没有收到<code>ACK</code>确认，TCP则任务该数据已经丢失变回重新传输该数据。TCP重传机制的重点在于<strong>如何确定超时时间</strong>和<strong>如何确定重传频率</strong>。<br>&emsp;TCP重传机制的<strong>定时器</strong>可分为四种类型：</p>
<ul>
<li>重传定时器</li>
<li>坚持定时器</li>
<li>保活定时器</li>
<li>2MSL定时器</li>
</ul>
<h4 id="重传定时器">重传定时器</h4><p>&emsp;为了确认数据是否丢失或被丢弃而设定，是对数据<code>ACK</code>确认包等待的时间。当TCP发送数据时，就创建针对该数据的<em>重传定时器</em>。若定时器超时前收到<code>ACK</code>确认包，则撤消<em>重传定时器</em>；若定时器超时后还没有收到<code>ACK</code>确认包，则重传该数据，并将<em>重传定时器</em>复位重新计时。<br>&emsp;如果重传失败，TCP会尝试多次重传，至于重传多少次后放弃则不同系统设计不同，Linux系统与<code>/proc/sys/net/ipv4/tcp_retries1</code> <code>/proc/sys/net/ipv4/tcp_retries2</code>有关，关于这两个选项参数更详细内容请点击<a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank" rel="external">这里</a><br>&emsp;TCP多次重传的间隔并不都是一样的，TCP重传间隔采用<strong>指数退避(exponential backoff)</strong>策略，既两次重传时间间隔是一个倍乘关系(每次增加1倍)。如书中的例子重传时间间隔为<code>1 3 6 12 24 48 64 64 64 64...</code>；Linux下可能是这样<code>1 2 4 8 16 32 64 64*8</code>(<code>tcp_retries2</code>默认为<code>15</code>)。</p>
<h4 id="坚持定时器">坚持定时器</h4><p>&emsp;其实<code>坚持定时器</code>在<strong>零窗口</strong>的时候就已经提到过。当接收方的窗口大小为<code>0</code>时，会通告自身<code>通告窗口</code>已为<code>0</code>让发送方停止发送数据。等到接收方的缓冲区空闲<code>通告窗口</code>恢复后，接收方会发送<code>ACK</code>包通告自身窗口大小。因为TCP是不会对<code>ACK</code>包进行确认的，既这个带<code>通告窗口</code>大小的<code>ACK</code>包可能会丢失。假若此<code>ACK</code>包丢失，发送方认为接收方窗口仍为<code>0</code>继续等待，接收方认为自己已经通知发送方自己窗口大小而等待发送方的数据，双方都陷入等待当中。为了避免这个<code>ACK</code>包丢失而导致的双方等待，当接收方通告自身窗口大小为<code>0</code>时，发送方会启用<strong>坚持定时器</strong>，当<strong>坚持定时器</strong>超时后，发送方会主动发送<code>探测包</code>询问接收方的窗口大小。在计算<strong>坚持定时器</strong>时同样是使用<strong>指数退避</strong>，比如说首次坚持定时器超时时间为<code>1.5秒</code>，则后续超时时间为<code>3 6 12</code>。但不会一直增加下去<strong>坚持定时器</strong>总是在<strong><code>5~60</code></strong>之间，达到<code>60</code>后就一直以<code>60</code>为超时时间。</p>
<h4 id="保活定时器">保活定时器</h4><p>&emsp;其实TCP的保活定时器就是类似于HTTP的Keepalive功能，<strong>保活定时器</strong>是用于检测对方是否发送异常，如果有异常则及时关闭连接释放资源。当<strong>保活定时器</strong>超时后会检查连接是否空闲太久，若空闲时间超过设定时间则发送探测报文。通过对方是否响应、响应是否符合预期，来判断对方是否正常，若不正常则关闭连接释放资源。<br>&emsp;在Linux系统中是由<code>/proc/sys/net/ipv4/tcp_keepalive_time</code>、<code>/proc/sys/net/ipv4/tcp_keepalive_intvl</code>、<code>/proc/sys/net/ipv4/tcp_keepalive_probes</code>三个内核参数决定。</p>
<ul>
<li>/proc/sys/net/ipv4/tcp_keepalive_time<br>  最后一次数据交换到TCP发送第一个保活探测报文的时间，即允许连接空闲的时间，默认为7200s</li>
<li>/proc/sys/net/ipv4/tcp_keepalive_intvl<br>  保活探测报文的重传时间，默认为75s</li>
<li>/proc/sys/net/ipv4/tcp_keepalive_probes<br>  保活探测报文的发送次数，默认为9次</li>
</ul>
<p>&emsp;默认情况下Linux的一次完整的保活探测时间，既Linux下TCP认为一个连接出现异常后关闭的时间：<br>tcp_keepalive_time + tcp_keepalive_intvl × tcp_keepalive_probes = <code>7200 + 75 × 9</code> = <code>7875</code></p>
<h4 id="2MSL定时器">2MSL定时器</h4><p>&emsp;TCP的<code>TIME_WAIT状态</code>也称之为<strong><code>2MSL等待状态</code></strong>，之前的章节也已说过。TCP连接的一端发起主动关闭，在四次挥手主动关闭方发送完最后一个<code>ACK</code>包后既进入<code>TIME_WAIT</code>状态，必须等待<strong><code>2MSL</code></strong>的时间后才能释放该TCP连接。之所以必须等待<code>2MSL</code>时间主要有以下两个原因：</p>
<ol>
<li>给被动关闭方重传<code>FIN</code>包的机会。主动关闭方发送的最后一个<code>ACK</code>包有可能会丢失，假若该最后一个<code>ACK</code>包丢失，被动关闭方的<code>重传定时器</code>超时后仍没有收到该<code>ACK</code>包就会重传之前的<code>FIN</code>。假若主动关闭方在发送完最后一个<code>ACK</code>后释放连接而此<code>ACK</code>丢失，就会导致被动关闭方处在<code>CLOSE_WAIT</code>状态，<code>重传定时器</code>不断超时、<code>FIN</code>指数退避不断重传，Linux系统中直到被动关闭方达到<code>tcp_retries2</code>次数后，TCP认为此连接出现问题才会释放该连接。</li>
<li>防止已失效连接的旧数据包出现在新连接上。TCP是根据四元组(src_ip,src_port,dst_ip,dst_port)唯一标识一个连接，数据包可能因为网络等原因延时到达，假若主动关闭方在发送最后一个<code>ACK</code>后立刻释放连接使得原先的端口可以被使用，当应用程序使用原先被释放的端口新建了一个TCP连接而旧连接的数据延时到达，这样就会造成数据混淆。</li>
</ol>
<h4 id="超时重传_与_快速重传">超时重传 与 快速重传</h4><p>&emsp;介绍完四个定时器后，接下来看看TCP常见的两种重传机制——<strong>超时重传</strong>、<strong>快速重传</strong></p>
<ul>
<li><strong>超时重传</strong>：超时重传机制利用到的就是<code>重传定时器</code>，当<code>重传定时器</code>超时后仍没有收到<code>ACK</code>确认则认为该数据包已经丢失，发送方会重传该数据包并将<code>重传定时器</code>复位重新计算。至于<code>重传定时器</code>的<strong>*超时时间</strong>则是由<strong>Jcobson/Karels 算法</strong>计算而得。</li>
<li><strong>快速重传</strong>：由于<code>超时重传</code>是以时间作为驱动，需要等待<strong>timeout</strong>后才进行重传。为了更快的得知数据是否已经丢失，TCP还会使用<strong>快速重传</strong>机制。<strong>快速重传</strong>是以数据为驱动的，如果发送方<strong>连续</strong>收到<strong>3次</strong>相同的<strong>ACK</strong>，则认为数据包已经丢失需要重传。<br>  &emsp;比如说发送方发送<code>1 2 3 4 5</code>数据，但<code>2</code>丢失了<code>3 4 5</code>成功到达，则<code>3 4 5</code>到达时接收方回复的都是<code>ACK=2</code>。发送方收到三个重复的ACK则知道<code>2</code>已丢失需要重传。</li>
</ul>
<p>&emsp;所以只要是<code>重传定时器</code>超时或收到<code>重复ACK</code>，TCP则会认为数据丢失需要重传数据。</p>
<h3 id="TCP拥塞控制"><strong>TCP拥塞控制</strong></h3><p>&emsp;TCP流量控制主要是针对发送端和接收端进行，而TCP拥塞控制则是对其中的网络情况进行控制。试想一下，当网络负载严重导致网络拥塞，进而使得数据丢失或延时到达，假若TCP不加控制就超时重传数据，那便会加重网络负载致使恶性循环直至整个网络瘫痪。为了避免此情况出现，TCP拥塞控制的主要实现方法有以下四种：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
<h4 id="慢启动">慢启动</h4><p>&emsp;慢启动，既当刚刚需要发送数据时，不是一下便发送大流量数据而是一点点的进行提速。<br>&emsp;慢启动为TCP的发送方定义了一个窗口——<strong>拥塞窗口(Congestion Window)</strong>，简称<strong>cwnd</strong>，拥塞窗口表明发送方一次可以发送多少报文段，一般cwnd是根据MSS而定，每收到一个<code>ACK</code>则<code>cwnd=cwnd+cwnd</code>。<br>&emsp;慢启动理想状态的过程如下所示()：</p>
<ul>
<li>TCP三次握手建立连接后，<strong>cwnd=1</strong>，表明可以发送一个MSS大小的数据。假定MSS=1024，cwnd=1则可发送<code>1024(1)</code>大小的数据</li>
<li>当收到<code>ACK</code>后，<strong>cwnd=1+1</strong>，表明可以发送两个MSS大小的数据。cwnd=2可发送<code>2048(2)</code>大小的数据</li>
<li>当收到cwnd=2时发送数据的<code>ACK</code>后，<strong>cwnd=2+2</strong>，表明可以发送四个MSS大小的数据。cwnd=4可发送<code>4096(4)</code>大小的数据</li>
<li>当收到cwnd=4时发送数据的<code>ACK</code>后，<strong>cwnd=4+4</strong>，表明可以发送八个MSS大小的数据。cwnd=8可发送<code>8192(8)</code>大小的数据</li>
<li>cwnd呈指数增长。但并不会无限增长下去，当拥塞窗口&lt;通告窗口时，发送拥塞窗口大小数据;但当拥塞窗口&gt;通告窗口时，只能发送通告窗口大小数据</li>
</ul>
<h4 id="拥塞避免_快速重传_快速恢复">拥塞避免 快速重传 快速恢复</h4><p>&emsp;TCP对于拥塞避免有一套复杂的拥塞避免算法，在此只能简要的描述TCP是如何实现拥塞避免的。<br>&emsp;TCP的拥塞避免算法通常都是与<strong>慢启动</strong>一起作用，那么每个TCP连接就会维持两个变量——<strong><code>cwnd</code></strong>(拥塞窗口Congestion Window)、<strong><code>ssthresh</code></strong>(慢启动门限slow start threshold)，TCP拥塞避免大致过程如下：</p>
<ul>
<li>当TCP完成三次握手后，会给该连接设定两个变量<strong><code>cwnd</code></strong>和<strong>ssthresh</strong>。<strong><code>cwnd</code></strong>初始化值为<code>1个报文段</code>(该值通常为MSS-40[IP+TCP header])，<strong><code>ssthresh</code></strong>初始化值一般为<code>65535字节</code></li>
<li>首先TCP使用<strong>慢启动</strong>，<strong><code>cwnd</code></strong>指数增长，但<strong><code>cwnd</code></strong>并不会无限制增长，当<strong><code>cwnd</code></strong><code>&gt;</code>接收方的<strong>通告窗口</strong>时以<strong>通告窗口</strong>为标准。<strong>拥塞窗口</strong>是发送方的流量控制、<strong>通告窗口</strong>是接收方的流量控制。当<em>拥塞窗口</em> <code>&lt;</code> <em>通告窗口</em>时，由<em>拥塞窗口</em>(发送方)控制发送速率(既为慢启动)；当<em>拥塞窗口</em> <code>&gt;</code> <em>通告窗口</em>时，由<em>通告窗口</em>(接收方)控制发送速率。</li>
<li>TCP在两种情况下会认为数据包已经丢失(详看重传机制)——<strong>超时</strong> 或 <strong>收到3个重复ACK</strong>，TCP对这两种情况处理又所有不同：<ol>
<li>假若在<strong>慢启动</strong>过程中出现<strong>超时</strong><ul>
<li>出现超时后则需要重新设置<strong>ssthresh</strong>。数据包超时后<strong>慢启动门限ssthresh</strong>会被设置为当前<strong>拥塞窗口</strong>的一半，既<strong><code>ssthresh=cwnd/2</code></strong></li>
<li><strong><code>cwnd</code></strong>重新初始化，既<code>cwnd</code>=1。重新开始慢启动过程</li>
<li>重新慢启动后，<code>cwnd</code>指数增长。当<code>cwnd</code> <code>=</code> <code>ssthresh</code>时，停止<strong>慢启动</strong>进入<strong>拥塞避免算法</strong></li>
<li>进入<strong>拥塞避免算法</strong>后，每收到一个<code>ACK</code>不再像慢启动那样<code>+1cwnd</code>而是<code>+1/cwnd</code>，既<code>cwnd = cwnd + 1/cwnd</code></li>
</ul>
</li>
<li>假若在<strong>慢启动</strong>过程中<strong>收到重复<code>ACK</code></strong><ul>
<li>收到<code>3</code>个重复<code>ACK</code>后需要重新设置<strong>ssthresh</strong>，<strong><code>ssthresh=cwnd/2</code></strong>。进入<strong>快速恢复算法</strong></li>
<li>在<strong>快速恢复算法</strong>中，<code>cwnd</code>会被重新计算——<strong><code>cwnd = ssthresh(既上面的cwnd/2) + 3*MSS(3个ACK)</code></strong> </li>
<li>启用<strong>快速重传</strong>重新丢失的数据包</li>
<li>如果在收到重复<code>ACK</code>则<code>cwnd=cwnd+1MSS</code></li>
<li>如果收到新<code>ACK</code>则<code>cwnd=ssthresh</code>，然后进入<strong>拥塞避免算法</strong>(既每收到一个<code>ACK</code>则<code>cwnd=cwnd+1/cwnd</code>)</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>&emsp;&emsp;&emsp;&emsp;超时：<code>慢启动</code>——&gt;<code>超时</code>——&gt;<code>ssthresh=cwnd/2 重新慢启动</code>——&gt;<code>cwnd=ssthresh</code>——&gt;<code>拥塞避免算法(cwnd=cwnd+1/cwnd)</code><br>&emsp;&emsp;&emsp;&emsp;重复ACK：<code>慢启动</code>——&gt;<code>3重复ACK</code>——&gt;<code>快速恢复算法+快速重传 ssthresh=cwnd/2</code>——&gt;<code>cwnd=ssthresh</code>——&gt;<code>拥塞避免算法(cwnd=cwnd+1/cwnd)</code><br>&emsp;&emsp;&emsp;&emsp;<strong>当<code>cwnd</code> <code>&lt;=</code> <code>ssthresh</code>时，慢启动(指数增长)；当<code>cwnd</code> <code>&gt;</code> <code>ssthresh</code>，拥塞避免算法(线性增长)</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="TCP传输控制协议"><strong>TCP传输控制协议</strong></h2><p>&emsp;TCP工作在传输层，提供一种面向连接的、可靠的字节流服务。面向连接表示在进行数据传输之前必须先建立一个<strong>TCP连接</strong>，这就有了之后要]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重读《TCP/IP详解卷一》之网络层]]></title>
    <link href="http://yoursite.com/2015/07/04/review-tcp-ip-2/"/>
    <id>http://yoursite.com/2015/07/04/review-tcp-ip-2/</id>
    <published>2015-07-04T14:25:15.000Z</published>
    <updated>2015-07-27T13:41:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="IP网际协议"><strong>IP网际协议</strong></h2><p>&emsp;IP提供的是不可靠、无连接的数据报传输服务。</p>
<ul>
<li>不可靠：不能保证IP数据报能成功到达目的地，既可能<strong>丢包</strong>。可靠性需要由上层提供，如TCP的超时重传机制等。IP有一个简单的错误处理办法，当IP数据报被丢弃后，会发送ICMP消息告诉发送端错误情况。</li>
<li>无连接：不维护任何后续数据报的状态信息。每个数据报都是相互独立的，独立进行路由选择，到达目的地的顺序和发送顺序可以不同。虽然IP是无连接的，但TCP是面向连接的。<br>举个例子，发送端TCP有四个数据包<code>0 1 2 3</code>，传给网络层，IP封装IP头部后将四个数据包发送出去；由于网络原因产生丢包或延时到达，在接收端只收到<code>0 1 3</code>三个数据包，由于IP是无连接的所以它不需要等<code>2</code>号包的到来就直接将三个数据包传给TCP。由于TCP是面向连接的，所以必须等到<code>2</code>号包的到达组装成完整的数据包后才能传入应用层。</li>
</ul>
<h2 id="IP头部分析"><strong>IP头部分析</strong></h2><p>&emsp;IP头部如图所示：</p>
<p><center><br><img src="http://7xk64o.com1.z0.glb.clouddn.com/ip-header.png" alt="ip-header"><br></center><br>&emsp;普通的IP头部长<strong>20字节</strong>(不包含选项字段)</p>
<ul>
<li><strong>版本(4位)</strong>：常说的IPv4或IPv6</li>
<li><strong>首部长度(4位)</strong>：IP头部最长为<strong>60字节</strong>(一般为<strong>20字节</strong>)。用4位表示长度，那么最大为<code>1111</code>转换成十进制为<code>15</code>，那么最大则为<code>15*4字节=60字节</code>。<br>  &emsp;需要注意的是：4个位里面，<code>0001</code>代表的不是数值1而是首部的1个单位长度，1个单位长度为32bit=4字节(如图所示一行为32bit)。所以首部长度表示首部占32bit字的数目，既首部长度能占多少行(每行32bit)。故一般IP头部长<strong>20字节</strong>，首部长度字段的值为<strong><code>5</code></strong>。</li>
<li><strong>服务类型TOS(8位)</strong>：TOS(8bit)=优先权子字段(3bit[已弃用])+TOS子字段(4bit)+保留位(1bit)，服务类型字段主要可用在QOS上。<br>  &emsp;4bitTOS子字段分别代表：<code>1000</code>——最小延时、<code>0100</code>——最大吞吐量、<code>0010</code>——最高可靠性、<code>0001</code>——最小费用</li>
<li><strong>总长度(16位)</strong>：指定整个IP数据报的长度(IP头部+数据)，单位为<strong>字节</strong>。由于<code>总长度</code>字段占<code>16</code>位，所以IP数据报的最长总长度为<code>2^16</code>既<code>65535</code>字节。</li>
<li><strong>标识(16位)</strong>：唯一标识每个数据报。通常情况下每发一个数据报该字段加1。<br>  &emsp;在IP分片的时候，比如说一个包该标识字段为<code>1</code>，此包过大需要被分片，分成三个小包<code>1-1</code>、<code>1-2</code>、<code>1-3</code>，这三个小包的标识字段依旧是<code>1</code>，而后面的<code>1、2、3</code>则和接下来的字段相关。</li>
<li><strong>标志(3位)</strong>：目前只用到2bit，第3位保留。<br>  &emsp;标志(3bit)=0+DF+MF    &emsp;&emsp;&emsp;&emsp;DF——Don’t Fragment    &emsp;&emsp;&emsp;&emsp;MF——More Fragment<br>  &emsp;<code>010</code>DF=1表示不允许分片(DF=1，若包过大则直接丢弃并用ICMP报文通知源端相关情况)；<code>DF=0</code>则表示允许分片<br>  &emsp;<code>001</code>MF=1表示后续还有分片；MF=0表示此分片包为若干分片的最后一个</li>
<li><strong>片偏移(13位)</strong>：分片在原数据报中的相对位置。相对于原数据报起点，该分片从何处开始。片偏移都是以<strong>8字节</strong>为偏移单位，既除最后一片外，其余所有分片长度皆为8字节的整数倍。由于IP是无连接的，分片后的数据报可能乱序到达所以需要用片偏移对分片进行正确重组。<br>  &emsp;举例说明：一个数据报被分成<code>1 2 3</code>三个分片，<code>1</code>分片的长度80字节、<code>2</code>分片长度64字节、<code>3</code>分片长度10字节。<br>  &emsp;<code>1</code>分片的片偏移为<code>0</code><br>  &emsp;<code>2</code>分片的片偏移为<code>80</code>，在原数据报中，<code>2</code>分片从第<em>80</em>字节开始<br>  &emsp;<code>3</code>分片的片偏移为<code>144</code>(0+80+64)</li>
<li><strong>TTL生存时间(8位)</strong>：设置数据报可经过的最多路由器数。经过一个路由器，TTL减一。当TTL=0时，数据报被丢弃并发送ICMP报文通知源端。<br>  &emsp;TTL占8bit，所以TTL最大值为<code>2^8</code>既<code>255</code>。TTL设置的意义在于防止网络出现环路时，数据报被无限的传递。</li>
<li><strong>协议(8位)</strong>：表明上一层传输层用的协议类型。常见的协议及字段值如下所示：<br>  &emsp;TCP——6、UDP——17、ICMP——1、EGP——8、IGP——9、OSPF——89</li>
<li><strong>首部检验和(16位)</strong>：IP头部的检验和</li>
<li><strong>源地址(32位)</strong></li>
<li><strong>目标地址(32位)</strong></li>
<li><strong>选项</strong>：由于IP头部最大位<code>60字节</code>，以上的基础头部占用<code>20字节</code>，所以选项最多只有<code>40字节</code><br>  &emsp;选项位是一个可变长的字段，目前有如下这些定义：<ul>
<li>安全和处理限制</li>
<li>路径记录(记录每跳路由的IP)</li>
<li>时间戳</li>
<li>宽松源站路由</li>
<li>严格源站路由</li>
</ul>
</li>
</ul>
<h2 id="IP路由选择"><strong>IP路由选择</strong></h2><p>&emsp;IP路由选择是<strong>逐跳</strong>进行的，所有的IP路由选择只为数据传输提供下一站路由的IP地址。IP路由选择需要注意以下两点：</p>
<ul>
<li>数据报中的<strong>目的IP</strong>始终是不变的(除非在IP头部<code>选项</code>中使用<code>源站路由</code>，目的IP才可能会被改变)。</li>
<li>链路层的<strong>目的MAC</strong>始终都是在改变的(非直连路由)，并且是下一跳路由的MAC地址。(下一跳路由的MAC通过ARP协议获得)</li>
</ul>
<p>&emsp;IP路由选择的大致过程如下：</p>
<ol>
<li>检查IP头部的<code>TTL</code>值，若<code>TTL=0</code>则丢弃该数据报并发送ICMP报文通知源端</li>
<li>搜索路由表，优先匹配主机，寻找能与目的IP完全匹配的条目。</li>
<li>搜索路由表，匹配相同子网的条目，寻找能与目的网络号匹配的条目。</li>
<li>搜索路由表，寻找默认路由条目。</li>
<li>搜索路由表后都没有找到以上三种相关的条目，丢弃该数据报。</li>
</ol>
<p>&emsp;路由选择的顺序：<code>匹配主机——&gt;匹配子网——&gt;默认路由</code></p>
<p>&emsp;IP路由根据连接情况可粗略分成两类：<code>直连路由</code>和<code>非直连路由</code></p>
<ul>
<li>直连路由的寻址<br>  源IP、目的IP、源MAC、目的MAC由始到终都是固定的，数据报不经过路由器</li>
<li>非直连路由<br>  <code>源IP</code>、<code>源MAC</code>、<code>目的IP</code>都是不变的(IP头部非源站路由)，但其中需要经过若干个路由器，每经过一次IP路由选择得出<code>下一跳路由</code>后，<code>目的MAC</code>就被修改成该<code>下一跳路由</code>接口的MAC</li>
</ul>
<p>&emsp;直连路由的目的MAC就是目标主机的MAC，而非直连路由的目的MAC是经路由选择后下一跳接口的MAC</p>
<h2 id="ARP"><strong>ARP</strong></h2><p>&emsp;ARP是为IP地址到对应的硬件地址(以太网中既MAC地址)之间提供动态映射的一种协议。</p>
<h3 id="实例分析"><strong>实例分析</strong></h3><p>&emsp;书中举例一个FTP的例子，可以从这个例子中全局的理解TCP/IP一个整体的过程，例子图如下：</p>
<p><center><br><img src="http://7xk64o.com1.z0.glb.clouddn.com/arp_example.png" alt="arp_example"><br></center><br><code>ftp bsdi</code></p>
<ol>
<li>应用层：FTP应用程序需要获取FTP服务器的IP地址，FTP应用程序发现输入的是一个域名于是调用DNS域名解析将域名解析成32bit的IP地址并将数据传给传输层</li>
<li>传输层：由于FTP是使用TCP连接的，所以请求TCP进行三次握手建立连接，TCP将握手包封装好后传给网络层</li>
<li>网络层：如果目的IP是直连网络那么数据报可直接送给目的主机；如果目的IP是非直连网络则按<code>IP路由选择</code>获取下一跳地址并将数据报转发。</li>
<li>链路层(以太网)：有了目的IP后需要知道目的IP对应的MAC(直连是目的主机的MAC/非直连是下一跳的MAC)才能将数据报真正的传给目的主机。这就需要ARP做<code>IP——&gt;MAC</code>的解析。</li>
<li>ARP解析过程<ul>
<li>ARP发送一个二层的<strong>广播</strong>既<code>ARP广播请求包</code>，ARP广播包里的<strong>目的MAC</strong>为<code>FF:FF:FF:FF:FF:FF</code>全F，全网广播询问<code>目的IPxxx.xxx.x.x对应的MAC是多少</code>。本网段的所有主机都会收到此ARP广播包，然后根据广播包中的目的IP是否为自己的IP做出判断。如果目的IP不是自己的IP则丢弃该ARP广播包。</li>
<li>目的主机发现该ARP广播包中的目的IP是自己的IP，于是向源IP发送一个<strong>单播</strong>的<code>ARP响应包</code>。该ARP响应包中包含了自己的MAC地址</li>
</ul>
</li>
<li><ul>
<li>如果是直连网络的话，源IP、源MAC、目的IP和目的MAC都齐全了并且建立连接后即可传输数据(数据的传输其实还是上述的过程)</li>
<li>如果是非直连网络的话，目的MAC就是下一跳的MAC，将数据报转发给下一跳的设备，经过不断的IP路由选择，数据报最终到达目的主机(期间不断重复3/4/5步骤)。在非直连网络中，数据报中的<code>目的IP</code>始终是不变的(非源站路由)而<code>目的MAC</code>总是在变换是下一跳设备接口的MAC，IP地址用于逻辑选路，MAC地址才是真正决定数据报要传到哪个设备或主机上。</li>
</ul>
</li>
</ol>
<p>&emsp;假若ARP解析失败，无法获取目的IP的MAC，那么网络层封装的IP包是不会从主机接口发出去的。<br>&emsp;在收到<code>ARP应答</code>的时候，操作系统或网络设备等都会将查询到的<code>IP-MAC</code>对应关系缓存起来，所以一般情况下系统会维护一张<strong>ARP表</strong>以供快速查询。Linux系统可以通过命令<code>arp -a</code>或<code>cat /proc/net/arp</code>查看缓存的arp记录</p>
<h3 id="ARP包结构"><strong>ARP包结构</strong></h3><p>&emsp;在<a href="">上一篇博客</a>中讲到以太网帧的结构，其中<code>类型</code>字段用来表示上层所用的协议，<strong><code>0x0806</code></strong>表示的是<code>ARP</code>，具体以太网帧结构如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以太网帧结构：</span><br><span class="line">  | 目的地址<span class="comment">(6)</span> | 源地址<span class="comment">(6)</span> | <span class="number">0</span>x<span class="number">0806</span> | ARP请求/应答数据<span class="comment">(28)</span> + PAD填充字节<span class="comment">(18)</span> | CRC<span class="comment">(4)</span> |</span><br></pre></td></tr></table></figure></p>
<p>&emsp;其中以太网帧的<code>数据</code>部分是由<code>ARP请求/应答数据(28) + PAD填充字节(18)</code>组成，接下来要分析的是<code>ARP请求/应答数据(28)</code>这<code>28字节</code>的结构，具体的分组结构如下所示：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARP包结构：</span><br><span class="line">  | 硬件类型<span class="comment">(2)</span> | 协议类型<span class="comment">(2)</span> | 硬件地址长度<span class="comment">(1)</span> | 协议地址长度<span class="comment">(1)</span> | 操作<span class="comment">(2)</span> | 源MAC<span class="comment">(6)</span> | 源IP<span class="comment">(4)</span> | 目的MAC<span class="comment">(6)</span> | 目的IP<span class="comment">(4)</span> |</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>硬件类型(2)</strong>：表示硬件地址的类型。<code>1</code>表示以太网地址</li>
<li><strong>协议类型(2)</strong>：此字段和以太网帧头部的<code>类型</code>字段是一样的。<code>0x0800</code>——IP。<code>协议类型</code>和<code>硬件类型</code>可以表面ARP是在做<code>IP——MAC</code>之间的映射。</li>
<li><strong>硬件地址长度(1)</strong>： 表明硬件地址的长度。以太网硬件地址(MAC)该字段值为<code>6</code>，表明以太网硬件地址(MAC)是占<code>6字节</code>/<code>48位</code>。</li>
<li><strong>协议地址长度(1)</strong>：表明协议地址的长度。IP协议地址长度该字段值为<code>4</code>，表明IP协议地址占<code>4字节</code>/<code>32位</code></li>
<li><strong>操作(2)</strong>：表明操作的类型。以太网帧的<code>类型</code>字段对于ARP请求/应答都是<code>0x0806</code>，所以需要通过ARP分组结构中的<code>操作</code>字段区分ARP请求/ARP应答<ul>
<li>1——ARP请求</li>
<li>2——ARP应答</li>
<li>3——RARP请求</li>
<li>4——RARP应答</li>
</ul>
</li>
<li><strong>源MAC(6)</strong>：源端的MAC地址</li>
<li><strong>源IP(4)</strong>：源端的IP地址</li>
<li><strong>目的MAC(6)</strong>：目的设备的MAC地址。该字段的值和<em>以太网帧头部的</em><code>目的地址</code>在<code>ARP请求</code>时是不同的(尽管它们都表示硬件地址，但所填的值不同)。<br>  &emsp;当是<code>ARP请求</code>的时候(<code>操作</code>字段为<code>1</code>)<ul>
<li>以太网帧头部的<code>目的地址(6)</code>字段值是<strong><code>FF:FF:FF:FF:FF</code></strong>(表明这是一个二层广播包，所有同网段的主机都会接收到该ARP请求包)</li>
<li>ARP分组结构的<code>目的MAC(6)</code>字段值是<strong><code>00:00:00:00:00:00</code></strong>(表明ARP不知道目的MAC是多少，需要目的主机将自身MAC填入该字段)</li>
</ul>
</li>
<li><strong>目的IP(4)</strong>：目的IP地址</li>
</ul>
<p>&emsp;所以包含ARP分组的完整以太网帧结构是这样的：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|目的地址<span class="comment">(6)</span>|源地址<span class="comment">(6)</span>|<span class="number">0</span>x<span class="number">0806</span>||  硬件类型<span class="comment">(2)</span>|协议类型<span class="comment">(2)</span>|硬件地址长度<span class="comment">(1)</span>|协议地址长度<span class="comment">(1)</span>|操作<span class="comment">(2)</span>|源MAC<span class="comment">(6)</span>|源IP<span class="comment">(4)</span>|目的MAC<span class="comment">(6)</span>|目的IP<span class="comment">(4)</span>  || + PAD填充字节<span class="comment">(18)</span>|CRC<span class="comment">(4)</span>|</span><br></pre></td></tr></table></figure></p>
<h3 id="代理ARP"><strong>代理ARP</strong></h3><p>&emsp;如果ARP请求是试图解析非本网络的一台主机，那么连接两个网络的路由器会代替目的主机应答该ARP请求，路由器将自身的接口MAC地址回应给源主机，此过程就称之为<code>代理ARP</code>或<code>委托ARP</code>。路由器其实是“欺骗”了源主机，ARP响应中的MAC地址并发真正目的主机的MAC地址而是与源主机相连的路由器接口的MAC，路由器让源主机误以为路由器是目的主机。因为ARP请求是一个<strong>二层的广播包</strong>，而路由器是隔离广播的，也就是说ARP请求广播包正常情况下是无法穿过路由器继续前进的，路由器知道如何到达目的主机(路由表有路由记录)，所以“欺骗”源主机并接收之后的数据报，将这些数据报<strong>转发</strong>出去。<br>&emsp;举例说明<strong>代理ARP</strong>，如下所示：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PC-A<span class="comment">(192.168.1.1/mac-a)</span>--------------<span class="comment">(192.168.1.2/mac-r1)</span> <span class="number">1</span>——Router——<span class="number">2</span> <span class="comment">(10.1.1.1/mac-r2)</span>-------------------<span class="comment">(10.1.1.2/mac-b)</span>PC-B</span><br></pre></td></tr></table></figure></p>
<ul>
<li>当PC-A发送<code>ARP请求</code>查询<em>10.1.1.2对应的MAC地址是多少</em>，ARP请求的广播包到达Router——1接口(一般情况下广播包就只能到达Router——1接口，不会经由Router——2再发出去)</li>
<li>如果普通主机接收到非自身IP的ARP请求包时，都是做丢弃处理的。但Router开启了代理ARP的功能，查询自身路由表发现知道如何到达10.1.1.2</li>
<li>Router对PC-A的<code>ARP请求</code>做出回应，发送一个<code>ARP响应</code>给PC-A，此ARP响应包内的映射关系为<strong><code>10.1.1.2——mac-r1</code></strong>(但实际上10.1.1.2对应的MAC应该是mac-b才对)</li>
<li>PC-A接收到Router发送的<code>ARP响应</code>包，误以为<code>10.1.1.2</code>的MAC地址是<code>mac-r1</code>，于是将所有目的IP为<code>10.1.1.2</code>的数据都发到<code>Router——1</code>接口上。Router接收到数据后再转发给PC-B</li>
</ul>
<h3 id="免费ARP"><strong>免费ARP</strong></h3><p>&emsp;主机发送ARP请求查询IP对应的MAC，这个ARP请求就称之为<code>免费ARP</code>。免费ARP的作用主要有两个：</p>
<ul>
<li>通过免费ARP来确定IP是否被占用，是否有IP冲突的情况。主机在系统重启或网络服务重启的时候会发送免费ARP，询问自身IP对应的MAC是多少，当网络上有主机已经配置了相同的IP则会回应该免费ARP的询问，源主机接收到ARP回应就能确定该IP已经被使用。</li>
<li>利用免费ARP更新arp表缓存。当主机发送免费ARP广播请求包时，本网络的所有主机都接收到该免费ARP。当发现目的IP不是自身IP时，主机会将该免费ARP丢弃，但在丢弃前会读取该免费ARP包内的源IP及源MAC，若发现和本机arp缓存表不同则更新映射。</li>
</ul>
<h3 id="ICMP"><strong>ICMP</strong></h3><p>&emsp;ICMP主要用于差错报文及其他消息的传递。ICMP报文通常被网络层或传输层使用，常用于将差错报文返回给客户进程，因为IP是不可靠的会出现丢包的情况，出现丢包现象的设备一般都会通过ICMP发送ICMP报文给源端，告诉出错的原因和问题等。<br>&emsp;ICMP报文封装在IP数据报内部，IP头部里的<code>协议(8位)</code>字段值为<code>1</code>就表示后面接的是ICMP报文：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">| IP头部(20字节) | ICMP报文 |</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;ICMP报文的基本格式：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 类型(<span class="number">8</span><span class="typename">bit</span>) | 代码(<span class="number">8</span><span class="typename">bit</span>) | 检验和(<span class="number">16</span><span class="typename">bit</span>) |</span><br><span class="line">| <span class="comment">-----------------------------------------------------|</span></span><br><span class="line">| 不同类型和代码的内容				 |</span><br></pre></td></tr></table></figure></p>
<p>&emsp;ICMP报文类型：<br>ICMP报文类型很多，但最常用的是<code>0 0 回显应答</code>、<code>8 0 请求回显</code>，这两个类型主要用在ping中。</p>
<p><center><br><img src="http://7xk64o.com1.z0.glb.clouddn.com/icmp-type.png" alt="icmp-type"><br></center><br>&emsp;ICMP差错报文必须包含该差错报文的<strong>IP首部(含<code>选项</code>)</strong>和IP首部后面的<strong>前8个字节</strong>，之所以要这样，是因为需要根据<strong>IP首部</strong>判断特定的<strong>协议</strong>、根据<strong>前8个字节</strong>判断用户进程(<strong>前8字节</strong>包含<strong>源端口</strong>和<strong>目标端口</strong>)<br>&emsp;以下情况不会产生ICMP差错报文，目的是为了防止广播风暴：</p>
<ul>
<li>ICMP差错报文，ICMP差错报文不会再产生差错报文来通知源端ICMP差错报文丢失(ICMP查询报文会产生ICMP差错报文)</li>
<li>目的地址为广播或多播的IP数据报</li>
<li>链路层广播的数据报</li>
<li>非IP分片的第一片，因为只有第一片分片才包含<strong>前8字节</strong>所需的源端口和目的端口</li>
<li>源地址不是单个主机的数据报，既源地址不能为全零、环回地址、广播地址和多播地址</li>
</ul>
<h2 id="IP路由"><strong>IP路由</strong></h2><p>&emsp;路由选路是IP最为重要的功能之一，系统会维护一张包含路由条目的路由表，通过查询路由表得出下一跳地址然后进行路由转发及选路。</p>
<h3 id="路由更新方式"><strong>路由更新方式</strong></h3><p>&emsp;路由表更新的方式有如下三种：</p>
<ul>
<li>路由守护进程，运行着动态路由协议的用户进程，比如OSPF守护进程、RIP守护进程。</li>
<li>route命令，可以通过route命令手动添加路由条目(静态路由就属于这种方式)。</li>
<li>ICMP重定向，当收到ICMP重定向报文时，路由表也会被更新。</li>
</ul>
<p>&emsp;除了更新路由表外，可以通过<code>netstat -nr</code>命令查看路由表中的路由条目，当查看路由表时会看到不同的标志(flag)：</p>
<ul>
<li>U 该路由可用</li>
<li>G 该路由是一个网关</li>
<li>H 该路由是一个主机路由(直接到主机，目的地址是一个完整的主机地址)</li>
<li>D 该路由是ICMP重定向报文创建的</li>
<li>M 该路由被ICMP重定向报文修改</li>
</ul>
<h3 id="路由原理"><strong>路由原理</strong></h3><p>&emsp;路由原理其实之前也讲过，就是搜索路由表的优先顺序：</p>
<ul>
<li>搜索匹配主机地址的路由</li>
<li>搜索匹配网络地址的路由</li>
<li>搜索默认路由</li>
</ul>
<h3 id="ICMP重定向"><strong>ICMP重定向</strong></h3><p>&emsp;当路由器检测到某台主机使用非最优路由的时候，可以通过向该主机发送ICMP重定向报文，请求改变该主机的路由。(ICMP重定向报文只能由路由器生成，针对主机使用而不是路由器)<br>&emsp;ICMP重定向报文结构：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">————————————</span><br><span class="line"><span class="string">|类型 5|代码 0~3|检验和|</span></span><br><span class="line">————————————</span><br><span class="line"><span class="string">|应该使用的路由器IP地址|</span></span><br><span class="line">———————————————</span><br><span class="line"><span class="string">|IP首部+原IP首部后的前8个字节|</span></span><br><span class="line">———————————————</span><br></pre></td></tr></table></figure></p>
<ul>
<li>类型——5，表示是ICMP重定向(详见之前的表格)</li>
<li>代码——0~3，0——网络重定向、1——主机重定向、2——服务类型和网络重定向、3——服务类型和主机重定向</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="IP网际协议"><strong>IP网际协议</strong></h2><p>&emsp;IP提供的是不可靠、无连接的数据报传输服务。</p>
<ul>
<li>不可靠：不能保证IP数据报能成功到达目的地，既可能<strong>丢包</strong>。可靠性需要由]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重读《TCP/IP详解卷一》之链路层]]></title>
    <link href="http://yoursite.com/2015/06/29/review-tcp-ip-1/"/>
    <id>http://yoursite.com/2015/06/29/review-tcp-ip-1/</id>
    <published>2015-06-29T14:42:43.000Z</published>
    <updated>2015-08-03T14:42:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="链路层主要目的"><strong>链路层主要目的</strong></h2><p>&emsp;TCP/IP支持多种链路层协议，不同的网络硬件设备使用不同链路层协议，如：以太网协议、令牌环、FDDI和PPP等。链路层主要有三个目的：</p>
<ul>
<li>为IP模块发送和接受IP数据报</li>
<li>为ARP模块发送ARP请求和接受ARP应答</li>
<li>为RARP模块发送RARP请求和接受RARP应答</li>
</ul>
<h2 id="以太网"><strong>以太网</strong></h2><p>&emsp;以太网是目前TCP/IP在局域网中最主要的技术，采用CSMA/CD(带冲突检测的载波侦听多路接入)接入方法，地址为48bit(既MAC地址)。然而以太网是几家公司联合发布的一个技术标准，后来IEEE发布802标准(802.3针对CSMA/CD网络)。但实际上目前局域网中绝大多数都是以太网包，802.3的包有使用但极少。<strong>以太网帧结构和802.3帧结构是完全不同的</strong>，以下我主要记录以太网包相关的内容。</p>
<h3 id="以太网帧结构"><strong>以太网帧结构</strong></h3><p>&emsp;以太网规定以太网帧中的<code>数据</code>长度在<strong><code>46~1500</code></strong>字节之间。最小不少于46字节，<strong>不足46字节的必须加入填充(PAD)字节</strong>；最大不得超过1500字节(1500既MTU)。所以一个正常的以太网帧长度应该在<strong>64~1518</strong>字节之间，由<code>帧头部+数据+帧尾校验</code>组成<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| 目的地址<span class="comment">(6)</span> | 源地址<span class="comment">(6)</span> | 类型<span class="comment">(2)</span> | 数据<span class="comment">(46~1500)</span> | CRC<span class="comment">(4)</span> |</span><br></pre></td></tr></table></figure></p>
<h3 id="以太网帧中的类型字段"><strong>以太网帧中的类型字段</strong></h3><p>&emsp;在以太网帧结构中有2字节的<code>类型</code>字段，其主要目的是为了标识上层协议类型。常见的有以下三种类型，更详细的类型参见<a href="https://en.wikipedia.org/wiki/EtherType#Examples" target="_blank" rel="external">这里</a></p>
<ul>
<li><p>IP协议——0x0800<br>  IP数据报在以太网帧中的类型字段以<code>0x0800</code>表示，数据部分大小依旧是<code>46~1500</code>字节</p>
  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| 目的地址<span class="comment">(6)</span> | 源地址<span class="comment">(6)</span> | <span class="number">0</span>x<span class="number">0800</span> | 数据<span class="comment">(46~1500)</span> | CRC<span class="comment">(4)</span> |</span><br></pre></td></tr></table></figure>
</li>
<li><p>ARP协议——0x0806<br>  ARP的请求或应答包在以太网帧中的类型字段以<code>0x0806</code>表示，但数据部分ARP包只有<strong>28</strong>字节，不满足以太网规定的最小<strong>46</strong>字节，所以ARP包的数据部分会有<strong>18</strong>字节的PAD填充字节</p>
  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| 目的地址<span class="comment">(6)</span> | 源地址<span class="comment">(6)</span> | <span class="number">0</span>x<span class="number">0806</span> | ARP请求/应答数据<span class="comment">(28)</span> + PAD填充字节<span class="comment">(18)</span> | CRC<span class="comment">(4)</span> |</span><br></pre></td></tr></table></figure>
</li>
<li><p>RARP协议——0x0835<br>  RARP和ARP差不多，数据部分也只有28字节，需要填充18字节</p>
</li>
</ul>
<h2 id="环回接口(loopback)"><strong>环回接口(loopback)</strong></h2><p>&emsp;通常我们会把<code>127.0.0.1</code>分配给环回接口并命名为<code>localhost</code>，<strong>传给环回接口的IP包不能出现在任何网络上</strong>。环回接口是个比较特殊的接口，此接口会有些有趣或特殊的应用，比如LVS的DR模式中会将VIP配置在RealServer的<em>lo:0</em>环回设备上。<br>&emsp;以下三种情况环回接口处理数据包时，数据包直接经过环回接口驱动程序传入上层，数据包并没有经过网卡输出到以太网后再返回。所以当我们ping 127.0.0.1或本机IP地址时，数据包是直接通过环回驱动程序再回到上层。</p>
<ul>
<li>目的IP为环回接口地址。IP输出函数——&gt;环回驱动程序——&gt;IP输入函数</li>
<li>目的IP为广播或多播地址。</li>
<li>目的IP为本机接口IP地址。</li>
</ul>
<p>除以上三种情况外的目的IP数据包会通过ARP协议找到目的IP的MAC地址后进行发送到以太网</p>
<h2 id="最大传输单元MTU、路径MTU"><strong>最大传输单元MTU、路径MTU</strong></h2><p>&emsp;数据帧中可容最大数据长度称为MTU，在不同帧结构中MTU是不同的，以太网的MTU是<code>1500字节</code>。我们可以通过<code>netstat -in</code>命令查看MTU信息<br>&emsp;当网络上两台主机通信时，会经过路由选路确定一条路径，在这条路径上可能会有不同的网络或设备的MTU。所谓的<strong>路径MTU</strong>则是在这条路径中<strong>最小</strong>的MTU。两台主机间的路径MTU并不一定是固定的，因为路径MTU取决于所选路径。<br>&emsp;由于链路层有MTU限制，所以当IP层要传的数据包大于MTU时，网络层则需要进行IP分片，而且由于路径上的MTU可能会不同，所以数据包可能会被进行多次分片。有关IP分片的详细内容会在网络层做详细介绍。<br>&emsp;大于MTU的包会有两种处理方式：</p>
<ul>
<li>直接丢弃。丢弃后会发送ICMP报文告诉源端包太大并通告自身的MTU</li>
<li>重新分块后再发送</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="链路层主要目的"><strong>链路层主要目的</strong></h2><p>&emsp;TCP/IP支持多种链路层协议，不同的网络硬件设备使用不同链路层协议，如：以太网协议、令牌环、FDDI和PPP等。链路层主要有三个目的：</p>
<ul>
<li>为IP]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重读《TCP/IP详解卷一》之概述]]></title>
    <link href="http://yoursite.com/2015/06/25/review-tcp-ip-0/"/>
    <id>http://yoursite.com/2015/06/25/review-tcp-ip-0/</id>
    <published>2015-06-25T14:28:41.000Z</published>
    <updated>2015-07-26T12:52:46.000Z</updated>
    <content type="html"><![CDATA[<p>&emsp;《TCP/IP详解卷一》此书在学校期间就已经读过，当时还是花了一定的精力和时间去读的。前段时间在看有关LVS方面的资料，其中涉及网络方面的知识，这让我发现自己关于TCP/IP方面的细节知识已经有点模糊。于是决定再重新仔细的阅读《TCP/IP详解卷一》这边经典书籍，顺便做个笔记记录，方便以后查阅。</p>
<h2 id="分层"><strong>分层</strong></h2><p>有别于OSI七层模型，TCP/IP协议族分为四层：</p>
<ul>
<li>应用层：处理应用程序细节，例如：Telnet远程登录、FTP文件传输协议、HTTP协议等。信息单元称之为<strong>数据(data)</strong></li>
<li>传输层：主要负责提供端对端通信，主要有两个不通的传输协议：TCP(传输控制协议)、UDP(用户数据报协议)。信息单元称之为<strong>段(segment)</strong></li>
<li>网络层：负责处理分组在网络的活动，即路由寻址。网络层协议包括：IP协议、ICMP协议和IGMP协议。信息单元称之为<strong>包/分组(Packet)</strong></li>
<li>链路层：主要包括设备驱动及网络设备接口，链路层协议：以太网、令牌环网、FDDI等。信息单元称之为<strong>帧(frame)</strong></li>
</ul>
<h2 id="IP地址"><strong>IP地址</strong></h2><p>IPv4地址长32bit，分成5类</p>
<ul>
<li>A类地址：0.0.0.~127.255.255.255，0-网络号(7位)-主机号(24位)</li>
<li>B类地址：128.0.0.0~192.255.255.255，10-网络号(14位)-主机号(16位)</li>
<li>C类地址：192.0.0.0~223.255.255.255，110-网络号(21位)-主机号(8位)</li>
<li>D类地址：224.0.0.0~239.255.255.255，1110-多播组号(28位)</li>
<li>E类地址：240.0.0.0~255.255.255.255，11110-保留(27位)</li>
</ul>
<p>保留地址(私有地址)：</p>
<ul>
<li>127.0.0.0/8</li>
<li>10.0.0.0/8</li>
<li>169.254.0.0/16</li>
<li>172.16.0.0/12~172.31.0.0/12</li>
<li>192.168.0.0/16</li>
<li>E类地址(用于实验)</li>
</ul>
<h2 id="封装"><strong>封装</strong></h2><p>数据从<code>应用层——&gt;传输层——&gt;网络层——&gt;链路层</code>逐层传递时，每层都会对收到的数据添加首部信息/尾部信息</p>
<ul>
<li>应用层：用户数据</li>
<li>传输层：用户数据+TCP首部                                    此数据单元(以TCP为例)称为——<strong>TCP报文(TCP segment)</strong></li>
<li>网络层：用户数据+TCP首部+IP首部                            此数据单元称为——<strong>分组(packet)</strong></li>
<li>链路层：以太网尾部+应用数据+TCP首部+IP首部+以太网首部    此数据单元称为——<strong>帧(frame)</strong>，由于以太网物理性质限制<code>46B&lt; 应用数据+TCP首部+IP首部&lt; 1500B</code></li>
</ul>
<h2 id="端口号"><strong>端口号</strong></h2><ul>
<li>1~1023        知名服务端口(<code>/etc/services</code>查看常用熟知端口)</li>
<li>1024~65535    随机端口(之所以最大端口号为65535是因为TCP/UDP头部采用<code>16bit</code>来标识端口，故最大为<code>2^16</code>)</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;《TCP/IP详解卷一》此书在学校期间就已经读过，当时还是花了一定的精力和时间去读的。前段时间在看有关LVS方面的资料，其中涉及网络方面的知识，这让我发现自己关于TCP/IP方面的细节知识已经有点模糊。于是决定再重新仔细的阅读《TCP/IP详解卷一》这边经典书籍]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tmux使用录]]></title>
    <link href="http://yoursite.com/2015/06/20/tmux/"/>
    <id>http://yoursite.com/2015/06/20/tmux/</id>
    <published>2015-06-20T14:20:20.000Z</published>
    <updated>2015-10-27T14:42:19.000Z</updated>
    <content type="html"><![CDATA[<p>&emsp;<a href="https://tmux.github.io/" target="_blank" rel="external">tmux</a>是一款优秀且好用的终端复用工具，有点类似screen。之所以说好用是因为它支持全键盘操作，连屏幕复制都能直接通过键盘完成，以下是平时的一点使用记录。</p>
<h2 id="安装"><strong>安装</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu：sudo apt-get install tmux</span><br><span class="line">CentOS：yum install tmux</span><br></pre></td></tr></table></figure>
<h2 id="基础概念"><strong>基础概念</strong></h2><p>&emsp;要用好tmux，需要先了解有关tmux的几个基础概念——会话(session)、窗口(window)和面板(pane)</p>
<ul>
<li>会话(session)：直接输入<code>tmux</code>命令即创建了一个会话</li>
<li>窗口(window)： window为session的终端，一个session可以包含多个window</li>
<li>面板(pane)：     面板为一个窗口分隔出的若干小终端，一个window可以包含多个pane</li>
<li>前缀操作(prefix)：tmux的所有键盘操作都必须以前缀操作开始即<code>prefix + command</code>，默认的前缀操作prefix为<code>Ctrl + b</code>(可根据个人习惯更改)</li>
</ul>
<p>&emsp;会话(session)、窗口(window)、面板(pane)之间的关系<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">session1&#123;</span><br><span class="line">		window1&#123;pane1,pane2,<span class="keyword">...</span>&#125;,</span><br><span class="line">		window2&#123;pane1,pane2,<span class="keyword">...</span>&#125;,</span><br><span class="line">		window3&#123;pane1,pane2,<span class="keyword">...</span>&#125;,</span><br><span class="line">		<span class="keyword">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="会话(session)操作"><strong>会话(session)操作</strong></h2><table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th></th>
<th></th>
<th></th>
<th style="text-align:left">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">tmux ls</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">列出所有session</td>
</tr>
<tr>
<td style="text-align:left">tmux attach -t session_name</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">重新进入指定的session</td>
</tr>
<tr>
<td style="text-align:left">prefix d</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">离开session</td>
</tr>
<tr>
<td style="text-align:left">prefix $</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">重命名session</td>
</tr>
<tr>
<td style="text-align:left">prefix s</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">查看/切换session</td>
</tr>
<tr>
<td style="text-align:left">prefix t</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">查看时间</td>
</tr>
</tbody>
</table>
<h2 id="窗口(window)操作"><strong>窗口(window)操作</strong></h2><table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th></th>
<th></th>
<th></th>
<th style="text-align:left">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">prefix c</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">新建窗口</td>
</tr>
<tr>
<td style="text-align:left">prefix ,</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">重命名窗口</td>
</tr>
<tr>
<td style="text-align:left">prefix &amp;</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">关闭窗口</td>
</tr>
<tr>
<td style="text-align:left">prefix 窗口号</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">切换到窗口号</td>
</tr>
<tr>
<td style="text-align:left">prefix n</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">移动到下一个窗口</td>
</tr>
<tr>
<td style="text-align:left">prefix p</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">移动到上一个窗口</td>
</tr>
<tr>
<td style="text-align:left">prefix l</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">移动到上一次活动的窗口</td>
</tr>
<tr>
<td style="text-align:left">prefix w</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">列出所有窗口，并进行选择切换</td>
</tr>
<tr>
<td style="text-align:left">prefix f</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">搜索窗口名</td>
</tr>
</tbody>
</table>
<h2 id="面板(pane)操作"><strong>面板(pane)操作</strong></h2><table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th></th>
<th></th>
<th></th>
<th style="text-align:left">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">prefix “</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">水平分隔出一个pane</td>
</tr>
<tr>
<td style="text-align:left">prefix %</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">垂直分隔出一个pane</td>
</tr>
<tr>
<td style="text-align:left">prefix 方向键</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">在所有pane中移动</td>
</tr>
<tr>
<td style="text-align:left">prefix o</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">移动到下一个pane</td>
</tr>
<tr>
<td style="text-align:left">prefix 空格</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">循环变换pane布局</td>
</tr>
<tr>
<td style="text-align:left">prefix q</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">显示pane编号</td>
</tr>
<tr>
<td style="text-align:left">prefix x</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">关闭当前pane</td>
</tr>
<tr>
<td style="text-align:left">prefix !</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">将当前pane置于一个新建窗口中</td>
</tr>
<tr>
<td style="text-align:left">prefix z</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">临时最大化当前pane/恢复pane原大小</td>
</tr>
<tr>
<td style="text-align:left">prefix ;</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">切换到上次使用的pane</td>
</tr>
<tr>
<td style="text-align:left">prefix {</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">向前置换当前pane</td>
</tr>
<tr>
<td style="text-align:left">prefix }</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">向后置换当前pane</td>
</tr>
</tbody>
</table>
<h2 id="VI模式的面板(pane)间移动"><strong>VI模式的面板(pane)间移动</strong></h2><p>&emsp;面板的移动默认都是通过<code>prefix o</code>或<code>prefix 方向键</code>来实现，但习惯使用vim的用户会想通过<code>hjkl</code>来移动，可以通过以下配置实现<br>&emsp;配置完后通过<code>prefix hjkl</code>在各面板间移动<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pane hjkl移动</span></span><br><span class="line"><span class="keyword">bind</span> h <span class="keyword">select</span>-pane -L</span><br><span class="line"><span class="keyword">bind</span> j <span class="keyword">select</span>-pane -D</span><br><span class="line"><span class="keyword">bind</span> k <span class="keyword">select</span>-pane -U</span><br><span class="line"><span class="keyword">bind</span> l <span class="keyword">select</span>-pane -R</span><br></pre></td></tr></table></figure></p>
<h2 id="复制模式"><strong>复制模式</strong></h2><p>&emsp;进入复制模式可以非常方便的复制粘贴屏幕的内容，有点类似与VIM的<code>Ctrl-v</code>模式，首先要在配置文件<code>~/.tmux.conf</code>添加如下配置：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>-window-option -<span class="keyword">g</span> <span class="built_in">mode</span>-<span class="built_in">keys</span> <span class="keyword">vi</span></span><br><span class="line">bind-key -<span class="keyword">t</span> <span class="keyword">vi</span>-<span class="built_in">copy</span> <span class="string">'v'</span> begin-selection</span><br><span class="line">bind-key -<span class="keyword">t</span> <span class="keyword">vi</span>-<span class="built_in">copy</span> <span class="string">'y'</span> <span class="built_in">copy</span>-selection</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>prefix [</code>进入选择模式</li>
<li>按<code>v</code>进入vi选择模式</li>
<li>移动选择需要复制的行，可用vim的移动快捷方式</li>
<li>按<code>y</code>将选择的行复制到tmux的剪贴板中</li>
<li>按<code>prefix ]</code>粘贴到光标所在处</li>
</ul>
<p>&emsp;或者按行复制</p>
<ul>
<li><code>prefix [</code>进入复制模式</li>
<li>按<code>space</code>(空格键)，复制每行</li>
<li>按<code>Enter</code>复制到tmux剪贴板中并退出复制模式</li>
<li>按<code>prefix ]</code>粘贴到光标所在处</li>
</ul>
<p>&emsp;假若像我这样平时以Ubuntu系统作为桌面系统，还可将tmux粘贴板里的内容复制到系统粘贴板上，只需绑定<code>prefix o</code>快捷键并调用命令即可。<br>&emsp;如下配置完后，如上面<code>prefix [</code>所示操作选择需要复制内容，最后一步并非按<code>prefix ]</code>而是按<code>prefix o</code>既可将tmux粘贴板上的内容复制到系统粘贴板上<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind o <span class="keyword">run</span>-<span class="keyword">shell</span> <span class="string">"tmux saveb - | xsel -i -b"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="重启保持会话(session)"><strong>重启保持会话(session)</strong></h2><p>&emsp;tmux自身有会话保存功能，只要机器不重启就能保存会话，一旦机器重启会话便会丢失。如果想重启仍保持会话则需要额外的插件，这里使用的是<a href="https://github.com/tmux-plugins/tmux-resurrect" target="_blank" rel="external">tmux-resurrect</a>和<a href="https://github.com/tmux-plugins/tmux-continuum" target="_blank" rel="external">tmux-continuum</a>。使用此插件tmux版本需要在<strong><code>1.9</code></strong>以上，Ubuntu14.04默认安装的是<strong><code>1.8</code></strong>版本，所以先对tmux进行升级。也可自行进行编译安装，<a href="https://tmux.github.io/" target="_blank" rel="external">tmux下载地址</a></p>
<h4 id="Ubuntu14-04升级tmux到2-0版本"><strong>Ubuntu14.04升级tmux到2.0版本</strong></h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y python-software-properties software-properties-common</span><br><span class="line">sudo<span class="instruction"> add-apt-repository </span>-y ppa:pi-rho/dev</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y tmux=2.0-1~ppa1~t</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看tmux版本</span></span><br><span class="line">tmux -V</span><br></pre></td></tr></table></figure>
<h4 id="安装tmxu-resurrect插件"><strong>安装tmxu-resurrect插件</strong></h4><p>&emsp;此插件是用来保存tmux的会话，安装后按快捷键<strong><code>prefix+Ctrl+s</code></strong>保存会话，<strong>tmux-resurrect</strong>会将会话以文本方式保存在<code>~/.tmux/resurrect</code>目录中。按<strong><code>prefix+Ctrl+r</code></strong>还原。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/<span class="class">.tmux</span> &amp;&amp; cd ~/<span class="class">.tmux</span></span><br><span class="line">git clone https:<span class="comment">//github.com/tmux-plugins/tmux-resurrect.git</span></span><br><span class="line">echo <span class="string">'run-shell ~/.tmux/tmux-resurrect/resurrect.tmux'</span> &gt;&gt; ~/<span class="class">.tmux</span><span class="class">.conf</span></span><br></pre></td></tr></table></figure></p>
<h4 id="安装tmux-continuum插件"><strong>安装tmux-continuum插件</strong></h4><p>&emsp;此插件会自动完成保存和还原会话的功能，无需手动执行。默认每隔<strong><code>15分钟</code></strong>对会话进行一次保存。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd ~/<span class="class">.tmux</span></span><br><span class="line">git clone https:<span class="comment">//github.com/tmux-plugins/tmux-continuum.git</span></span><br><span class="line">echo <span class="string">'run-shell ~/.tmux/tmux-continuum/continuum.tmux'</span> &gt;&gt; ~/<span class="class">.tmux</span><span class="class">.conf</span></span><br><span class="line">echo <span class="string">"set -g @continuum-restore 'on'"</span> &gt;&gt; ~/<span class="class">.tmux</span><span class="class">.conf</span></span><br><span class="line"></span><br><span class="line">#若想调整自动保存时间间隔，可将此设置添加到~/<span class="class">.tmux</span><span class="class">.conf</span>下(改为<span class="number">60</span>分钟自动保存一次)。更多设置查看项目网页</span><br><span class="line">set -g @continuum-save-interval <span class="string">'60'</span></span><br><span class="line"></span><br><span class="line">#若安装插件前已启用tmux，则需重载配置文件</span><br><span class="line">tmux source-file ~/<span class="class">.tmux</span><span class="class">.conf</span></span><br></pre></td></tr></table></figure></p>
<h2 id="SSH_Tips"><strong>SSH Tips</strong></h2><p>&emsp;对于需要登录多台机器进行操作的用户来说，Windows有诸如<strong>Xshell</strong>等SSH连接管理工具，当远程登录多台机器的时候会有预先填好的标签方便识别每台机器。Linux平台上本来就可通过终端进行远程登录，所以这类软件较少，比较好用的是<a href="https://sites.google.com/site/davidtv/" target="_blank" rel="external">PAC Manager</a>。但其实使用<strong>Tmux</strong>就可以完成类<strong>Xshell</strong>的便签功能，在SSH远程登录的时候修改Tmux的Window Name就能很好的用于识别多台机器。<br>&emsp;个人的做法是先配完SSH无密码登录，然后做<code>alias</code>别名命令，最后是修改Tmux的Window Name。可根据个人需求就行修改，在此仅说说我个人的做法。将<code>tmux_rename_window</code>函数写入到<code>~/.bashrc</code>并配置好<code>alias</code>命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tmux_rename_window</span></span>() &#123;</span><br><span class="line">    wname=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">    sship=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$wname</span>"</span>|grep -Po <span class="string">"(\d+\.)&#123;3&#125;\d+$"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$(ps -p $(ps -p $$ -o ppid=)</span> -o comm=)"</span> = <span class="string">"tmux"</span> ]; <span class="keyword">then</span></span><br><span class="line">        tmux rename-window -t<span class="variable">$&#123;TMUX_PANE&#125;</span> <span class="string">"<span class="variable">$&#123;wname&#125;</span>"</span></span><br><span class="line">        <span class="built_in">command</span> ssh root@<span class="variable">$&#123;sship&#125;</span></span><br><span class="line">        tmux <span class="built_in">set</span>-window-option automatic-rename <span class="string">"on"</span> <span class="number">1</span>&gt;/dev/null</span><br><span class="line">    <span class="keyword">fi</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> nagios.<span class="number">192.16</span>.<span class="number">1.1</span>=<span class="string">'tmux_rename_window nagios.192.16.1.1'</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;当想登录<code>192.168.1.1</code>这台部署了<code>nagiso</code>的机器时，终端上输入<code>nagios.192.16.1.1</code>后会将Tmux的Window Name修改成<code>nagios.192.16.1.1</code>并SSH到<code>192.168.1.1</code>机器上去。</p>
<p>&emsp;当SSH远程登录多台机器后可以使用<code>prefix w</code>列出所有窗口方便按照Window Name进行快速选择机器进行操作。</p>
<h2 id="tmux配置"><strong>tmux配置</strong></h2><p>&emsp;可通过以下命令查看所有终端的颜色：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">0</span>..<span class="number">255</span>&#125;;<span class="keyword">do</span> <span class="built_in">printf</span> <span class="string">"\x1b[38;5;<span class="variable">$&#123;i&#125;</span>mcolour<span class="variable">$&#123;i&#125;</span>\n"</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<h3 id="我的tmux配置"><strong>我的tmux配置</strong></h3><p>&emsp;tmux的配置文件为<code>~/.tmux.conf</code>，以下是我参考网上修改的配置文件，因为终端颜色显示问题最好先执行此命令<strong><code>echo &quot;alias tmux=&#39;tmux -2&#39;&quot; &gt;&gt; ~/.bashrc</code></strong><br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">##设置颜色</span></span><br><span class="line"><span class="keyword">set</span> -g <span class="keyword">default</span>-terminal <span class="string">"screen-256color"</span></span><br><span class="line"><span class="preprocessor">#set -g default-terminal "xterm"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">##### 256 ######</span></span><br><span class="line"><span class="preprocessor"># default statusbar colors</span></span><br><span class="line"><span class="keyword">set</span>-<span class="keyword">option</span> -g status-bg colour235 <span class="preprocessor">#base02</span></span><br><span class="line"><span class="keyword">set</span>-<span class="keyword">option</span> -g status-fg colour34 <span class="preprocessor">#purple</span></span><br><span class="line"><span class="keyword">set</span>-<span class="keyword">option</span> -g status-attr <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># default window title colors</span></span><br><span class="line"><span class="keyword">set</span>-window-<span class="keyword">option</span> -g window-status-fg colour244 <span class="preprocessor">#base0</span></span><br><span class="line"><span class="keyword">set</span>-window-<span class="keyword">option</span> -g window-status-bg <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># active window title colors</span></span><br><span class="line"><span class="keyword">set</span>-window-<span class="keyword">option</span> -g window-status-current-fg colour88 <span class="preprocessor">#red</span></span><br><span class="line"><span class="keyword">set</span>-window-<span class="keyword">option</span> -g window-status-current-bg colour232 <span class="preprocessor">#black</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># pane border</span></span><br><span class="line"><span class="keyword">set</span>-<span class="keyword">option</span> -g pane-border-fg colour235 <span class="preprocessor">#base02</span></span><br><span class="line"><span class="keyword">set</span>-<span class="keyword">option</span> -g pane-active-border-fg colour196 <span class="preprocessor">#base01</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># message text</span></span><br><span class="line"><span class="keyword">set</span>-<span class="keyword">option</span> -g message-bg colour235 <span class="preprocessor">#base02</span></span><br><span class="line"><span class="keyword">set</span>-<span class="keyword">option</span> -g message-fg colour83 <span class="preprocessor">#green</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># pane number display</span></span><br><span class="line"><span class="keyword">set</span>-<span class="keyword">option</span> -g display-panes-active-colour colour33 <span class="preprocessor">#blue</span></span><br><span class="line"><span class="keyword">set</span>-<span class="keyword">option</span> -g display-panes-colour colour166 <span class="preprocessor">#orange</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># clock</span></span><br><span class="line"><span class="keyword">set</span>-window-<span class="keyword">option</span> -g clock-mode-colour colour64</span><br><span class="line"><span class="keyword">set</span>-<span class="keyword">option</span> -g status-right <span class="string">"[#(hostname)] #(date +%H:%M' '%Y-%m-%d)"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#设置前缀</span></span><br><span class="line"><span class="keyword">set</span> -g prefix C-o</span><br><span class="line"><span class="preprocessor">#解除Ctrl+b 与前缀的对应关系</span></span><br><span class="line">unbind C-b</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#复制</span></span><br><span class="line"><span class="keyword">set</span>-window-<span class="keyword">option</span> -g mode-keys vi</span><br><span class="line">bind-<span class="keyword">key</span> -t vi-copy <span class="comment">'v' begin-selection</span></span><br><span class="line">bind-<span class="keyword">key</span> -t vi-copy <span class="comment">'y' copy-selection</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pane hjkl移动</span></span><br><span class="line">bind h <span class="keyword">select</span>-pane -L</span><br><span class="line">bind j <span class="keyword">select</span>-pane -D</span><br><span class="line">bind k <span class="keyword">select</span>-pane -U</span><br><span class="line">bind l <span class="keyword">select</span>-pane -R</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#系统粘贴</span></span><br><span class="line">bind o run-shell <span class="string">"tmux saveb - | xsel -i -b"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#tmux-resurrect and tmux-continuum</span></span><br><span class="line">run-shell ~/.tmux/tmux-resurrect/resurrect.tmux</span><br><span class="line">run-shell ~/.tmux/tmux-continuum/continuum.tmux</span><br><span class="line"><span class="keyword">set</span> -g @continuum-restore <span class="comment">'on'</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;<a href="https://tmux.github.io/" target="_blank" rel="external">tmux</a>是一款优秀且好用的终端复用工具，有点类似screen。之所以说好用是因为它支持全键盘操作，连屏幕复制都能直接通过键盘]]>
    </summary>
    
      <category term="tmux" scheme="http://yoursite.com/tags/tmux/"/>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Autossh反向连接]]></title>
    <link href="http://yoursite.com/2015/05/23/autossh/"/>
    <id>http://yoursite.com/2015/05/23/autossh/</id>
    <published>2015-05-23T11:54:39.000Z</published>
    <updated>2015-05-23T13:19:06.000Z</updated>
    <content type="html"><![CDATA[<p>&emsp;一般我们管理内网机器常用的方式都是NAT/VPN。SSH对Linux用户来说再熟悉不过了，其实我们可以通过ssh反向连接来管理内网的机器，而autossh顾名思义则是在ssh由于某种原因断开后自动重连的工具。autossh配合ssh反向连接可以很轻松的管理内网机器。(需要一台外网机器)</p>
<h2 id="autossh安装"><strong>autossh安装</strong></h2><p>&emsp;在内网机器上安装autossh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install autossh</span><br></pre></td></tr></table></figure></p>
<h2 id="ssh免密码登录"><strong>ssh免密码登录</strong></h2><p>&emsp;内网机器需要能ssh免密码登录到外网机器，在内网机器上生成公钥并复制到外网主机<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P <span class="string">''</span> <span class="operator">-f</span> ~/.ssh/id_rsa</span><br><span class="line">ssh-copy-id -p port user@ip</span><br></pre></td></tr></table></figure></p>
<h2 id="启动autossh"><strong>启动autossh</strong></h2><p>&emsp;在内网机器上对autossh进行配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">autossh -o <span class="string">"StrictHostKeyChecking no"</span> -M <span class="number">8888</span> <span class="operator">-f</span>NR <span class="number">20001</span>:localhost:<span class="number">22</span> user@ip -p port</span><br><span class="line">  -o <span class="string">"StrictHostKeyChecking no"</span>：取消ssh首次连接时的确认</span><br><span class="line">  -M port：autossh通过port端口监控连接状态，若连接有问题则会自动重连(port随意定义)</span><br><span class="line">  <span class="operator">-f</span>：后台运行</span><br><span class="line">  -N：不执行远程命令，仅作端口转发</span><br><span class="line">  -R：绑定映射端口，外网port:localhost:内网port</span><br><span class="line">  user@ip -p port：外网的ssh用户及ssh端口</span><br></pre></td></tr></table></figure></p>
<h2 id="反向连接"><strong>反向连接</strong></h2><p>&emsp;在外网机器上通过ssh反向连接管理内网机器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p <span class="number">20001</span> root@localhost</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;一般我们管理内网机器常用的方式都是NAT/VPN。SSH对Linux用户来说再熟悉不过了，其实我们可以通过ssh反向连接来管理内网的机器，而autossh顾名思义则是在ssh由于某种原因断开后自动重连的工具。autossh配合ssh反向连接可以很轻松的管理内网机]]>
    </summary>
    
      <category term="autossh" scheme="http://yoursite.com/tags/autossh/"/>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[建站记]]></title>
    <link href="http://yoursite.com/2015/03/22/build-blog/"/>
    <id>http://yoursite.com/2015/03/22/build-blog/</id>
    <published>2015-03-22T13:22:11.000Z</published>
    <updated>2015-06-29T13:35:32.000Z</updated>
    <content type="html"><![CDATA[<p>&emsp;零碎记录一下此博客的建立过程，基础说明如下：</p>
<ul>
<li>系统：Ubuntu 14.04 32位</li>
<li>博客框架：<a href="http://hexo.io/" target="_blank" rel="external">hexo</a></li>
<li>主题：Nadya</li>
<li>代码仓库：Github</li>
</ul>
<p>&emsp;基本情况就这样，以下是详细建站过程记录。。。    </p>
<h2 id="安装NodeJS"><strong>安装NodeJS</strong></h2><p>&emsp;因为hexo是基于NodeJS开发的，所以需要先安装NodeJS相关的环境。最方便快捷的方法是直接使用apt-get安装，如果安装失败那很可能是源的问题需要在网上找到一个合适可用的源。直接执行以下命令进行安装：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> nodejs</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> npm</span></span><br></pre></td></tr></table></figure></p>
<h2 id="安装hexo"><strong>安装hexo</strong></h2><p>&emsp;如果你是采用apt-get安装的NodeJS，那么必须先要建立一个软链接。因为使用apt-get方式安装的NodeJS命令为<code>/usr/bin/nodejs</code>，但在安装hexo的过程中hexo是寻找<code>/usr/bin/node</code>命令。若不事先建立软链接，那么在安装hexo的过程会报错<code>无法找到node命令</code><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s <span class="regexp">/usr/</span>bin<span class="regexp">/nodejs /u</span>sr<span class="regexp">/bin/</span>node</span><br><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure></p>
<h2 id="初始化hexo"><strong>初始化hexo</strong></h2><p>&emsp;安装完hexo后，建立目录用于存放博客程序并在此目录对hexo进行初始化操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog_dir &amp;&amp; hexo init</span><br><span class="line">sudo npm install</span><br></pre></td></tr></table></figure></p>
<h2 id="生成静态页面"><strong>生成静态页面</strong></h2><p>&emsp;初始化hexo后，需要使用<code>hexo g</code>命令生成相关的静态页面文件。<code>hexo g</code>命令是<code>hexo generate</code>的简写<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g	<span class="keyword">or</span>	hexo <span class="keyword">ge</span><span class="label">nerate</span></span><br></pre></td></tr></table></figure></p>
<h2 id="本地启动"><strong>本地启动</strong></h2><p>&emsp;使用<code>hexo g</code>后会在目录下生成许多博客相关的目录及文件，成功生成文件后一个默认的hexo博客就已经建好了，只需要在本地启动hexo即可浏览博客<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s	<span class="keyword">or</span>	hexo <span class="built_in">server</span></span><br></pre></td></tr></table></figure></p>
<h2 id="hexo主题"><strong>hexo主题</strong></h2><p>&emsp;hexo默认使用<code>landscape</code>主题，可以到<a href="https://github.com/hexojs/hexo/wiki/themes" target="_blank" rel="external">这里</a>选着自己喜欢的主题并根据自己喜好对主题进行修改(需要懂点前端知识)。安装主题和后续需要使用到Github，所以先安装Github<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install git-core</span><br></pre></td></tr></table></figure></p>
<p>&emsp;使用Github安装主题，主题将会被安装在<code>blog_dir/themes</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="tag">&lt;<span class="title">theme-gitgub-url</span>&gt;</span> themes/<span class="tag">&lt;<span class="title">theme-name</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;在配置文件<code>_config.yml</code>中指定主题<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">theme</span>: <span class="string">&lt;theme-name&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="配置RSS订阅"><strong>配置RSS订阅</strong></h2><p>&emsp;hexo默认是没有RSS订阅功能的，需要自己配置。先安装hexo的RSS订阅插件<code>hexo-generator-feed</code>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;在<code>&lt;blog_dir&gt;/_config.yml</code>配置文件的最后添加RSS订阅的相关配置项，注意<code>-</code>后有一个<code>空格</code>：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line"><span class="bullet">- </span>hexo-generator-feed</span><br></pre></td></tr></table></figure></p>
<p>&emsp;完成后使用<code>hexo g</code>生成RSS订阅文件<code>atom.xml</code>，生成的xml文件会存放在<code>&lt;blog_dir&gt;/public/atom.xml</code>，如果存在此文件则说明成功。直接访问<code>http://域名/atom.xml</code>或将其嵌入到博客代码中即可</p>
<h2 id="添加categories配置项"><strong>添加categories配置项</strong></h2><p>&emsp;一般使用<a href="https://zh.wikipedia.org/zh/Markdown" target="_blank" rel="external">Markdown</a>写文章可以用<strong><code>hexo n &quot;article title&quot;</code></strong>命令生成一个md文件。生成的md文件会存放在<code>&lt;blog_dir/source/_posts</code>目录下，默认会有如下内容：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: "article title"</span><br><span class="line">date: xxxx-xx-xx xx:xx:xx</span><br><span class="line"><span class="header">tags: </span><br><span class="line">---</span></span><br></pre></td></tr></table></figure></p>
<p><code>title</code>即文件的标题；<code>tags</code>即标签，如果需要写<strong>多个标签<code>[tag1, tag2]</code></strong>，<em>注意冒号后必须有一个空格</em>；但我想要默认添加一个分类<code>categories</code>的配置<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">vim <span class="tag">&lt;<span class="title">blog_dir</span>&gt;</span>/scaffolds/post.md</span><br><span class="line">添加一行categories:，添加后：</span><br><span class="line">	title: </span><span class="expression">&#123;&#123; <span class="variable">title</span> &#125;&#125;</span><span class="xml"></span><br><span class="line">	date: </span><span class="expression">&#123;&#123; <span class="variable">date</span> &#125;&#125;</span><span class="xml"></span><br><span class="line">	categories:</span><br><span class="line">	tags:</span><br><span class="line">	---</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Github配置"><strong>Github配置</strong></h2><p>&emsp;写好的博客内容最终是要上传到Github的，又不想每次发布的时候都需要输入Github相关的账号及密码。所以要对Github做一些配置。首先需要有一个Github账号，没有的需要<a href="https://github.com/join" target="_blank" rel="external">注册</a>。<br>配置ssh免密码登录<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -<span class="keyword">C</span> <span class="string">"注册邮箱"</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;添加SSH keys<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">登录Github——&gt;setting——&gt;SSH <span class="built_in">keys</span>——&gt;Add SSH <span class="built_in">key</span></span><br><span class="line">将~/.ssh/id_rsa.pub的内容复制到Github上</span><br></pre></td></tr></table></figure></p>
<p>&emsp;测试ssh无密码连接Github<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">第一次手动输入<span class="string">"yes"</span>后显示如下内容则设置成功：</span><br><span class="line">The authenticity <span class="keyword">of</span> host <span class="attribute">'github</span>.com ' can<span class="attribute">'t</span> be established.</span><br><span class="line">RSA key fingerprint <span class="keyword">is</span> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">Are you sure you want <span class="keyword">to</span> continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added <span class="attribute">'github</span>.com' (RSA) <span class="keyword">to</span> the list <span class="keyword">of</span> known hosts.</span><br><span class="line">Hi username! You<span class="attribute">'ve</span> successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell <span class="keyword">access</span>.</span><br></pre></td></tr></table></figure></p>
<p>&emsp;Github账号相关配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user<span class="class">.name</span> <span class="string">"Github注册用户名"</span></span><br><span class="line">git config --global user<span class="class">.email</span> <span class="string">"Github注册邮箱"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="创建博客Github项目"><strong>创建博客Github项目</strong></h2><p>&emsp;需要在Github上创建一个项目用于存放博客的内容.<strong>Repository name必须是<code>用户名.github.io</code></strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录Github——&gt;New Repository——&gt;Repository <span class="function"><span class="title">name</span><span class="params">(必须是:用户名.github.io)</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="hexo发布博客配置"><strong>hexo发布博客配置</strong></h2><p>&emsp;想要通过hexo发布博客到Github上需要安装<code>hexo-deployer-git</code>插件<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm <span class="operator"><span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;配置_config.yml。<code>repository</code>必须写成<code>git@github.com:用户名/用户名.github.io.git</code>这种形式，如果写成url形式<code>https://github.com/用户名/用户名.github.io.git</code>则每次发布时都要输入Github的用户名及密码!<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">	<span class="attribute">type</span>: git</span><br><span class="line">	<span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:用户名/用户名.github.io.git</span><br><span class="line">	<span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p>
<p>&emsp;写完博客后通过命令<code>hexo d</code>进行发布，通过域名<code>https://用户名.github.io/</code>进行访问博客</p>
<h2 id="写博客流程"><strong>写博客流程</strong></h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">n</span> <span class="string">"article name"</span>			生成Markdown文件并用Markdown格式写博客</span><br><span class="line">hexo s					本地启动hexo查看博客</span><br><span class="line">hexo <span class="keyword">g</span>					生成博客页面</span><br><span class="line">hexo <span class="keyword">d</span>					发布博客</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;零碎记录一下此博客的建立过程，基础说明如下：</p>
<ul>
<li>系统：Ubuntu 14.04 32位</li>
<li>博客框架：<a href="http://hexo.io/" target="_blank" rel="external">hexo]]>
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[About this blog]]></title>
    <link href="http://yoursite.com/2015/03/12/About-this-blog/"/>
    <id>http://yoursite.com/2015/03/12/About-this-blog/</id>
    <published>2015-03-12T11:21:04.000Z</published>
    <updated>2015-03-22T14:01:56.000Z</updated>
    <content type="html"><![CDATA[<p>&emsp;此博客主要用于个人记录，记录笔记、生活新发现等。崇尚简约风格，目前没有以后估计也不会有诸如评论系统、友情链接等东西。<br>若有什么问题需要联系请E-mail我——fatesai#gmail.com<br><em>2015-03-12 by 小mo</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;此博客主要用于个人记录，记录笔记、生活新发现等。崇尚简约风格，目前没有以后估计也不会有诸如评论系统、友情链接等东西。<br>若有什么问题需要联系请E-mail我——fatesai#gmail.com<br><em>2015-03-12 by 小mo</em></]]>
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
</feed>