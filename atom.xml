<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hexo]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2019-07-02T06:02:04.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[John Doe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Golang RPC]]></title>
    <link href="http://yoursite.com/2019/06/28/golang-rpc/"/>
    <id>http://yoursite.com/2019/06/28/golang-rpc/</id>
    <published>2019-06-28T07:54:39.000Z</published>
    <updated>2019-07-02T06:02:04.000Z</updated>
    <content type="html"><![CDATA[<p><strong>RPC</strong>(Remote Procedure Call)，远程调用。RPC消息传输可通过TCP、HTTP和UDP等。<br>Golang中实现RPC有多种方式：</p>
<ul>
<li><strong><code>net/rpc</code></strong>: 官方RPC库，支持TCP和HTTP方式传输，使用<code>gob</code>编解码(导致无法跨语言调用)</li>
<li><strong><code>net/rpc/jsonrpc</code></strong>: 官方RPC库，仅支持TCP传输，使用<code>json</code>编解码(可跨语言调用)</li>
<li><strong><code>gRPC</code></strong>: Google开源RPC库，基于HTTP/2传输，使用<code>ProtoBuf</code>编解码</li>
</ul>
<p>当然除上面3种外还是许多RPC库，目前有所接触的是<code>net/rpc/jsonrpc</code>、<code>gRPC</code>，主要记录这2种，后续若有接触其他实现方式会持续更新。</p>
<h2 id="jsonrpc"><a href="#jsonrpc" class="headerlink" title="jsonrpc"></a><strong>jsonrpc</strong></h2><p>使用<code>net/rpc/jsonrpc</code>库，想要方法能被远程访问，需要满足以下条件：<br>可输出在Golang中即首字母大写</p>
<ol>
<li>方法的类型可输出 (the method’s type is exported) <code>*T</code></li>
<li>方法可输出 （the method is exported）<code>MethodName</code></li>
<li>方法必须有两个参数，且必须是输出类型或者是内建类型 (the method has two arguments, both exported or builtin types)  <code>T1</code> <code>*T2</code></li>
<li>方法的第二个参数是指针类型 (the method’s second argument is a pointer)   <code>*T2</code></li>
<li>方法返回类型为 error (the method has return type error)  <code>error</code></li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (t *T) MethodName(argType T1, replyType *T2) error</span><br></pre></td></tr></table></figure>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a><strong>目录结构</strong></h3><p>演示实例目录结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── client  // client rpc封装调用方法</span><br><span class="line">│   └── rpc.go</span><br><span class="line">├── common  // 公共结构体</span><br><span class="line">│   └── rpc.go</span><br><span class="line">├── jsonrpcClient.go</span><br><span class="line">├── jsonrpcServer.go</span><br><span class="line">└── server  // server rpc封装方法</span><br><span class="line">    ├── agent.go</span><br><span class="line">    └── rpc.go</span><br></pre></td></tr></table></figure></p>
<h3 id="请求响应参数结构体"><a href="#请求响应参数结构体" class="headerlink" title="请求响应参数结构体"></a><strong>请求响应参数结构体</strong></h3><p>定义请求参数、响应参数的结构体，client和server都需要使用<br><code>common/rpc.go</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> common</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC请求参数</span></span><br><span class="line"><span class="keyword">type</span> AgentReportRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Hostname <span class="typename">string</span> <span class="string">`json:"hostname"`</span></span><br><span class="line">    IP       <span class="typename">string</span> <span class="string">`json:"ip"`</span></span><br><span class="line">    Version  <span class="typename">string</span> <span class="string">`json:"version"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC响应参数</span></span><br><span class="line"><span class="comment">// code == 0 -&gt; success</span></span><br><span class="line"><span class="comment">// code == 1 -&gt; fail</span></span><br><span class="line"><span class="keyword">type</span> RpcResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code <span class="typename">int</span>    <span class="string">`json:"code"`</span></span><br><span class="line">    Msg  <span class="typename">string</span> <span class="string">`json:"msg"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RPC-Server端"><a href="#RPC-Server端" class="headerlink" title="RPC Server端"></a><strong>RPC Server端</strong></h3><h4 id="Server端RPC方法"><a href="#Server端RPC方法" class="headerlink" title="Server端RPC方法"></a><strong>Server端RPC方法</strong></h4><p>Server端的RPC方法都需要符合之前提到的5个条件方可别远程调用，方法接收的请求参数和响应参数为之前预先定义好的<br><code>server/agent.go</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/mogl/jsonrpc/common"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Agent <span class="typename">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法需要满足之前提到的5个条件</span></span><br><span class="line"><span class="comment">// 从client传入的args中 获取请求参数，进行逻辑处理，并构造reply结构返回</span></span><br><span class="line"><span class="keyword">func</span> (ag *Agent) ReportStatus(args *common.AgentReportRequest, reply *common.RpcResponse) error &#123;</span><br><span class="line">    <span class="keyword">if</span> args.Hostname == <span class="string">""</span> &#123;</span><br><span class="line">        reply.Code = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"rpc server receive, hostname:%s, ip:%s, version:%s"</span>, args.Hostname, args.IP, args.Version)</span><br><span class="line">    reply.Code = <span class="number">0</span></span><br><span class="line">    reply.Msg = <span class="string">"call rpc server successfully."</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建RPC-Server服务"><a href="#创建RPC-Server服务" class="headerlink" title="创建RPC Server服务"></a><strong>创建RPC Server服务</strong></h4><p>监听TCP端口、注册服务<br><code>server/rpc.go</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">    <span class="string">"net/rpc/jsonrpc"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建rpc server服务</span></span><br><span class="line"><span class="keyword">func</span> Start() &#123;</span><br><span class="line">    addr := <span class="string">":2333"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建server</span></span><br><span class="line">    server := rpc.NewServer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册处理器</span></span><br><span class="line">    server.Register(<span class="built_in">new</span>(Agent)) <span class="comment">// server/agent.go</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听TCP端口</span></span><br><span class="line">    l, e := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">    <span class="keyword">if</span> e != <span class="constant">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">"listen error:"</span>, e)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"listerning"</span>, addr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待请求、每个client请求新建goroutine处理</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">            log.Fatalln(<span class="string">"listener accept fail:"</span>, err)</span><br><span class="line">            time.Sleep(time.Duration(<span class="number">100</span>) * time.Millisecond)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 绑定rpc的编码器</span></span><br><span class="line">        <span class="comment">// 新建jsonrpc编码器，并将该编码器绑定给http处理器</span></span><br><span class="line">        <span class="keyword">go</span> server.ServeCodec(jsonrpc.NewServerCodec(conn))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RPC-Client端"><a href="#RPC-Client端" class="headerlink" title="RPC Client端"></a><strong>RPC Client端</strong></h3><h4 id="建立连接-amp-远程调用"><a href="#建立连接-amp-远程调用" class="headerlink" title="建立连接 &amp; 远程调用"></a><strong>建立连接 &amp; 远程调用</strong></h4><p>在进行远程调用前，client需要先和server建立连接。同步方式使用<code>Call()</code>函数调用，异步方式使用<code>Go()</code>函数调用(异步调用需要使用channel取回返回数据，<code>Done</code>)<br><code>client/rpc.go</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">    <span class="string">"net/rpc/jsonrpc"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义client连接用的结构体</span></span><br><span class="line"><span class="keyword">type</span> ConnRpcClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    rpcClient *rpc.Client</span><br><span class="line">    RpcServer <span class="typename">string</span></span><br><span class="line">    Timeout   time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client和server建立连接</span></span><br><span class="line"><span class="keyword">func</span> (c *ConnRpcClient) rpcServerConn() error &#123;</span><br><span class="line">    <span class="keyword">if</span> c.rpcClient != <span class="constant">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重试次数</span></span><br><span class="line">    retry := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.rpcClient != <span class="constant">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TCP连接</span></span><br><span class="line">        conn, err := net.DialTimeout(<span class="string">"tcp"</span>, c.RpcServer, c.Timeout)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"dial %s fail: %v"</span>, c.RpcServer, err)</span><br><span class="line">            <span class="comment">// 最多尝试建立连接3次</span></span><br><span class="line">            <span class="keyword">if</span> retry &gt; <span class="number">3</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">"dial %s fail(retry %d times): %v"</span>, c.RpcServer, retry, err)</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            time.Sleep(time.Second &lt;&lt; <span class="typename">uint</span>(retry)) <span class="comment">// 指数退避重试</span></span><br><span class="line">            retry++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.rpcClient = jsonrpc.NewClient(conn) <span class="comment">// 基于TCP连接建立rpcClient实例</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client调用server方法</span></span><br><span class="line"><span class="keyword">func</span> (c *ConnRpcClient) Call(method <span class="typename">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;) error &#123;</span><br><span class="line">    <span class="comment">// 一个client实例如果要串行调用，同步阻塞，则加锁</span></span><br><span class="line">    <span class="comment">//c.Lock()</span></span><br><span class="line">    <span class="comment">//defer c.Unlock()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// client和server建立连接</span></span><br><span class="line">    err := c.rpcServerConn()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"connect rpc server %s fail: %v"</span>, c.RpcServer, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远程调用超时</span></span><br><span class="line">    timeout := time.Duration(<span class="number">15</span>) * time.Second</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client远程调用方法</span></span><br><span class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        <span class="comment">// 同步方式调用</span></span><br><span class="line">        err := c.rpcClient.Call(method, args, reply)</span><br><span class="line">        done &lt;- err</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用超时机制</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line">        log.Printf(<span class="string">"rpc call timeout: %s -&gt; %s"</span>, c.rpcClient, c.RpcServer)</span><br><span class="line">        c.rpcClient.Close()</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"rpc call timeout: %s -&gt; %s"</span>, c.rpcClient, c.RpcServer)</span><br><span class="line">    <span class="keyword">case</span> err := &lt;-done:</span><br><span class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">            c.rpcClient.Close()</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jsonrpc-调用"><a href="#jsonrpc-调用" class="headerlink" title="jsonrpc 调用"></a><strong>jsonrpc 调用</strong></h3><p><code>jsonrpcServer.go</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/mogl/jsonrpc/server"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="keyword">go</span> server.Start()   <span class="comment">// 创建jsonrpc server服务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>jsonrpcClient.go</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/mogl/jsonrpc/client"</span></span><br><span class="line">    <span class="string">"github.com/mogl/jsonrpc/common"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    req := &amp;common.AgentReportRequest&#123;</span><br><span class="line">        Hostname: <span class="string">"sai"</span>,</span><br><span class="line">        IP:       <span class="string">"localhost"</span>,</span><br><span class="line">        Version:  <span class="string">"1.0"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应参数</span></span><br><span class="line">    resp := &amp;common.RpcResponse&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client实例</span></span><br><span class="line">    rpcClient := client.ConnRpcClient&#123;</span><br><span class="line">        RpcServer: <span class="string">":2333"</span>,</span><br><span class="line">        Timeout:   time.Duration(<span class="number">10</span>) * time.Second,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Duration(<span class="number">3</span> * time.Second))</span><br><span class="line">    rpcClient.Call(<span class="string">"Agent.ReportStatus"</span>, req, resp)     <span class="comment">// jsonrpc 调用</span></span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">"response code:"</span>, resp.Code)</span><br><span class="line">    log.Println(<span class="string">"response msg:"</span>, resp.Msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a><strong>gRPC</strong></h2><p>  gRPC 默认使用 <em>protocol buffers</em>，这是 Google 开源的一套成熟的结构数据序列化机制。用 <em>proto files</em> 创建 gRPC 服务，用 protocol buffers 消息类型来定义方法参数和返回类型。你可以在 <a href="http://grpc.mydoc.io/https%EF%BC%9A//developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="external">Protocol Buffers 文档</a>找到更多关于 Protocol Buffers 的资料。<br>  在使用gRPC前需要进行一些比较麻烦的安装</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><h4 id="Install-Go"><a href="#Install-Go" class="headerlink" title="Install Go"></a><strong>Install Go</strong></h4><p>Go version &gt;= 1.6</p>
<h4 id="Install-Protocol-Buffers-v3"><a href="#Install-Protocol-Buffers-v3" class="headerlink" title="Install Protocol Buffers v3"></a><strong>Install Protocol Buffers v3</strong></h4><h5 id="Install-protoc"><a href="#Install-protoc" class="headerlink" title="Install protoc"></a><strong>Install protoc</strong></h5><p><a href="https://github.com/google/protobuf/releases" target="_blank" rel="external">protoc-[version]-[platform].zip</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip protoc-<span class="number">3.7</span>.<span class="number">1</span>-linux-x86_64.zip <span class="operator">-d</span> /usr/<span class="built_in">local</span>/protoc/</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'PATH=/usr/local/protoc/bin:$PATH'</span> &gt;&gt; /etc/profile &amp;&amp; <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<h5 id="Install-proctoc-gen-go"><a href="#Install-proctoc-gen-go" class="headerlink" title="Install proctoc-gen-go"></a><strong>Install proctoc-gen-go</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure>
<h4 id="Install-gRPC"><a href="#Install-gRPC" class="headerlink" title="Install gRPC"></a><strong>Install gRPC</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fail</span></span><br><span class="line">go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/grpc/grpc-go.git <span class="variable">$GOPATH</span>/src/google.golang.org/grpc</span><br><span class="line"><span class="comment">#git clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/net</span></span><br><span class="line"><span class="comment">#git clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/text</span></span><br><span class="line"><span class="comment">#git clone https://github.com/golang/sys.git $GOPATH/src/golang.org/x/sys</span></span><br><span class="line"><span class="comment">#go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;</span></span><br><span class="line"><span class="comment">#git clone https://github.com/google/go-genproto.git $GOPATH/src/google.golang.org/genproto</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/</span><br><span class="line">go install google.golang.org/grpc</span><br></pre></td></tr></table></figure>
<h3 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a><strong>目录结构</strong></h3><p>演示实例目录结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── helloworld</span><br><span class="line">    ├── client</span><br><span class="line">    │   └── main.go</span><br><span class="line">    ├── protos</span><br><span class="line">    │   ├── helloworld.pb.go</span><br><span class="line">    │   └── helloworld.proto</span><br><span class="line">    └── server</span><br><span class="line">        └── main.go</span><br></pre></td></tr></table></figure></p>
<h3 id="定义protobuf文件"><a href="#定义protobuf文件" class="headerlink" title="定义protobuf文件"></a><strong>定义protobuf文件</strong></h3><p>gRPC能定义4种类型服务方法</p>
<ul>
<li><p><strong>单项 RPC</strong>: 客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">serviceName</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">rpc</span> SayHello(HelloRequest) <span class="keyword">returns</span> (HelloResponse)&#123;&#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>服务端流式 RPC</strong>: 客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">serviceName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> LotsOfReplies(HelloRequest) <span class="keyword">returns</span> (stream HelloResponse)&#123;&#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端流式 RPC</strong>: 客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">serviceName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> LotsOfGreetings(stream HelloRequest) <span class="keyword">returns</span> (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>双向流式 RPC</strong>: 两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">serviceName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> BidiHello(stream HelloRequest) <span class="keyword">returns</span> (stream HelloResponse)&#123;&#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>protobuf3的消息类型定义规则，详细protobuf3语法参见: <a href="https://colobu.com/2017/03/16/Protobuf3-language-guide/" target="_blank" rel="external">Protobuf3 语法指南</a><br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> &lt;<span class="title">MessageName</span>&gt; </span>&#123;</span><br><span class="line">    &lt;FieldType&gt; &lt;FieldName&gt; = &lt;UniqueNumber&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>protobuf 文件编写</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协议版本</span></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务及方法</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义SayHello方法, 接收HelloRequest参数, 返回HelloReply</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义传入参数</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">    string name = 1</span>;    <span class="comment">// 1 是每个字段的唯一标识符，新增一个字段则递增</span></span><br><span class="line">    <span class="comment">// int32 age = 2;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义返回参数</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> msg = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将protobuf文件编译成Go文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd: helloworld</span></span><br><span class="line">protoc -I protos protos/helloworld.proto --go_out=plugins=grpc:./protos/</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd helloworld/protos</span></span><br><span class="line"><span class="comment">#protoc --go_out=plugins=grpc:. helloworld.proto</span></span><br></pre></td></tr></table></figure>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"net"</span></span><br><span class="line"></span><br><span class="line">        pb <span class="string">"github.com/mogl/gRPC/helloworld/protos"</span></span><br><span class="line">        <span class="string">"golang.org/x/net/context"</span></span><br><span class="line">        <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">        <span class="comment">//"google.golang.org/grpc/reflection"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        address = <span class="string">":50051"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义server结构体, 用于实现SayHello方法</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现SayHello方法</span></span><br><span class="line"><span class="keyword">func</span> (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloReply, error) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;pb.HelloReply&#123;Msg: <span class="string">"Hello "</span> + req.Name&#125;, <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">        <span class="comment">// 监听TCP</span></span><br><span class="line">        listener, err := net.Listen(<span class="string">"tcp"</span>, address)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">                log.Fatalf(<span class="string">"listen %v failed."</span>, address)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new rpc server</span></span><br><span class="line">        s := grpc.NewServer()</span><br><span class="line">        <span class="comment">// RegisterGreeterServer(), proto文件定义Greeter服务, protoc自动生成</span></span><br><span class="line">        pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Serve接收来自listener的连接，为每个连接创建ServerTransport和service goroutine处理连接请求</span></span><br><span class="line">        <span class="keyword">if</span> err := s.Serve(listener); err != <span class="constant">nil</span> &#123;</span><br><span class="line">                log.Fatalf(<span class="string">"Failed to server: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">        pb <span class="string">"github.com/mogl/gRPC/helloworld/protos"</span></span><br><span class="line">        <span class="string">"golang.org/x/net/context"</span></span><br><span class="line">        <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        address     = <span class="string">"localhost:50051"</span></span><br><span class="line">        defaultName = <span class="string">"World"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">        <span class="comment">// 与server建立连接</span></span><br><span class="line">        conn, err := grpc.Dial(address, grpc.WithInsecure())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">                log.Fatalf(<span class="string">"can't connect to the server: %v"</span>, address)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new client</span></span><br><span class="line">        client := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">        name := defaultName</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">                name = os.Args[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接server调用SayHello()函数</span></span><br><span class="line">        resp, err := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">                log.Fatalf(<span class="string">"client call SayHello() failed: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">"server response: %v"</span>, resp.Msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>RPC</strong>(Remote Procedure Call)，远程调用。RPC消息传输可通过TCP、HTTP和UDP等。<br>Golang中实现RPC有多种方式：</p>
<ul>
<li><strong><code>net/rpc</code>]]>
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Open-Falcon源码阅读-Agent]]></title>
    <link href="http://yoursite.com/2019/06/05/Open-Falcon-agent/"/>
    <id>http://yoursite.com/2019/06/05/Open-Falcon-agent/</id>
    <published>2019-06-04T16:05:39.000Z</published>
    <updated>2019-06-28T07:07:19.170Z</updated>
    <content type="html"><![CDATA[<h2 id="Agent源码目录结构"><a href="#Agent源码目录结构" class="headerlink" title="Agent源码目录结构"></a><strong>Agent源码目录结构</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cfg.example.json	// 配置文件示例</span><br><span class="line">├── control</span><br><span class="line">├── cron	// 定时任务</span><br><span class="line">├── funcs	// 各种采集指标函数</span><br><span class="line">├── g	// 配置文件、日志、rpc等全局设置及初始化</span><br><span class="line">├── http    // HTTP API</span><br><span class="line">├── LICENSE</span><br><span class="line">├── main.go		// 入口函数</span><br><span class="line">├── NOTICE</span><br><span class="line">├── plugins     // 插件</span><br><span class="line">├── public      // html、css、js文件</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>
<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><strong>main函数</strong></h2><h3 id="命令行参数解析"><a href="#命令行参数解析" class="headerlink" title="命令行参数解析"></a><strong>命令行参数解析</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行参数解析</span></span><br><span class="line">cfg := flag.String(<span class="string">"c"</span>, <span class="string">"cfg.json"</span>, <span class="string">"configuration file"</span>)</span><br><span class="line">version := flag.Bool(<span class="string">"v"</span>, <span class="constant">false</span>, <span class="string">"show version"</span>)</span><br><span class="line">check := flag.Bool(<span class="string">"check"</span>, <span class="constant">false</span>, <span class="string">"check collector"</span>)</span><br><span class="line"></span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否打印agent版本信息</span></span><br><span class="line"><span class="keyword">if</span> *version &#123;</span><br><span class="line">    fmt.Println(g.VERSION)	<span class="comment">// g/const.go VERSION</span></span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否检查采集器</span></span><br><span class="line"><span class="keyword">if</span> *check &#123;</span><br><span class="line">    funcs.CheckCollector()	<span class="comment">// funcs/checker.go</span></span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="funcs-CheckCollector"><a href="#funcs-CheckCollector" class="headerlink" title="funcs.CheckCollector()"></a><strong>funcs.CheckCollector()</strong></h4><p>函数主要功能为检测各个采集模块功能是否正常</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> CheckCollector() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化存放检测结果mapping</span></span><br><span class="line">    output := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toolkits/nux/cpustat.go</span></span><br><span class="line">    <span class="comment">// 检测CPU状态，/proc/stat</span></span><br><span class="line">    _, procStatErr := nux.CurrentProcStat()</span><br><span class="line">    <span class="comment">// toolkits/nux/iostat.go</span></span><br><span class="line">    <span class="comment">// 检测磁盘状态，/proc/diskstats</span></span><br><span class="line">    _, listDiskErr := nux.ListDiskStats()</span><br><span class="line">    <span class="comment">// toolkits/nux/prostat.go</span></span><br><span class="line">    <span class="comment">// 获取系统所有TCP监听端口，ss -t -n -l</span></span><br><span class="line">    ports, listeningPortsErr := nux.ListeningPorts()</span><br><span class="line">    <span class="comment">// toolkits/nux/proc.go</span></span><br><span class="line">    <span class="comment">// 获取所有进程，/proc/&lt;pid&gt;/status，/proc/&lt;pid&gt;cmdline</span></span><br><span class="line">    procs, psErr := nux.AllProcs()</span><br><span class="line"></span><br><span class="line">    _, duErr := sys.CmdOut(<span class="string">"du"</span>, <span class="string">"--help"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大部分调用funcs包下模块对各采集项进行检测</span></span><br><span class="line">    output[<span class="string">"kernel  "</span>] = <span class="built_in">len</span>(KernelMetrics()) &gt; <span class="number">0</span></span><br><span class="line">    output[<span class="string">"df.bytes"</span>] = DeviceMetricsCheck()</span><br><span class="line">    output[<span class="string">"net.if  "</span>] = <span class="built_in">len</span>(CoreNetMetrics([]<span class="typename">string</span>&#123;&#125;)) &gt; <span class="number">0</span></span><br><span class="line">    output[<span class="string">"loadavg "</span>] = <span class="built_in">len</span>(LoadAvgMetrics()) &gt; <span class="number">0</span></span><br><span class="line">    output[<span class="string">"cpustat "</span>] = procStatErr == <span class="constant">nil</span></span><br><span class="line">    output[<span class="string">"disk.io "</span>] = listDiskErr == <span class="constant">nil</span></span><br><span class="line">    output[<span class="string">"memory  "</span>] = <span class="built_in">len</span>(MemMetrics()) &gt; <span class="number">0</span></span><br><span class="line">    output[<span class="string">"netstat "</span>] = <span class="built_in">len</span>(NetstatMetrics()) &gt; <span class="number">0</span></span><br><span class="line">    output[<span class="string">"ss -s   "</span>] = <span class="built_in">len</span>(SocketStatSummaryMetrics()) &gt; <span class="number">0</span></span><br><span class="line">    output[<span class="string">"ss -tln "</span>] = listeningPortsErr == <span class="constant">nil</span> &amp;&amp; <span class="built_in">len</span>(ports) &gt; <span class="number">0</span></span><br><span class="line">    output[<span class="string">"ps aux  "</span>] = psErr == <span class="constant">nil</span> &amp;&amp; <span class="built_in">len</span>(procs) &gt; <span class="number">0</span></span><br><span class="line">    output[<span class="string">"du -bs  "</span>] = duErr == <span class="constant">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印检测结果</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> output &#123;</span><br><span class="line">        status := <span class="string">"fail"</span></span><br><span class="line">        <span class="keyword">if</span> v &#123;</span><br><span class="line">            status = <span class="string">"ok"</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(k, <span class="string">"..."</span>, status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a><strong>配置文件解析</strong></h3><h4 id="g-ParseConfig-cfg"><a href="#g-ParseConfig-cfg" class="headerlink" title="g.ParseConfig(*cfg)"></a><strong>g.ParseConfig(*cfg)</strong></h4><p>解析通过命令行<code>-c</code>参数传入的配置文件</p>
<p>通过调用<code>g.Config()</code>函数获取package级变量<code>config *GlobalConfig</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`g.Config()` ---&gt; `config`(`config *GobalConfig`) ---&gt; `config = &amp;c` ---&gt; `json.Unmarshal([]byte(configContent), &amp;c)` ---&gt; `configContent, err := file.ToTrimString(cfg)`</span><br></pre></td></tr></table></figure>
<p>通过<code>g.Config().XXX</code>即可获取<code>-c</code>指定配置文件的具体配置项目</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g/cfg.go</span></span><br><span class="line"><span class="keyword">func</span> ParseConfig(cfg <span class="typename">string</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// toolkits/file/reader.go</span></span><br><span class="line">    <span class="comment">// ToTrimString()/strings.TrimSpace() ---&gt; ToString() ---&gt; ioutil.ReadFile()</span></span><br><span class="line">    configContent, err := file.ToTrimString(cfg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">"read config file:"</span>, cfg, <span class="string">"fail:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// agent配置文件结构体</span></span><br><span class="line">    <span class="comment">// GlobalConfig嵌套了Plugin、Heartbeat、Transfer、Http和Collector结构体，结合cfg.example.json模板配置文件看</span></span><br><span class="line">    <span class="comment">// json ---&gt; struct</span></span><br><span class="line">    <span class="keyword">var</span> c GlobalConfig</span><br><span class="line">    err = json.Unmarshal([]<span class="typename">byte</span>(configContent), &amp;c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">"parse config file:"</span>, cfg, <span class="string">"fail:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// package级变量</span></span><br><span class="line">    <span class="comment">// lock = new(sync.RWMutex)</span></span><br><span class="line">    lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// package级变量</span></span><br><span class="line">    <span class="comment">// config *GlobalConfig</span></span><br><span class="line">    config = &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g/cfg.go</span></span><br><span class="line"><span class="comment">// 通过g.Config()函数获取到存放配置文件内容的*GlobalConfig指针结构体变量config</span></span><br><span class="line"><span class="keyword">func</span> Config() *GlobalConfig &#123;</span><br><span class="line">    lock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> lock.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="g初始化"><a href="#g初始化" class="headerlink" title="g初始化"></a><strong>g初始化</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用os.Getwd()获取当前目录路径</span></span><br><span class="line">g.InitRootDir()</span><br><span class="line"><span class="comment">// 通过net包向Heartbeat server服务发起TCP连接获取本地agent机器IP</span></span><br><span class="line">g.InitLocalIp()</span><br><span class="line"><span class="comment">// 构造SingleConnRpcClient结构体对象，设置Heartbeat server服务端IP:Port及连接超时时间</span></span><br><span class="line">g.InitRpcClients()</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SingleConnRpcClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    rpcClient *rpc.Client</span><br><span class="line">    RpcServer <span class="typename">string</span></span><br><span class="line">    Timeout   time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="监控项采集mapping"><a href="#监控项采集mapping" class="headerlink" title="监控项采集mapping"></a><strong>监控项采集mapping</strong></h3><h4 id="funcs-BuildMappers"><a href="#funcs-BuildMappers" class="headerlink" title="funcs.BuildMappers()"></a><strong>funcs.BuildMappers()</strong></h4><p><code>BuildMappers()</code>函数的作用是构建采集各种指标的函数，而这些函数的返回值统一都是<code>[]*model.MetricValue</code>，<code>model.MetricValue</code>结构体为: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MetricValue <span class="keyword">struct</span> &#123;</span><br><span class="line">    Endpoint  <span class="typename">string</span>      <span class="string">`json:"endpoint"`</span></span><br><span class="line">    Metric    <span class="typename">string</span>      <span class="string">`json:"metric"`</span>	<span class="comment">// 监控项名称</span></span><br><span class="line">    Value     <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:"value"`</span>	<span class="comment">// 监控项值</span></span><br><span class="line">    Step      <span class="typename">int64</span>       <span class="string">`json:"step"`</span>		<span class="comment">// 采集间隔</span></span><br><span class="line">    Type      <span class="typename">string</span>      <span class="string">`json:"counterType"`</span>	<span class="comment">//RRD数据类型: Counter、Derive、Absolute、Gauge、Compute</span></span><br><span class="line">    Tags      <span class="typename">string</span>      <span class="string">`json:"tags"`</span>		<span class="comment">// 监控项标签</span></span><br><span class="line">    Timestamp <span class="typename">int64</span>       <span class="string">`json:"timestamp"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Type</code>是指RRD中的DST(data source type)，共计5种: </p>
<ul>
<li><strong><code>Counter</code></strong>: 递增类型(必须增加) (Open-Falcon常用类型)</li>
<li><strong><code>Derive</code></strong>: 可增可减类型</li>
<li><strong><code>Absolute</code></strong>: 每次都假定前一个interval的值是0，再计算平均值</li>
<li><strong><code>Gauge</code></strong>: 直接将值存入RRD，不做任何处理 (Open-Falcon常用类型)</li>
<li><strong><code>Compute</code></strong>: 不接受输入，直接定义表达式，引用其他RRD中的DS自动计算出某个值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// funcs/funcs.go</span></span><br><span class="line"><span class="keyword">type</span> FuncsAndInterval <span class="keyword">struct</span> &#123;</span><br><span class="line">    Fs       []<span class="keyword">func</span>() []*model.MetricValue	<span class="comment">// 一组生成MetricValue的函数</span></span><br><span class="line">    Interval <span class="typename">int</span>	<span class="comment">// 上传数据到Transfer的时间间隔</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Mappers []FuncsAndInterval</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> BuildMappers() &#123;</span><br><span class="line">    interval := g.Config().Transfer.Interval	<span class="comment">// 获取配置文件中上传数据到Transfer的时间间隔</span></span><br><span class="line">    Mappers = []FuncsAndInterval&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Fs: []<span class="keyword">func</span>() []*model.MetricValue&#123;</span><br><span class="line">                AgentMetrics,</span><br><span class="line">                CpuMetrics,</span><br><span class="line">                NetMetrics,</span><br><span class="line">                KernelMetrics,</span><br><span class="line">                LoadAvgMetrics,</span><br><span class="line">                MemMetrics,</span><br><span class="line">                DiskIOMetrics,</span><br><span class="line">                IOStatsMetrics,</span><br><span class="line">                NetstatMetrics,</span><br><span class="line">                ProcMetrics,</span><br><span class="line">                UdpMetrics,</span><br><span class="line">            &#125;,</span><br><span class="line">            Interval: interval,</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>以<code>LoadAvgMetrics</code>为例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取指标值 ---&gt; GaugeValue()|CounterValue() ---&gt; NewMetricValue() 创建*model.MetricValue</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> LoadAvgMetrics() []*model.MetricValue &#123;</span><br><span class="line">    load, err := nux.LoadAvg()	<span class="comment">// 获取指标值</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []*model.MetricValue&#123;</span><br><span class="line">        GaugeValue(<span class="string">"load.1min"</span>, load.Avg1min),	<span class="comment">// 调用GaugeValue()函数，实际构建*medel.MetricValue数据的是NewMetricValue()函数</span></span><br><span class="line">        GaugeValue(<span class="string">"load.5min"</span>, load.Avg5min),</span><br><span class="line">        GaugeValue(<span class="string">"load.15min"</span>, load.Avg15min),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> GaugeValue(metric <span class="typename">string</span>, val <span class="keyword">interface</span>&#123;&#125;, tags ...<span class="typename">string</span>) *model.MetricValue &#123;</span><br><span class="line">    <span class="keyword">return</span> NewMetricValue(metric, val, <span class="string">"GAUGE"</span>, tags...)	<span class="comment">// 调用NewMetricValue()构建*model.MetricValue数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> NewMetricValue(metric <span class="typename">string</span>, val <span class="keyword">interface</span>&#123;&#125;, dataType <span class="typename">string</span>, tags ...<span class="typename">string</span>) *model.MetricValue &#123;</span><br><span class="line">    <span class="comment">// 根据传入参数构建model.MetricValue数据</span></span><br><span class="line">    mv := model.MetricValue&#123;</span><br><span class="line">        Metric: metric,	<span class="comment">// 监控项名称，load.1min/load.5min/load.15min</span></span><br><span class="line">        Value:  val,	<span class="comment">// 监控项值</span></span><br><span class="line">        Type:   dataType,	<span class="comment">// 数据类型，Gauge/Counter，Open-Falcon Agent只用到这2种DST</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size := <span class="built_in">len</span>(tags)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> size &gt; <span class="number">0</span> &#123;</span><br><span class="line">        mv.Tags = strings.Join(tags, <span class="string">","</span>)	<span class="comment">// tag有值则加入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;mv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终<code>LoadAvgMetrics()</code>函数返回的数据样例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;Endpoint:, Metric:load<span class="number">.1</span>min, Type:GAUGE, Tags:, Step:<span class="number">0</span>, Time:<span class="number">0</span>, Value:<span class="number">0.32</span>&gt; &lt;Endpoint:, Metric:load<span class="number">.5</span>min, Type:GAUGE, Tags:, Step:<span class="number">0</span>, Time:<span class="number">0</span>, Value:<span class="number">0.26</span>&gt; &lt;Endpoint:, Metric:load<span class="number">.15</span>min, Type:GAUGE, Tags:, Step:<span class="number">0</span>, Time:<span class="number">0</span>, Value:<span class="number">0.28</span>&gt;]</span><br></pre></td></tr></table></figure>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a><strong>定时任务</strong></h3><h4 id="cron-InitDataHistory"><a href="#cron-InitDataHistory" class="headerlink" title="cron.InitDataHistory()"></a><strong>cron.InitDataHistory()</strong></h4><p><code>cron.InitDataHistory()</code>作用是周期性更新CPU和Disk状态信息，保留上次采集及此次更新的数据，总共会保留2份数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> InitDataHistory() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        funcs.UpdateCpuStat()	<span class="comment">// 更新CPU状态</span></span><br><span class="line">        funcs.UpdateDiskStats()	<span class="comment">// 更新磁盘状态</span></span><br><span class="line">        time.Sleep(g.COLLECT_INTERVAL)	<span class="comment">// 默认1秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cron-ReportAgentStatus"><a href="#cron-ReportAgentStatus" class="headerlink" title="cron.ReportAgentStatus()"></a><strong>cron.ReportAgentStatus()</strong></h4><p><code>cron.ReportAgentStatus()</code>作用是每隔<code>Heartbeat.Interval(配置文件中设定)</code>秒通过RPC方式向HBS上报agent信息，上报数据为<code>model.AgentReportRequest</code></p>
<p>上报逻辑为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cron.ReportAgentStatus() ---&gt; go reportAgentStatus() ---&gt; g.HbsClient.Call() ---&gt; serverConn() &amp; rcpClient.Call()</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open-falcon/falcon-plus/common/model/agent.go</span></span><br><span class="line"><span class="keyword">type</span> AgentReportRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Hostname      <span class="typename">string</span></span><br><span class="line">    IP            <span class="typename">string</span></span><br><span class="line">    AgentVersion  <span class="typename">string</span></span><br><span class="line">    PluginVersion <span class="typename">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cron/reporter.go</span></span><br><span class="line">    <span class="comment">// 上报信息</span></span><br><span class="line">    req := model.AgentReportRequest&#123;</span><br><span class="line">        Hostname:      hostname,</span><br><span class="line">        IP:            g.IP(),</span><br><span class="line">        AgentVersion:  g.VERSION,</span><br><span class="line">        PluginVersion: g.GetCurrPluginVersion(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC请求返回值</span></span><br><span class="line">    <span class="keyword">var</span> resp model.SimpleRpcResponse</span><br><span class="line">    <span class="comment">// RPC方式请求上报agent信息</span></span><br><span class="line">    <span class="comment">// g.HbsClient 为之前g.InitRpcClient()中初始化变量，var HbsClient *SingleConnRpcClient</span></span><br><span class="line">    <span class="comment">// Call()为结构体SingleConnRpcClient方法</span></span><br><span class="line">    <span class="comment">// func (this *SingleConnRpcClient) Call(method string, args interface&#123;&#125;, reply interface&#123;&#125;) error &#123;...&#125;</span></span><br><span class="line">    err = g.HbsClient.Call(<span class="string">"Agent.ReportStatus"</span>, req, &amp;resp)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> || resp.Code != <span class="number">0</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"call Agent.ReportStatus fail:"</span>, err, <span class="string">"Request:"</span>, req, <span class="string">"Response:"</span>, resp)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="cron-SyncMinePlugins"><a href="#cron-SyncMinePlugins" class="headerlink" title="cron.SyncMinePlugins()"></a><strong>cron.SyncMinePlugins()</strong></h4><p>每隔<code>Heartbeat.Interval</code>秒以RPC方式向HBS请求并同步plugin信息，执行删除无用plugin，添加新plugin等同步操作。所有plugin信息都存储在packae级变量<code>Plugins</code>(<code>map[string]*Plugin</code>)中</p>
<p>请求体为<code>model.AgentHeartbeatRequest</code>结构体，响应体为<code>model.AgentPluginsResponse</code>结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open-falcon/falcon-plus/common/model/agent.go</span></span><br><span class="line"><span class="comment">// 请求体数据结构</span></span><br><span class="line"><span class="keyword">type</span> AgentHeartbeatRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Hostname <span class="typename">string</span>	<span class="comment">// agent主机名</span></span><br><span class="line">    Checksum <span class="typename">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应体数据结构</span></span><br><span class="line"><span class="keyword">type</span> AgentPluginsResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Plugins   []<span class="typename">string</span></span><br><span class="line">    Timestamp <span class="typename">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个Plugin数据结构</span></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">    FilePath <span class="typename">string</span></span><br><span class="line">    MTime    <span class="typename">int64</span></span><br><span class="line">    Cycle    <span class="typename">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cron-SyncBuiltinMetrics"><a href="#cron-SyncBuiltinMetrics" class="headerlink" title="cron.SyncBuiltinMetrics()"></a><strong>cron.SyncBuiltinMetrics()</strong></h4><p>每隔<code>Heartbeat.Interval</code>秒以RPC方式<code>g.HbsClient.Call(&quot;Agent.BuiltinMetrics&quot;, req, &amp;resp)</code>周期性从HBS同步监控端口、URL、进程及du路径信息到agent</p>
<h4 id="cron-SyncTrustableIps"><a href="#cron-SyncTrustableIps" class="headerlink" title="cron.SyncTrustableIps()"></a><strong>cron.SyncTrustableIps()</strong></h4><p>每隔<code>Heartbeat.Interval</code>秒以RPC方式<code>g.HbsClient.Call(&quot;Agent.TrustableIps&quot;, model.NullRpcRequest{}, &amp;ips)</code>周期性从HBS同步信任IP列表到agent</p>
<h4 id="cron-Collect"><a href="#cron-Collect" class="headerlink" title="cron.Collect()"></a><strong>cron.Collect()</strong></h4><p>每隔<code>Transfer.Interval</code>秒间隔执行由<code>funcs.BuildMappers()</code>构建<code>Mappers</code>变量中的所有采集函数<code>Fs</code>，先获得监控项目的值，并为每个监控项数据(<code>MetricValue</code>)加上<code>Step</code>、<code>Endpoint</code>(<code>hostname</code>)和<code>Timestamp</code>(<code>time.Now().Unix()</code>)。最后调用<code>g.SendToTransfer()</code>将所有监控数据上传到Transfer</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> Collect() &#123;</span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> funcs.Mappers &#123;</span><br><span class="line">        <span class="keyword">go</span> collect(<span class="typename">int64</span>(v.Interval), v.Fs)		<span class="comment">// 创建一个goroutine执行指标采集函数(`funcs.BuildMappers()`)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> collect(sec <span class="typename">int64</span>, fns []<span class="keyword">func</span>() []*model.MetricValue) &#123;</span><br><span class="line">    t := time.NewTicker(time.Second * time.Duration(sec))	<span class="comment">// 每隔sec秒(v.Interval)执行采集函数并上报transfer</span></span><br><span class="line">    <span class="keyword">defer</span> t.Stop()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        &lt;-t.C</span><br><span class="line"></span><br><span class="line">        hostname, err := g.Hostname()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mvs := []*model.MetricValue&#123;&#125;	<span class="comment">// 最终存储metric指标的slice</span></span><br><span class="line">        ignoreMetrics := g.Config().IgnoreMetrics</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, fn := <span class="keyword">range</span> fns &#123;	<span class="comment">// 迭代所有采集函数，汇总所有指标到mvs</span></span><br><span class="line">            items := fn()	<span class="comment">// 执行指标采集函数，获得指标</span></span><br><span class="line">            <span class="keyword">if</span> items == <span class="constant">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(items) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _, mv := <span class="keyword">range</span> items &#123;	<span class="comment">//检测指标，若没被忽略，则汇总到mvs中</span></span><br><span class="line">                <span class="keyword">if</span> b, ok := ignoreMetrics[mv.Metric]; ok &amp;&amp; b &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mvs = <span class="built_in">append</span>(mvs, mv)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        now := time.Now().Unix()</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(mvs); j++ &#123;		<span class="comment">// 为每个metric设置Step、Endpoint和Timestamp</span></span><br><span class="line">            mvs[j].Step = sec</span><br><span class="line">            mvs[j].Endpoint = hostname</span><br><span class="line">            mvs[j].Timestamp = now</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.SendToTransfer(mvs)	<span class="comment">// 将所有指标上报到Transfer</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="API-amp-Dashboard"><a href="#API-amp-Dashboard" class="headerlink" title="API &amp; Dashboard"></a><strong>API &amp; Dashboard</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> http.Start()</span><br></pre></td></tr></table></figure>
<p>监听端口、启动API服务和Dashboard服务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http/http.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载路由函数</span></span><br><span class="line"><span class="keyword">func</span> init() &#123;</span><br><span class="line">    configAdminRoutes()</span><br><span class="line">    configCpuRoutes()</span><br><span class="line">    configDfRoutes()</span><br><span class="line">    configHealthRoutes()</span><br><span class="line">    configIoStatRoutes()</span><br><span class="line">    configKernelRoutes()</span><br><span class="line">    configMemoryRoutes()</span><br><span class="line">    configPageRoutes()</span><br><span class="line">    configPluginRoutes()</span><br><span class="line">    configPushRoutes()</span><br><span class="line">    configRunRoutes()</span><br><span class="line">    configSystemRoutes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Start() &#123;</span><br><span class="line">    <span class="keyword">if</span> !g.Config().Http.Enabled &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr := g.Config().Http.Listen</span><br><span class="line">    <span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s := &amp;http.Server&#123;	<span class="comment">// 设置监听端口</span></span><br><span class="line">        Addr:           addr,</span><br><span class="line">        MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">30</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">"listening"</span>, addr)</span><br><span class="line">    log.Fatalln(s.ListenAndServe())		<span class="comment">// 启动http服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Agent源码目录结构"><a href="#Agent源码目录结构" class="headerlink" title="Agent源码目录结构"></a><strong>Agent源码目录结构</strong></h2><figure class="highl]]>
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Open-Falcon源码阅读-概述]]></title>
    <link href="http://yoursite.com/2019/05/23/Open-Falcon/"/>
    <id>http://yoursite.com/2019/05/23/Open-Falcon/</id>
    <published>2019-05-23T11:54:39.000Z</published>
    <updated>2019-06-28T07:03:27.612Z</updated>
    <content type="html"><![CDATA[<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong>架构</strong></h2><p><img src="http://book.open-falcon.org/zh_0_2/image/func_intro_1.png" alt="Open-Falcon 官方架构图"></p>
<h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a><strong>核心组件</strong></h3><ul>
<li><strong>falcon-agent</strong>: 采集客户端，采集数据上报到Transfer</li>
<li><strong>HBS(heartbeat server)</strong>: 接收falcon-agent心跳请求，管理agent信息(新增/删除)、缓存分组/策略信息以提供给Judge/Agent查询同步</li>
<li><strong>Transfer</strong>: 接收falcon-agent上报的数据，转发至Judge、Graph或OpenTSDB，Transfer自身是无状态的</li>
<li><strong>Graph</strong>: 将从Transfer接收的数据存入RRD数据库，并提供查询接口</li>
<li><strong>Judge</strong>: 告警条件触发判断，接收Transfer数据，请求HBS同步策略列表</li>
<li><strong>Alarm</strong>: 从redis中获取告警事件，合并后发送告警</li>
<li><strong>Portal</strong>:  告警策略配置Web界面</li>
<li><strong>Dashboard</strong>: 图表Web界面</li>
<li><strong>Aggregator</strong>: 集群数据聚合，提供集群下所有机器单指标值</li>
<li><strong>API</strong>: 提供接口从Graph中查询数据</li>
</ul>
<h3 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a><strong>源码目录结构</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmd		// open-falcon命令操作</span><br><span class="line">├── common	// 常用工具集合</span><br><span class="line">│   ├── backend_pool</span><br><span class="line">│   ├── db</span><br><span class="line">│   ├── model</span><br><span class="line">│   ├── proc</span><br><span class="line">│   ├── sdk</span><br><span class="line">│   └── utils</span><br><span class="line">├── config</span><br><span class="line">├── docker</span><br><span class="line">├── docs</span><br><span class="line">│   ├── doc</span><br><span class="line">│   ├── _includes</span><br><span class="line">│   ├── _layouts</span><br><span class="line">│   └── _posts</span><br><span class="line">├── g	// 定义配置文件路径、日志路径等信息</span><br><span class="line">├── logos</span><br><span class="line">├── modules		// 各核心组件</span><br><span class="line">│   ├── agent</span><br><span class="line">│   ├── aggregator</span><br><span class="line">│   ├── alarm</span><br><span class="line">│   ├── alarm-manager</span><br><span class="line">│   ├── api</span><br><span class="line">│   ├── gateway</span><br><span class="line">│   ├── graph</span><br><span class="line">│   ├── hbs</span><br><span class="line">│   ├── judge</span><br><span class="line">│   ├── nodata</span><br><span class="line">│   └── transfer</span><br><span class="line">├── scripts		// sql脚本</span><br><span class="line">│   └── mysql</span><br><span class="line">├── <span class="built_in">test</span></span><br><span class="line">├── vagrant</span><br><span class="line">└── vendor</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong>架构</strong></h2><p><img src="http://book.open-falcon.org/zh_0_2/image/fu]]>
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go语言圣经笔记-下]]></title>
    <link href="http://yoursite.com/2019/05/15/golang-bible-1/"/>
    <id>http://yoursite.com/2019/05/15/golang-bible-1/</id>
    <published>2019-05-15T08:18:33.000Z</published>
    <updated>2019-08-26T16:22:38.370Z</updated>
    <content type="html"><![CDATA[<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a><strong>Function</strong></h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a><strong>函数声明</strong></h3><p>函数声明包含：</p>
<ul>
<li><p><strong>函数名</strong></p>
</li>
<li><p><strong>形参列表(变量名+类型)</strong></p>
<p>  无默认参数值</p>
<p>  函数最外层局部变量</p>
<p>  调用函数<strong>必须</strong>按照<strong>声明顺序</strong>为所有形参提供实参</p>
<p>  实参通过<strong>值方式传递</strong>，<strong>形参是实参的值拷贝</strong>。若实参是<strong>引用类型(pointer/slice/map/function/channel)</strong>，即便形参是值拷贝，也可以修改实参</p>
</li>
<li><p><strong>返回值列表(可省略)</strong></p>
<p>  函数最外层局部变量</p>
<p>  多个返回值在<code>()</code>内，只返回一个无名变量<code>()</code>可省略。每个返回值被声明为一个局部变量，并被初始化为对应类型零值</p>
<p>  若有返回值列表，函数则必须以<code>return</code>语句结尾</p>
<p>  Go支持函数多返回值，若函数返回值列表都显示命名变量，则<code>return</code>语句可省略操作数(<code>bare return</code>)</p>
</li>
<li><p><strong>函数体</strong></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> hypot(x, y <span class="typename">float64</span>) <span class="typename">float64</span> &#123;	<span class="comment">// hypot 函数名；x, y float64 形参列表；float64 返回值列表的无名变量类型</span></span><br><span class="line"><span class="comment">// func hypot(x float64, y float64) float64 &#123;</span></span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(x*x + y*y)			<span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(hypot(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">// "5"</span></span><br></pre></td></tr></table></figure>
<p>判断两个函数是否为相同函数类型：</p>
<ol>
<li>函数<strong>形参列表</strong>的<strong>变量类型</strong>(变量名不影响)一一对应</li>
<li>函数<strong>返回值列表</strong>的<strong>变量类型</strong>(变量名不影响)一一对应</li>
</ol>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h3><p>Go允许函数递归，递归实现Fibonacci数列</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> Fibonacci(n <span class="typename">int</span>) <span class="typename">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n-<span class="number">2</span>) + Fibonacci(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d  "</span>, Fibonacci(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a><strong>函数值</strong></h3><p>Go中函数为<strong>第一类值(first-class values)</strong>，即函数和其他类型一样，拥有类型(函数类型)，可被赋值给变量，可传递给函数做实参，可做函数的返回值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> square(n <span class="typename">int</span>) <span class="typename">int</span> &#123; <span class="keyword">return</span> n * n &#125;</span><br><span class="line">f := square		<span class="comment">// function value 函数值</span></span><br><span class="line">fmt.Println(f(<span class="number">3</span>))	<span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>函数类型的零值为<code>nil</code>。调用值为<code>nil</code>的函数值会panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">int</span>		<span class="comment">// f为函数类型变量，值为nil		// 函数类型变量声明</span></span><br><span class="line">f(<span class="number">3</span>)					<span class="comment">// panic !!!</span></span><br></pre></td></tr></table></figure>
<p><strong>函数值之间不能进行比较</strong>，故函数值无法作为map的key。函数值可与<code>nil</code>比较</p>
<p>关于函数类型的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Calculate <span class="keyword">func</span>(<span class="typename">int</span>, <span class="typename">int</span>)		<span class="comment">// 声明函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (c *Calculate) Echo() &#123;		<span class="comment">// 函数类型实现Echo()方法</span></span><br><span class="line">    fmt.Println(<span class="string">"function type"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> add(a, b <span class="typename">int</span>) &#123;		<span class="comment">// 普通函数</span></span><br><span class="line">    fmt.Println(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> mul(a, b <span class="typename">int</span>) &#123;		<span class="comment">// 普通函数</span></span><br><span class="line">    fmt.Println(a * b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    x := Calculate(add)		<span class="comment">// 将add函数强制转换为Calculate函数类型，能转换的前提是他们的底层类似都是相同类型的函数(形参类型、返回值类型相同)</span></span><br><span class="line">    y := Calculate(mul)		<span class="comment">// 将mul函数强制转换为Calculate函数类型</span></span><br><span class="line"></span><br><span class="line">    x(<span class="number">1</span>, <span class="number">1</span>)					<span class="comment">// 保持原有的函数的功能</span></span><br><span class="line">    y(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    x.Echo()				<span class="comment">// 新增Calculate类型的功能</span></span><br><span class="line">    y.Echo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于函数值做形参列子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CalculateOps <span class="keyword">func</span>(<span class="typename">int</span>, <span class="typename">int</span>) <span class="typename">int</span>		<span class="comment">// 声明函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Add(a, b <span class="typename">int</span>) <span class="typename">int</span> &#123;		<span class="comment">// 普通函数</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Mul(a, b <span class="typename">int</span>) <span class="typename">int</span> &#123;		<span class="comment">// 普通函数</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Calculate(a, b <span class="typename">int</span>, f CalculateOps) <span class="typename">int</span> &#123;		<span class="comment">// 函数类型形参	// Add、Mul和CalculateOps为同一类型函数(形参和返回值类型都相同)</span></span><br><span class="line">    <span class="keyword">return</span> f(a, b)				<span class="comment">// 执行传入函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    fmt.Println(Calculate(<span class="number">1</span>, <span class="number">1</span>, Add))</span><br><span class="line">    fmt.Println(Calculate(<span class="number">2</span>, <span class="number">2</span>, Mul))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><strong>匿名函数</strong></h4><p>普通命名函数<strong>只能</strong>在包级别进行声明，匿名函数(anonymous function)可在函数内进行，并且可访问函数的完整词法域</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (形参列表) [返回值列表] &#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<p>匿名函数实现<strong>闭包(closures)</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> squares() <span class="keyword">func</span>() <span class="typename">int</span> &#123;		<span class="comment">// 函数squares返回一个匿名函数</span></span><br><span class="line">    <span class="keyword">var</span> x <span class="typename">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">func</span>() <span class="typename">int</span> &#123;		<span class="comment">// 匿名函数</span></span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    f := squares()	<span class="comment">// f 为函数值	// squares函数返回后，变量x仍隐式存在与f</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "1"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "4"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "9"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "16"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="迭代变量陷阱"><a href="#迭代变量陷阱" class="headerlink" title="迭代变量陷阱"></a><strong>迭代变量陷阱</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="keyword">var</span> printDirs []<span class="keyword">func</span>()		<span class="comment">// 匿名函数slice</span></span><br><span class="line">    dirs := []<span class="typename">string</span>&#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">        <span class="comment">//d := d	// solution</span></span><br><span class="line">        printDirs = <span class="built_in">append</span>(printDirs, <span class="keyword">func</span>() &#123;	<span class="comment">// 匿名函数</span></span><br><span class="line">            fmt.Printf(<span class="string">"%s "</span>, d)	<span class="comment">// wrong</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, dir := <span class="keyword">range</span> printDirs &#123;</span><br><span class="line">        dir()		<span class="comment">// five five five five five</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del><code>for…range</code>引入新的词法域，变量<code>d</code>在该词法域中被声明，匿名函数中记录的是变量<code>d</code>的内存地址而非某次循环的值</del></p>
<p><del>闭包函数记录的是闭包变量的内存地址，闭包变量的值仅在闭包函数执行时确定</del><br><code>for...range</code>引入新的词法域，变量<code>d</code>在该词法域中被声明，并<strong>只会被初始化一次(多次迭代d只会有一个内存地址)</strong>，而并非每次迭代都分配新地址，产生一个新的变量<code>d</code>。所以最后<code>printDirs</code>中的<code>d</code>都指向同一个内存地址，最后打印出来的就都是<code>d</code>最后迭代值。<br>解决办法<code>d := d</code>，是重新声明一个变量<code>d</code>，重新分配内存给新变量<code>d</code>，接下来的词法域中新变量<code>d</code>覆盖迭代<code>d</code>，<code>printDirs</code>中5个匿名函数里的<code>d</code>都是指向5个不同的内存地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> echo []<span class="keyword">func</span>()</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">print</span> []<span class="typename">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="built_in">print</span> = <span class="built_in">append</span>(<span class="built_in">print</span>, i)	<span class="comment">// ok</span></span><br><span class="line">    echo = <span class="built_in">append</span>(echo, <span class="keyword">func</span>() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>, i)	<span class="comment">// wrong</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> <span class="built_in">print</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d: "</span>, p)		<span class="comment">// 0: 1: 2: 3: 4:</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> echo &#123;</span><br><span class="line">    e()							<span class="comment">// 5 5 5 5 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><strong>可变参数</strong></h4><p>在声明可变参数函数时，在形参列表<strong>最后一个参数类型</strong>前加上<code>…</code>，表示该参数可接收任意数量该类型的实参。</p>
<p>对于传入的多个实参，Go先创建一个array，并将多个实参复制到array中，在把array的一个slice作为实参传入，所以函数接收到的是<code>[]T</code>类型的slice。若以slice作为多个实参传入，则传入参数写成<code>slice…</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> sum(vals ...<span class="typename">int</span>) <span class="typename">int</span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> vals &#123;	<span class="comment">// vals == []int&#123;1, 2, 3&#125;</span></span><br><span class="line">        total += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    fmt.Println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))	<span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">	values := []<span class="typename">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(sum(values...))	<span class="comment">// 6	// 以slice作为可变参数传入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Deferred函数"><a href="#Deferred函数" class="headerlink" title="Deferred函数"></a><strong>Deferred函数</strong></h4><p>Go使用<strong><code>defer</code></strong>语句来延迟执行函数，延迟发生在defer所在函数执行完毕时，不管是<code>return</code>正常结束还是<code>panic</code>异常结束。(defer在return/panic前执行)</p>
<p><code>defer</code>后接的<strong>必须是函数调用</strong>(即必须要有<code>()</code>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG</span></span><br><span class="line"><span class="keyword">defer</span> <span class="keyword">func</span>() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RIGHT</span></span><br><span class="line"><span class="keyword">defer</span> <span class="keyword">func</span>() &#123;...&#125;()	<span class="comment">// 必须有()</span></span><br></pre></td></tr></table></figure>
<p>使用<code>defer</code>需要注意的点：</p>
<ol>
<li><p><strong>defer执行顺序为先进后出</strong></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> defer_call() &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() &#123; fmt.Println(<span class="string">"defer1"</span>) &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() &#123; fmt.Println(<span class="string">"defer2"</span>) &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() &#123; fmt.Println(<span class="string">"defer3"</span>) &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    defer_call()</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    defer3</span><br><span class="line">    defer2</span><br><span class="line">    defer1</span><br><span class="line">    panic: panic</span><br><span class="line">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>defer函数的参数在被defer声明时就已经确定</strong></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> calc(index <span class="typename">string</span>, a, b <span class="typename">int</span>) <span class="typename">int</span> &#123;</span><br><span class="line">    ret := a + b</span><br><span class="line">    fmt.Println(index, a, b, ret)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    b := <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> calc(<span class="string">"1"</span>, a, calc(<span class="string">"10"</span>, a, b))</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> calc(<span class="string">"2"</span>, a, calc(<span class="string">"20"</span>, a, b))</span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">        10 1 2 3</span><br><span class="line">        20 0 2 2</span><br><span class="line">        2 0 2 2</span><br><span class="line">        1 1 3 4</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p> 执行分析：</p>
<ol>
<li>程序执行到<code>defer calc(&quot;1&quot;, a, calc(&quot;10&quot;, a, b))</code>时，由于defer函数的参数在声明时就要确定，所以需要先计算出外层<code>calc()</code>的<code>b</code>值，于是执行<code>calc(“10”, a, b)</code>，<code>calc(“10”, 1, 2)</code>输出<code>10 1 2 3</code>，返回<code>3</code></li>
<li>第一个defer函数参数确定为<code>defer calc(“1”, 1, 3)</code></li>
<li>程序执行到<code>defer calc(&quot;2&quot;, a, calc(&quot;20&quot;, a, b))</code>时，此时变量<code>a</code>被改成<code>0</code>(<code>a=0</code>)，再次由于defer函数的参数在声明时需要确定，所以需要先计算外层<code>calc()</code>的<code>b</code>值，于是执行<code>calc(“20”, a, b)</code>，<code>calc(“20”, 0, 2)</code>输出<code>20 0 2 2</code>，返回<code>2</code></li>
<li>第二个defer函数参数确定为<code>defer calc(“2”, 0, 2)</code></li>
<li><code>b=1</code>，由于第二个defer函数参数已经确定，确定后既是修改变量<code>b</code>的值也不影响第二个defer函数的参数</li>
<li>按照defer先进后出规则，先执行第二个defer<code>defer calc(“2”, 0, 2)</code>输出<code>2 0 2 2</code></li>
<li>执行第一个defer<code>defer calc(“1”, 1, 3)</code>输出<code>1 1 3 4</code></li>
</ol>
</li>
<li><p><strong>defer可读改有名返回值</strong></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> doubleScore(source <span class="typename">float32</span>) (score <span class="typename">float32</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">1</span> || score &gt;= <span class="number">100</span> &#123;</span><br><span class="line">            <span class="comment">//将影响返回值</span></span><br><span class="line">            score = source</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    score = source * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//return source * 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    fmt.Println(doubleScore(<span class="number">0</span>))    <span class="comment">//0</span></span><br><span class="line">    fmt.Println(doubleScore(<span class="number">20.0</span>)) <span class="comment">//40</span></span><br><span class="line">    fmt.Println(doubleScore(<span class="number">50.0</span>)) <span class="comment">//50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> c() (i <span class="typename">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    fmt.Println(c())	<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> DeferFunc1(i <span class="typename">int</span>) (t <span class="typename">int</span>) &#123;</span><br><span class="line">    t = i</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        t += <span class="number">3</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> DeferFunc2(i <span class="typename">int</span>) <span class="typename">int</span> &#123;</span><br><span class="line">    t := i</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        t += <span class="number">3</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> DeferFunc3(i <span class="typename">int</span>) (t <span class="typename">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        t += i</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> DeferFunc4(i <span class="typename">int</span>) <span class="typename">int</span> &#123;</span><br><span class="line">    t := i</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>(t <span class="typename">int</span>) &#123;</span><br><span class="line">        t += <span class="number">3</span></span><br><span class="line">    &#125;(t)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="built_in">println</span>(DeferFunc1(<span class="number">1</span>))		<span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">println</span>(DeferFunc2(<span class="number">1</span>))		<span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">println</span>(DeferFunc3(<span class="number">1</span>))		<span class="comment">// 3</span></span><br><span class="line">    fmt.Println(DeferFunc4(<span class="number">1</span>))	<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="panic-amp-recover"><a href="#panic-amp-recover" class="headerlink" title="panic &amp; recover"></a><strong>panic &amp; recover</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> badCall() &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"bad end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> test() &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="constant">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"recover %s\r\n"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    badCall()</span><br><span class="line">    fmt.Printf(<span class="string">"After bad call\r\n"</span>) <span class="comment">// 不会执行，即使已经recover()，但panic()后直接return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"calling test\r\n"</span>)</span><br><span class="line">    test()</span><br><span class="line">    fmt.Printf(<span class="string">"recover completed\r\n"</span>)		<span class="comment">// 若无recover(), 此句不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a><strong>Method</strong></h2><p><strong>对象</strong>简单为一个值或变量，此对象包含<strong>方法</strong>，方法是和特殊类型关联的<strong>函数</strong>。</p>
<p>面向对象程序是通过<strong>方法</strong>来表达其<strong>属性</strong>和对应的<strong>操作</strong>，如此使用对象时，不需要直接操作对象而是借助方法完成操作</p>
<h3 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a><strong>方法声明</strong></h3><p>在函数声明时，在函数名前加上一个变量，即方法的声明。此变量称之为<strong>receiver(接收器)</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="typename">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">func</span> Distance(p, q Point) <span class="typename">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X - p.X, q.Y - p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line"><span class="keyword">func</span> (p Point) Distance(q Point) <span class="typename">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X - p.X, q.Y - p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">Distance(p, q)		<span class="comment">// 函数调用</span></span><br><span class="line">p.Distance(q)		<span class="comment">// 方法调用</span></span><br></pre></td></tr></table></figure>
<p>方法和struct成名变量都在同一个命名空间中，所以方法名和成员名不能相同，若在声明一个<code>X</code>方法，则会和成员变量<code>X</code>冲突</p>
<p>Go中除了底层类型为<strong>pointer</strong>和<strong>interface</strong>的命名类型外，其余的所有命名类型都可定义方法(数值/字符串/slice/map……)</p>
<h3 id="指针对象的方法"><a href="#指针对象的方法" class="headerlink" title="指针对象的方法"></a><strong>指针对象的方法</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (p *Point) ScaleBy(factor <span class="typename">float64</span>) &#123;</span><br><span class="line">    p.X *= factor</span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针对象的方法，即方法的receiver(接收器)为指针对象。上面方法的方法名为<strong><code>(*Point).ScaleBy</code></strong></p>
<p>只有<strong>类型(T)</strong>和<strong>指向类型的指针(*T)</strong>才能作为receiver(接收器)，若类型名本身是指针无法作为receiver(接收器)。正如上面所讲，底层类型为指针的命名类型不可定义方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> P *<span class="typename">int</span></span><br><span class="line"><span class="keyword">func</span> (P) f() &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// compile error: invalid receiver type</span></span><br></pre></td></tr></table></figure>
<p>如何调用指针对象的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="typename">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (p *Point) ScaleBy(factor <span class="typename">float64</span>) &#123;</span><br><span class="line">    p.X *= factor</span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">r.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(*r) <span class="comment">// "&#123;2, 4&#125;"</span></span><br></pre></td></tr></table></figure>
<p>不管方法的receiver是<code>T</code>还是<code>*T</code>类型，都可通过<code>T</code>和<code>*T</code>类型对象调用，编译器会自动识别。但个人最好明白是编译器帮忙做了转换</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (stu *Student) Speak() &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    s := &amp;Student&#123;&#125;		<span class="comment">// *T</span></span><br><span class="line">    ss := Student&#123;&#125;		<span class="comment">// T	// 虽然T编译器会自动转换成*T，但需明白&amp;Student&#123;&#125;才是最正确的用法</span></span><br><span class="line">    s.Speak()</span><br><span class="line">    ss.Speak()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套扩展方法"><a href="#嵌套扩展方法" class="headerlink" title="嵌套扩展方法"></a><strong>嵌套扩展方法</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="typename">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (p *Point) ScaleBy(factor <span class="typename">float64</span>) &#123;</span><br><span class="line">    p.X *= factor</span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cp ColoredPoint</span><br><span class="line">red := color.RGBA&#123;<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>&#125;</span><br><span class="line">cp = ColoredPoint&#123;Color: red&#125;</span><br><span class="line">cp.X = <span class="number">1</span> 	<span class="comment">// struct匿名嵌套，struct章节内容</span></span><br><span class="line">cp.Y = <span class="number">2</span></span><br><span class="line">fmt.Println(cp)</span><br><span class="line">cp.ScaleBy(<span class="number">2</span>) 	<span class="comment">// ColoredPoint类型对象可执行调用Point类型对象的ScaleBy方法</span></span><br><span class="line">fmt.Println(cp.X, cp.Y)</span><br></pre></td></tr></table></figure>
<p>Point类的方法也被引入了ColoredPoint，但一个ColoredPoint并不是一个Point，而是ColoredPoint has Point</p>
<h3 id="方法值和方法表达式"><a href="#方法值和方法表达式" class="headerlink" title="方法值和方法表达式"></a><strong>方法值和方法表达式</strong></h3><p>方法值和函数值类似，一般使用方法常规为<code>object.method()</code>，<code>object.method</code>称为<strong>选择器</strong>(没有<code>()</code>)，选择器返回一个方法值，即将方法绑定到特定接收器变量的函数，直接通过该函数接收参数调用方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cp ColoredPoint</span><br><span class="line">cp = ColoredPoint&#123;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, red&#125;</span><br><span class="line">methodValue = cp.ScaleBy		<span class="comment">// 方法值</span></span><br><span class="line">fmt.Println(methodValue(<span class="number">2</span>))		<span class="comment">// 通过方法值调用方法</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rocket <span class="keyword">struct</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">func</span> (r *Rocket) Launch() &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">r := <span class="built_in">new</span>(Rocket)</span><br><span class="line"><span class="comment">// time.AfterFunc(timeout, function) 	需要接收函数</span></span><br><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, <span class="keyword">func</span>() &#123; r.Launch() &#125;)		<span class="comment">// 因为参数需要是函数，所以要构造出一个匿名函数</span></span><br><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, r.Launch)					<span class="comment">// 使用方法值即可省略匿名函数</span></span><br></pre></td></tr></table></figure>
<p>方法表达式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distance := Point.Distance   <span class="comment">// 方法表达式，不需要通过对象实例，但在真正调用方法时需要传入receiver</span></span><br><span class="line">fmt.Println(distance(p, q))  <span class="comment">// "5"		// 需要传入p对象实例作为receiver</span></span><br></pre></td></tr></table></figure>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a><strong>Interface</strong></h2><h3 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a><strong>接口声明</strong></h3><p>接口是方法的集合，只要实现了接口内所有的方法就实现了接口，即当一个具体类型实现了接口内要求的所有方法，则该类型就是该接口的实例</p>
<p>接口支持内嵌</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;		<span class="comment">// 接口声明</span></span><br><span class="line">    Read(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)	<span class="comment">// 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader		<span class="comment">// 接口内嵌</span></span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a><strong>实现接口的条件</strong></h3><h4 id="指针对象方法接口实现"><a href="#指针对象方法接口实现" class="headerlink" title="指针对象方法接口实现"></a><strong>指针对象方法接口实现</strong></h4><p>对于指针对象的方法，需要特别注意一点：指针类型的receiver，只有指针类型对象实现该method</p>
<table>
<thead>
<tr>
<th style="text-align:center">values</th>
<th style="text-align:center">method receiver</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">(t T)</td>
</tr>
<tr>
<td style="text-align:center">*T</td>
<td style="text-align:center">(t T) and (t *T)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">method receiver</th>
<th style="text-align:center">values</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(t T)</td>
<td style="text-align:center">T and *T</td>
</tr>
<tr>
<td style="text-align:center">(t *T)</td>
<td style="text-align:center">*T</td>
</tr>
</tbody>
</table>
<p>在<a href="###指针对象的方法">指针对象的方法</a>中，无论是<code>T</code>还是<code>*T</code>类型都可调用<code>T</code>和<code>*T</code>方法，即<code>T</code>类型也能调用<code>*T</code>方法。但接口实现中，<code>*T</code>方法只有<code>*T</code>类型实现了，<code>T</code>类型并无实现<code>*T</code>方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论是`T`还是`*T`类型都可调用`T`和`*T`方法</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (stu *Student) Speak() &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    s := &amp;Student&#123;&#125;		<span class="comment">// *T</span></span><br><span class="line">    ss := Student&#123;&#125;		<span class="comment">// T	// 虽然T编译器会自动转换成*T，但需明白&amp;Student&#123;&#125;才是最正确的用法</span></span><br><span class="line">    s.Speak()</span><br><span class="line">    ss.Speak()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">    Speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (stu *Student) Speak() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="keyword">var</span> peo People = Student&#123;&#125;		<span class="comment">// WRONG	// T类型Student&#123;&#125;并没有实现(stu *Student) Spea()方法，故也无实现People接口</span></span><br><span class="line">    <span class="comment">// var peo People = &amp;Student&#123;&#125;	// RIGHT</span></span><br><span class="line">    peo.Speak()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口断言"><a href="#接口断言" class="headerlink" title="接口断言"></a><strong>接口断言</strong></h4><p>由于接口的实现采用隐式实现，即只要实现了接口内所有方法，就实现了接口。当要判断一个类型是否实现接口时，可通过如下方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*bytes.Buffer)(<span class="constant">nil</span>)	<span class="comment">// nil转换为*bytes.Buffer类型，并尝试赋值操作(空标识符，类型为io.Writer)。无编译报错，则*bytes.Buffer实现了io.Writer接口</span></span><br></pre></td></tr></table></figure>
<h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a><strong>接口值</strong></h4><p>接口本质上是由2部分组成：</p>
<ol>
<li>指向值类型的指针</li>
<li>指向值内容的指针</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InterfaceStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    pointType  <span class="typename">uintptr</span> <span class="comment">// 指向值类型的指针</span></span><br><span class="line">    pointValue <span class="typename">uintptr</span> <span class="comment">// 指向值内容的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口值是可进行比较的，但当接口的<code>pointType</code>类型是不可比较类型(<code>slice</code>/<code>map</code>)则无法进行比较操作。这里尤其注意<strong>接口和<code>nil</code>的比较</strong></p>
<p><strong>判断接口是否等于<code>nil</code>，需要接口的<code>pointType</code> 和 <code>pointValue</code>都为<code>nil</code>时才等于<code>nil</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">    Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (stu *Student) Show() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> live() People &#123; <span class="comment">// BBBBBBB</span></span><br><span class="line">    <span class="keyword">var</span> stu *Student</span><br><span class="line">    <span class="keyword">return</span> stu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="keyword">if</span> live() == <span class="constant">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"nil"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"not nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// not nil</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    虽然live()返回People的value为nil，但People的type为*Student，不为nil。所以People接口类型变量不等于nil</span><br><span class="line">    只有当type和value都为nil时，接口才等于nil</span><br><span class="line">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a><strong>类型断言</strong></h4><p>类型断言语法：<strong><code>x.(T)</code></strong> (<strong><code>x</code>必须为接口类型且不为<code>nil</code></strong>)</p>
<p>类型断言主要分2种情况：</p>
<ul>
<li><p><code>T</code>为具体类型，<code>x.(T)</code>检查<code>x</code>的类型是否和<code>T</code>类型相同</p>
<p>  判断成功后会返回<code>x</code>的pointValue</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i, ok := <span class="keyword">interface</span>&#123;&#125;(w).(<span class="typename">int</span>); ok &#123;	<span class="comment">//由于x.(T)中x必须为接口类型，所以需将i进行类型转换interface&#123;&#125;(i)</span></span><br><span class="line">    fmt.Println(<span class="string">"ok"</span>, i)		<span class="comment">// ok 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>T</code>为接口类型，<code>x.(T)</code>检查<code>x</code>的类型是否实现<code>T</code>接口</p>
<p>  判断成功后，<code>x</code>的pointType和pointValue都不变，但<code>x</code>的类型被转换为<code>T</code>类型</p>
</li>
</ul>
<h4 id="type-switch"><a href="#type-switch" class="headerlink" title="type switch"></a><strong>type switch</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">interface</span>&#123;&#125;(i).(<span class="keyword">type</span>) &#123;	<span class="comment">//由于x.(T)中x必须为接口类型，所以需将i进行类型转换interface&#123;&#125;(i)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="typename">int</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"int"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="typename">string</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"string"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"interface"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"unknown"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Goroutines-amp-Channels"><a href="#Goroutines-amp-Channels" class="headerlink" title="Goroutines &amp; Channels"></a><strong>Goroutines &amp; Channels</strong></h2><h3 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a><strong>Goroutines</strong></h3><p>Go语言中，每一个并发的执行单元叫作一个<strong>goroutine</strong>。程序启动时，<code>main()</code>函数即在一个goroutine中运行，此gouroutine称之为<strong>main goroutine</strong></p>
<p>创建一个gouroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> function()</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    fmt.Println(<span class="string">"main start"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() &#123;		<span class="comment">// 创建一个goroutine执行匿名函数</span></span><br><span class="line">        fmt.Println(<span class="string">"groutine"</span>)</span><br><span class="line">    &#125;()		<span class="comment">// 此处必须要有()，go 语句紧跟的是一个函数调用</span></span><br><span class="line">    fmt.Println(<span class="string">"main end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">main start</span><br><span class="line">main end</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>上面代码在<code>main()</code>函数中创建了一个goroutine来执行一个匿名函数，但输出的结果仅有<code>main start</code>和<code>main end</code>并没有新建goroutine的输出。因为新建完goroutine后，<code>main()</code>函数继续往下执行，执行完后main goroutine直接就结束了，由于main goroutine结束其所创建的goroutine也会被杀掉，导致新建的goroutine还没来得及输出就已经被结束了。改进方案就是需要用到<strong><code>channel</code></strong>、<strong><code>sync</code></strong>等来解决</p>
<ul>
<li><p><strong>channel方式</strong></p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        fmt.Println(<span class="string">"GO GO GO!!!"</span>)</span><br><span class="line">        c &lt;- <span class="constant">true</span></span><br><span class="line">        <span class="built_in">close</span>(c)	<span class="comment">// 必须close，否则for...range会出现死锁</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用for...range对channel进行不断读取，直到close channel</span></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sync方式</strong></p>
<p>  <code>sync.WaitGroup()</code>方式适用于知道具体数目goroutine的情况</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> add(wg *sync.WaitGroup, index <span class="typename">int</span>) &#123;</span><br><span class="line">    a := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        a += i</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(index, a)</span><br><span class="line">    wg.Done()	<span class="comment">// 通知wg.Wait()，goroutine已执行完</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    runtime.GOMAXPROCS(runtime.NumCPU())	<span class="comment">// 根据CPU核心数并发执行</span></span><br><span class="line"></span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">10</span>)	<span class="comment">// 10个goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&amp;wg 需要传递指针，需要在add()中进行Done()操作，不能值拷贝而需要地址拷贝</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> add(&amp;wg, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a><strong>Channels</strong></h3><h4 id="channel声明"><a href="#channel声明" class="headerlink" title="channel声明"></a><strong>channel声明</strong></h4><p><strong>channel</strong>是goroutine间的通讯机制，允许让一个goroutine向另一个goroutine发送消息，每个channel都必须规定其类型，表示该channel只允许传输该类型的消息，一般表示为<strong><code>chan T</code></strong>。使用内置的<code>make()</code>函数创建channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)	<span class="comment">// 创建一个int类型的channel</span></span><br></pre></td></tr></table></figure>
<p>channel为引用类型，零值为<code>nil</code>。两个相同类型的channel可比较<code>==</code>/<code>!=</code></p>
<p>channel主要操作有2个：</p>
<ul>
<li><strong>发送</strong>：<code>ch &lt;- xxx</code></li>
<li><strong>接收</strong>：<code>xxx = &lt;- ch</code>、<code>&lt;- ch</code></li>
</ul>
<p>关闭channel使用<code>close()</code>函数，<code>close(ch)</code>后，对channel进行发送操作会引发panic，接收操作仍可接收到之前已成功发送的数据。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收</p>
<h4 id="channel缓存"><a href="#channel缓存" class="headerlink" title="channel缓存"></a><strong>channel缓存</strong></h4><p>channel以是否能缓存分为2种</p>
<ul>
<li><p><strong>无缓存channel</strong></p>
<p>  无缓存channel将会<strong>阻塞</strong>goroutine对channel的操作。当一个goroutine对一个无缓存channel进行发送操作后，该goroutine会立马阻塞，直到有goroutine对该channel进行接收操作，接收操作完成后发送&amp;接收的goroutine才能继续执行后面语句。接收操作先发送也是如此。</p>
<p>  由于无缓存channel会导致goroutine的阻塞，发送和接收者相当于做了一次同步操作，所以无缓存channel也称为<strong>同步channel</strong></p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> T)	<span class="comment">// 创建无缓存channel</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>)		<span class="comment">// 创建无缓存channel</span></span><br><span class="line">    fmt.Println(<span class="string">"main start"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() &#123;			<span class="comment">// 新建goroutine执行匿名函数</span></span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"groutine"</span>)</span><br><span class="line">        c &lt;- <span class="string">"done"</span>		<span class="comment">// 发送数据到无缓存channel</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    &lt;-c		<span class="comment">// 从无缓存channel接收数据。一般情况下main goroutine执行较快，到此程序阻塞，等待其他goroutine执行发送操作</span></span><br><span class="line">    fmt.Println(<span class="string">"main end"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有缓存channel</strong></p>
<p>  有缓存channel内部持有一个缓存队列，向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素</p>
<p>  如果缓存队列已满，发送操作将会阻塞；如果缓存队列为空，接收操作将会阻塞</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> T, N)		<span class="comment">// 创建有缓存channel</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="comment">//c := make(chan string)</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>, <span class="number">1</span>)	<span class="comment">// 有缓存channel</span></span><br><span class="line">    fmt.Println(<span class="string">"main start"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"groutine"</span>)</span><br><span class="line">        &lt;-c</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    c &lt;- <span class="string">"done"</span>		<span class="comment">// 向有缓存channel发送数据，由于有1个缓存空间，所以一次发送操作不会阻塞，main goroutine继续执行结束，另一个goroutine还没来得及执行就已结束，无输出</span></span><br><span class="line">    fmt.Println(<span class="string">"main end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">main start</span><br><span class="line">main end</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a><strong>pipeline</strong></h4><p>channels可用于将多个goroutine连接在一起，一个channel的输出作为下一个channel的输入，这类串联的channel称之为pipeline</p>
<p>go Counter -&gt; chan naturals -&gt; go Squarer -&gt; chan squares -&gt; go Printer</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Counter</span></span><br><span class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">            naturals &lt;- x	<span class="comment">// 向naturals channel发送100个整数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(naturals)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Squarer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> x := <span class="keyword">range</span> naturals &#123;	<span class="comment">// 不断从naturals channel中接收整数</span></span><br><span class="line">            squares &lt;- x * x	<span class="comment">// 计算后向squares channel发送数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(squares)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Printer (in main goroutine)</span></span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> squares &#123;	<span class="comment">// 不断从squares channel中接收数据</span></span><br><span class="line">        fmt.Println(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单方向channel"><a href="#单方向channel" class="headerlink" title="单方向channel"></a><strong>单方向channel</strong></h4><p>默认情况下channel都是双向的，但可创建只能发送或只能接收的单方向channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</span><br><span class="line"><span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="typename">int</span> = c		<span class="comment">// 只能发送channel</span></span><br><span class="line"><span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="typename">int</span> = c		<span class="comment">// 只能接收channel</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> squarer(out <span class="keyword">chan</span>&lt;- <span class="typename">int</span>, in &lt;-<span class="keyword">chan</span> <span class="typename">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- v * v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a><strong>select多路复用</strong></h4><p>Go语言中<code>select...case</code>用于同时监听多个channel，<code>case</code>语句必须是一个面向channel的操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-chan1: <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>: <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>select…case</code>执行流程：</p>
<ol>
<li>select中只要有一个case能执行成功，则立刻执行</li>
<li>如果同一时间有多个case均能执行成功则伪随机方式抽取任意一个case执行</li>
<li>如果所有case都不能执行成功，则执行<code>default</code>。如果没有<code>default</code>，则<strong>一直阻塞</strong>，直到有一个<code>case</code>能执行</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)	<span class="comment">// 设置单核CPU执行</span></span><br><span class="line"></span><br><span class="line">    int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>, <span class="number">1</span>)	<span class="comment">// 新建channel，必须是有缓存channel</span></span><br><span class="line">    string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    int_chan &lt;- <span class="number">1</span></span><br><span class="line">    string_chan &lt;- <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">            fmt.Println(value)</span><br><span class="line">        <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">            <span class="built_in">panic</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有可能panic。因为int_chan和string_chan都可以成功执行，select会随机选取其中一个case执行，无法确定选择哪个case</span></span><br></pre></td></tr></table></figure>
<h2 id="基于共享变量的并发"><a href="#基于共享变量的并发" class="headerlink" title="基于共享变量的并发"></a><strong>基于共享变量的并发</strong></h2><h3 id="sync-Mutex互斥锁"><a href="#sync-Mutex互斥锁" class="headerlink" title="sync.Mutex互斥锁"></a><strong>sync.Mutex互斥锁</strong></h3><p><code>sync.Mutex</code>包中提供了<code>Lock()</code>和<code>Unlock()</code>方法，当需要访问共享变量时，通过调用<code>Lock()</code>/<code>Unlock()</code>方法获取互斥锁。如果互斥锁被其他goroutine调用<code>Lock()</code>先获取，那么访问该共享变量的goroutine便会阻塞，阻塞一直到其他goroutine调用<code>Unlock()</code>释放互斥锁。</p>
<p><code>Lock()</code>和<code>Unlock()</code>之间的代码段，称之为<strong>临界区</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu      sync.Mutex <span class="comment">// guards balance</span></span><br><span class="line">    balance <span class="typename">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Deposit(amount <span class="typename">int</span>) &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    balance = balance + amount</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Balance() <span class="typename">int</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    b := balance</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sync-RWMutex读写锁"><a href="#sync-RWMutex读写锁" class="headerlink" title="sync.RWMutex读写锁"></a><strong>sync.RWMutex读写锁</strong></h3><p><code>sync.RWMutex</code>包提供<strong>多读单写锁</strong>，读锁：<code>sync.RWMutex.Rlock()</code>/<code>sync.RWMutex.RUnlock()</code>；写锁：<code>sync.RWMutex.Lock()</code>/<code>sync.RWMutex.Unlock()</code></p>
<p><code>Rlock()</code>只能在临界区共享变量没有任何写入操作时才可用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> balance <span class="typename">int</span></span><br><span class="line"><span class="keyword">func</span> Balance() <span class="typename">int</span> &#123;</span><br><span class="line">    mu.RLock() <span class="comment">// readers lock</span></span><br><span class="line">    <span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sync-Once初始化"><a href="#sync-Once初始化" class="headerlink" title="sync.Once初始化"></a><strong>sync.Once初始化</strong></h3><p><code>sync.Once</code>中的<code>Do()</code>方法能在并发环境下，确保函数只被执行一次，<code>sync.Once.Do(f)</code>。常用于做初始化操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="typename">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> setup() &#123;</span><br><span class="line">    fmt.Println(<span class="string">"in setup"</span>)</span><br><span class="line">    a = <span class="string">"hello world"</span>	<span class="comment">// 初始化变量a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> doprint() &#123;</span><br><span class="line">    once.Do(setup) <span class="comment">//无此行则会打印两次"in setup"</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    &lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="comment">// 两个goroutine，虽然doprint()函数中有调用setup()，但由于使用了once.Do()，所以两个goroutine也只会执行一次setup()，既只输出一次"in setup"</span></span><br><span class="line">    <span class="keyword">go</span> doprint()</span><br><span class="line">    <span class="keyword">go</span> doprint()</span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="竞争条件检测"><a href="#竞争条件检测" class="headerlink" title="竞争条件检测"></a><strong>竞争条件检测</strong></h4><p>Go提供竞争条件检测分析工具，只要在<code>go build</code>、<code>go run</code>或者<code>go test</code>命令后面加上<code>-race</code>即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test -race mypkg    <span class="comment">// test the package</span></span><br><span class="line"><span class="keyword">go</span> run -race mysrc.<span class="keyword">go</span>  <span class="comment">// compile and run the program</span></span><br><span class="line"><span class="keyword">go</span> build -race mycmd   <span class="comment">// build the command</span></span><br></pre></td></tr></table></figure>
<h3 id="Goroutines和线程"><a href="#Goroutines和线程" class="headerlink" title="Goroutines和线程"></a><strong>Goroutines和线程</strong></h3><p>os线程使用固定大小的栈(一般2MB)；goroutine的栈大小不是固定的，可动态伸缩<strong>最大为1GB</strong></p>
<p>os线程被操作系统内核调度，进行上下文切换；goroutine由Go调度器调度，Go调度器调度不需要进行上下文切换，调度代价小</p>
<p>Go的调度器使用了一个叫做<code>GOMAXPROCS</code>的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数</p>
<p>进程有进程id(<code>pid</code>)，线程有线程id(<code>tid</code>)，goroutine没有id</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a><strong>Function</strong></h2><h3 id="函数声明"><a href="#函数声明" cl]]>
    </summary>
    
      <category term="GO" scheme="http://yoursite.com/tags/GO/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go语言圣经笔记-上]]></title>
    <link href="http://yoursite.com/2019/05/01/golang-bible-0/"/>
    <id>http://yoursite.com/2019/05/01/golang-bible-0/</id>
    <published>2019-05-01T02:49:33.000Z</published>
    <updated>2019-05-22T02:46:04.083Z</updated>
    <content type="html"><![CDATA[<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a><strong>程序结构</strong></h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a><strong>命名</strong></h3><ul>
<li><p>命名规则:</p>
<ul>
<li>以字母或下划线开头，接任意字母、数字或下划线(<strong>区分大小写</strong>)。保留关键字及预定义名不可用</li>
<li>名字<strong>首字母大小写</strong>决定该名在包外可见性</li>
</ul>
</li>
<li><p>保留关键字</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>      <span class="keyword">default</span>       <span class="keyword">func</span>     <span class="keyword">interface</span>   <span class="keyword">select</span></span><br><span class="line"><span class="keyword">case</span>       <span class="keyword">defer</span>         <span class="keyword">go</span>       <span class="keyword">map</span>         <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>       <span class="keyword">else</span>          <span class="keyword">goto</span>     <span class="keyword">package</span>     <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>      <span class="keyword">fallthrough</span>   <span class="keyword">if</span>       <span class="keyword">range</span>       <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>   <span class="keyword">for</span>           <span class="keyword">import</span>   <span class="keyword">return</span>      <span class="keyword">var</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>预定义名</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内建常量: <span class="constant">true</span> <span class="constant">false</span> <span class="constant">iota</span> <span class="constant">nil</span></span><br><span class="line"></span><br><span class="line">内建类型: <span class="typename">int</span> <span class="typename">int8</span> <span class="typename">int16</span> <span class="typename">int32</span> <span class="typename">int64</span></span><br><span class="line">         <span class="typename">uint</span> <span class="typename">uint8</span> <span class="typename">uint16</span> <span class="typename">uint32</span> <span class="typename">uint64</span> <span class="typename">uintptr</span></span><br><span class="line">         <span class="typename">float32</span> <span class="typename">float64</span> <span class="typename">complex128</span> <span class="typename">complex64</span></span><br><span class="line">         <span class="typename">bool</span> <span class="typename">byte</span> <span class="typename">rune</span> <span class="typename">string</span> error</span><br><span class="line"></span><br><span class="line">内建函数: <span class="built_in">make</span> <span class="built_in">len</span> <span class="built_in">cap</span> <span class="built_in">new</span> <span class="built_in">append</span> <span class="built_in">copy</span> <span class="built_in">close</span> <span class="built_in">delete</span></span><br><span class="line">         <span class="built_in">complex</span> <span class="built_in">real</span> <span class="built_in">imag</span></span><br><span class="line">         <span class="built_in">panic</span> <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命名规范</p>
<ul>
<li><p>使用<strong>驼峰式</strong>方式</p>
</li>
<li><p>包(package)名用<strong>小写</strong>，使用短命名</p>
</li>
<li><p>接口(interface)名，单方法接口以函数名+<code>er</code>后缀，两个方法接口综合两个函数名+<code>er</code>后缀，三个以上取能精准描述接口目的的名字</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriteFlusher <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write([]<span class="typename">byte</span>) (<span class="typename">int</span>, error)</span><br><span class="line">    Flush() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部变量/函数参数，使用小写字母，尽量短小</p>
</li>
<li><p>方法接收者(receiver)应该缩写，一般使用一个或者两个字符作为receiver的名称</p>
</li>
<li><p>包(package)级别导出名不要把包名的意义再写一遍，<code>bytes.Buffer</code>，<del><code>bytes.ByteBuffer</code></del></p>
</li>
</ul>
</li>
</ul>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a><strong>声明</strong></h3><p>声明语句，包(package)级声明语句顺序无关紧要</p>
<ul>
<li><strong><code>var</code></strong>: 变量</li>
<li><strong><code>const</code></strong>: 常量</li>
<li><strong><code>type</code></strong>: 类型</li>
<li><strong><code>func</code></strong>: 函数</li>
</ul>
<p>声明示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="typename">int</span></span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="typename">int</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    name <span class="typename">string</span></span><br><span class="line">    age <span class="typename">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> mapper <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">string</span>  <span class="comment">// mapper = make(map[int]string) map是声明后必须使用make初始化才能使用</span></span><br><span class="line"><span class="keyword">var</span> names []<span class="typename">string</span>	<span class="comment">// 声明并初始化: var sliceName []type = make([]type, len, capacity)，简写slice1 := make([]type, len, capacity)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi <span class="typename">float32</span> = <span class="number">3.14159</span> <span class="comment">// const Pi = 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	id      <span class="typename">int</span></span><br><span class="line">	name    <span class="typename">string</span></span><br><span class="line">	age     <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> WriteFlusher <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write([]<span class="typename">byte</span>) (<span class="typename">int</span>, error)</span><br><span class="line">    Flush() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> add(a, b <span class="typename">int</span>) <span class="typename">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><p>变量声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span> = expression	<span class="comment">// var age int = 18</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span>	<span class="comment">// var age int	// 自动赋予零值</span></span><br><span class="line"><span class="keyword">var</span> name = expression	<span class="comment">// var age = 18</span></span><br></pre></td></tr></table></figure>
<p><code>type</code> 和 <code>= expression</code>可二选一，省略<code>type</code>会根据<code>expression</code>推导变量类型(<code>var name = expression</code>)，省略<code>expression</code>会用<strong>零值</strong>初始化变量(<code>var name type</code>)，各类型零值:</p>
<ul>
<li>number: <code>0</code></li>
<li>bool: <code>false</code></li>
<li>string: <code>“”</code> (空字符串)</li>
<li>slice/pointer/map/chan/func/interface: <code>nil</code></li>
<li>array/struct: 每个元素/字段对于类型的零值</li>
</ul>
<h4 id="简短变量声明"><a href="#简短变量声明" class="headerlink" title="简短变量声明"></a><strong>简短变量声明</strong></h4><p><strong>函数内部</strong>可用简短变量声明语句<strong>声明</strong>和<strong>初始化</strong>局部变量(只能用于函数内部)，变量类型根据表达式自动推导</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := expression	<span class="comment">// age := 18</span></span><br></pre></td></tr></table></figure>
<p>相同词法域中，简短变量声明过的变量<strong>只能赋值</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">out, err := os.Create(outfile)	<span class="comment">// err变量已简短声明过，此处是对err变量进行了赋值</span></span><br></pre></td></tr></table></figure>
<p>简短变量声明语句中<strong>必须至少要声明一个新变量</strong>，否则编译不通过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">f, err := os.Create(outfile) 	<span class="comment">// 编译报错，f和err都已声明过，只能赋值		// f, err = os.Create(outfile)</span></span><br></pre></td></tr></table></figure>
<p>简短变量声明只对同级词法域声明过的变量进行赋值操作，变量在外部词法域则是重新声明一个新的变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    test := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="constant">true</span> &#123;</span><br><span class="line">        test := <span class="number">1</span>	<span class="comment">// 此test变量是一个新变量, 无论怎么修改都不会影响if外的test变量</span></span><br><span class="line">        fmt.Println(<span class="string">"main if"</span>, test)    <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"main"</span>, test)       <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a><strong>指针</strong></h4><p>一个指针类型变量的值是另一个变量的地址(指针存储变量在内存中的位置)，通过指针可<strong>直接</strong>读或更新对应变量的值，不需要知道变量名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x		<span class="comment">// p为指向x变量的指针，p的类型为 *int	// &amp; 为取地址操作</span></span><br><span class="line">fmt.Println(*p)		<span class="comment">// 1	// *p表示读取指针指向变量的值</span></span><br><span class="line">*p = <span class="number">2</span>		<span class="comment">// 等价于 x = 2	// 通过指针修改变量值</span></span><br><span class="line">fmt.Println(x)	<span class="comment">// 2</span></span><br><span class="line">*p++	<span class="comment">// 只是增加p指向的变量的值，并不改变p指针！！！</span></span><br><span class="line">fmt.Println(x)	<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><strong>任何类型的指针的零值都是<code>nil</code></strong></p>
<p>p指向某个有效变量，那么<code>p != nil</code>测试为<code>true</code></p>
<p>指针可进行相等测试，只有当它们指向同一个变量或全部是nil时才相等</p>
<h4 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a><strong>new函数</strong></h4><p><strong><code>new(T)</code></strong></p>
<ol>
<li>创建一个T类型匿名变量</li>
<li>初始化匿名变量为T类型零值</li>
<li>返回匿名变量地址，返回的指针类型为<strong><code>*T</code></strong></li>
</ol>
<p><code>new(T)</code>得到的是一个<code>*T</code>类型，值为T类型零值的匿名变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="typename">int</span>)	<span class="comment">// p 类型为*int，值为0</span></span><br><span class="line">fmt.Println(*p)	<span class="comment">// 0</span></span><br><span class="line">*p = <span class="number">2</span></span><br><span class="line">fmt.Println(*p)	<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a><strong>赋值</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>                       <span class="comment">// 命名变量的赋值</span></span><br><span class="line">*p = <span class="constant">true</span>                   <span class="comment">// 通过指针间接赋值</span></span><br><span class="line">person.name = <span class="string">"bob"</span>         <span class="comment">// struct结构体字段赋值</span></span><br><span class="line">count[x] = count[x] * scale <span class="comment">// array、slice或map的元素赋值</span></span><br><span class="line">count[x] *= scale			<span class="comment">// 二元算术运算符和赋值语句的复合操作</span></span><br><span class="line">v++;v--						<span class="comment">// 数值变量支持递增/递减语句，自增/自减是语句，非表达式，x = v++ 是错误的!!!</span></span><br></pre></td></tr></table></figure>
<p>元组赋值，允许同时更新多个变量的值</p>
<p>当函数调用出现在元组赋值右边的表达式中时，左边变量的数目必须和右边一致</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x					<span class="comment">// 交换两个变量</span></span><br><span class="line">i, j, k = <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>			<span class="comment">// 多变量同时赋值</span></span><br><span class="line">f, err = os.Open(<span class="string">"foo.txt"</span>)	<span class="comment">// os.Open()返回2个值，进行元组赋值时左边也必须有2个变量</span></span><br></pre></td></tr></table></figure>
<p>如果map查找、类型断言或channel接收出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v, ok = m[key]             <span class="comment">// map查找</span></span><br><span class="line">v, ok = x.(T)              <span class="comment">// 类型断言</span></span><br><span class="line">v, ok = &lt;-ch               <span class="comment">// channel接收</span></span><br><span class="line">_, ok = m[key]             <span class="comment">// 可使用_丢弃不需要的值</span></span><br></pre></td></tr></table></figure>
<p>隐式赋值行为：</p>
<ul>
<li>函数调用隐式地将调用参数的值赋值给函数的参数变量</li>
<li>返回语句会隐式地将返回操作的值赋值给结果变量</li>
<li>复合类型的字面量所产生的赋值行为 <code>medals := []string{&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;}</code>，赋值行为：<code>medals[0] = &quot;gold&quot;</code></li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a><strong>类型</strong></h3><p>类型声明语句一般在包级，&lt;类型名&gt;首字母大写则包外可见。类型声明语句如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;类型名&gt; &lt;底层类型&gt;	<span class="comment">// type Celsius float64</span></span><br></pre></td></tr></table></figure>
<p><strong>类型转换</strong>操作，每一类型<code>T</code>，都有对应的类型转换操作<code>T(x)</code>，用于将x转为T类型。<strong>只有当两个类型的底层基础类型相同时，才允许这种转型操作</strong>。</p>
<p>命名类型可为该类型的值定义新行为，行为表现为一组关联到该类型的函数集合，称之为<strong>类型方法集</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="typename">float64</span>	<span class="comment">// 创建命令类型</span></span><br><span class="line"><span class="keyword">func</span> (c Celsius) String() <span class="typename">string</span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%g°C"</span>, c) &#125;	<span class="comment">// 为命名类型创建String()方法</span></span><br><span class="line"><span class="keyword">var</span> c Celsius</span><br><span class="line">c = <span class="number">100.0</span></span><br><span class="line">fmt.Println(c.String())		<span class="comment">// 调用String()方法</span></span><br></pre></td></tr></table></figure>
<h3 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a><strong>包和文件</strong></h3><p>Go语言中的包(package)，目的是为了支持模块化、封装、单独编译和代码重用</p>
<p>一个包中保存在一个或多个以.go为文件后缀名的源文件，包级别的名字在同一个包的其他源文件可以直接访问，逻辑上所有代码都在一个文件一样</p>
<p>包所在目录路径是包的导入路径，e.g., 包导入路径: <code>gopl.io/ch1/helloworld</code>，目录路径: <code>$GOPATH/src/gopl.io/ch1/helloworld</code></p>
<p>每个包对应一个独立的名字空间，通过<strong>首字母大小写</strong>控制包外可见性</p>
<h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a><strong>导入包</strong></h4><p>每个包都有一个全局唯一的导入路径</p>
<p>每个包还有一个包名，包名命名以短小原则为主。一般而言，包名和包的导入路径的最后一个字段相同。e.g., <code>gopl.io/ch2/tempconv</code>，包名为<code>tempconv</code></p>
<p>包被导入却没有使用会引发编译错误</p>
<h4 id="包初始化"><a href="#包初始化" class="headerlink" title="包初始化"></a><strong>包初始化</strong></h4><p>包的变量初始化：按变量<strong>声明顺序</strong>初始化，但变量间有依赖<strong>优先初始化被依赖变量</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b + c <span class="comment">// a 第三个初始化, 为 3</span></span><br><span class="line"><span class="keyword">var</span> b = f()   <span class="comment">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>     <span class="comment">// c 第一个初始化, 为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> f() <span class="typename">int</span> &#123; <span class="keyword">return</span> c + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>包内有多个<code>.go</code>源文件，按照发给编译器顺序初始化，Go语言构建工具首先按<code>.go</code>文件的文件名字典顺序排序，然后依次传给编译器</p>
<p>初始化工作可交由<code>init()</code>初始化函数完成，<code>init()</code>初始化函数有以下特点：</p>
<ul>
<li><p>每个<code>.go</code>文件可包含<strong>多个</strong><code>init()</code>初始化函数</p>
</li>
<li><p><code>init()</code>初始化函数<strong>不能被调用</strong>，<strong>无传参</strong></p>
</li>
<li>多个<code>init()</code>初始化函数，在程序执行时，<strong>按声明顺序</strong>被自动调用</li>
</ul>
<p>包的初始化顺序如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/moguol/blogImg/master/golang-pkg-init.png" alt="Go 包初始化"></p>
<p><a href="https://beego.me/docs/quickstart/router.md" target="_blank" rel="external">图片出处</a></p>
<ol>
<li><strong>初始化依赖包</strong>：初始化一个包前，必须完全初始化其所依赖的包，按包<strong>出现顺序</strong>初始化并且每个包<strong>只会初始化一次</strong>(即使多次引用也一次)</li>
<li><strong>初始化const常量</strong>：初始化完依赖包后，以下的都属于<strong>包内初始化</strong>。首先是<code>const</code>常量的初始化</li>
<li><strong>初始化var全局变量</strong>：按全局变量<strong>声明顺序</strong>初始化，但全局变量间有依赖<strong>优先初始化被依赖变量</strong></li>
<li><strong>初始化init()函数</strong>：按<strong>声明顺序</strong>初始化<code>init()</code>函数，若包内有多个<code>.go</code>文件，按<strong>文件名字典顺序</strong>初始化<code>.go</code>文件</li>
<li><strong>main()函数</strong></li>
</ol>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h3><ul>
<li><p>包级作用域：包内函数外定义，必须以<code>var</code>方式声明(不能简短声明)，包内多个文件皆可使用，包外可见性以首字母大小写决定。包级作用域的变量，声明顺序不影响作用域范围</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="typename">int</span>	<span class="comment">// 包级作用域</span></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数作用域：传入参数(非外部引用型)、返回值声明参数、函数内部声明参数，以上都只能在函数内部使用。若外部有同名变量则内部覆盖外部</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str/name/age 都是函数作用域</span></span><br><span class="line"><span class="keyword">func</span> test(str <span class="typename">string</span>) (name <span class="typename">string</span>) &#123;</span><br><span class="line">    age := <span class="number">18</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="typename">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> init() &#123;</span><br><span class="line">    cwd, err := os.Getwd() <span class="comment">// 此处cwd为重新声明定义的变量，与包级cwd无丝毫关系，为init()函数作用域变量</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"os.Getwd failed: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for/if/switch局部作用域</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f, err := os.Open(fname); err != <span class="constant">nil</span> &#123; <span class="comment">// if局部作用域，只在if词法域中有效</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">f.ReadByte() <span class="comment">// f 为if局部作用域变量，if外无法使用，f未定义</span></span><br><span class="line">f.Close()    <span class="comment">// compile error: undefined f</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>Go语言中数据类型分为4类：</p>
<ul>
<li><strong>基础类型</strong>：numeric、string、bool</li>
<li><strong>复合类型</strong>：array、struct</li>
<li><strong>引用类型</strong>：point、<strong>slice</strong>、<strong>map</strong>、<strong>channal</strong>、function</li>
<li><strong>接口类型</strong>：interface</li>
</ul>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a><strong>基础类型</strong></h3><h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a><strong>Integer</strong></h4><ul>
<li>有符号整型：<code>int8</code>、<code>int16</code>、<code>int32</code>(<code>rune</code>)、<code>int64</code>    (<code>-2^(N-1)</code> ~ <code>2^(N-1)-1</code>)</li>
<li>无符号整型：<code>uint8</code>(<code>byte</code>)、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>    (<code>0</code> ~ <code>2^N - 1</code>)</li>
<li>依赖系统类型：<code>int</code>、<code>uint</code>    (32位系统为<code>int32</code>、<code>uint32</code>，64位系统为<code>int64</code>、<code>uint64</code>)</li>
</ul>
<p>二元运算优先级：上 &gt; 下、左 &gt; 右、可使用<code>()</code>提升优先级、<code>%</code>的符号和被取模数符号一致、<code>/</code>结果精度根据操作数定</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*      /      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^</span><br><span class="line">+      -      |      ^</span><br><span class="line">==     !=     &lt;      &lt;=       &gt;      &gt;=</span><br><span class="line">&amp;&amp;</span><br><span class="line">||</span><br></pre></td></tr></table></figure>
<h4 id="Float"><a href="#Float" class="headerlink" title="Float"></a><strong>Float</strong></h4><ul>
<li>单精度浮点型：<code>float32</code></li>
<li>双精度浮点型：<code>float64</code></li>
</ul>
<h4 id="Complex"><a href="#Complex" class="headerlink" title="Complex"></a><strong>Complex</strong></h4><ul>
<li><code>complex64</code>：对应<code>float32</code></li>
<li><code>complex128</code>：对应<code>float64</code></li>
</ul>
<h4 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a><strong>Bool</strong></h4><ul>
<li><code>true</code></li>
<li><code>false</code></li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h4><p>字符串是数个8位字节(8-bit bytes)的集合，通常是UTF-8编码的文本(可为其他编码)</p>
<p>字符串是<strong>不可改变</strong>的字节序列 (意味若两个字符串共享相同的底层数据是安全的)，由于字符串不可改变，所以每次更改字符串需要重新分配一块新内存空间<br>Go的字符串有2种形式：</p>
<ul>
<li><p>解析性字符串：带<code>“”</code>的字节序列</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello world"</span></span><br><span class="line">fmt.Println(s)	<span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原生字符串：带反引号的字符序列</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">`hello world\n`</span></span><br><span class="line">fmt.Println(s)	<span class="comment">// hello world\n	// \n会被原样输出</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>len()</code>函数返回字符串中的字节数；<code>str[i]</code>索引操作返回第<code>i</code>个字节值(<code>0&lt;= i &lt;len(str)</code>)，超出索引范围会引发panic</p>
<p><code>str[i:j]</code>子字符串操作返回第<code>i</code>个字节到第<strong><code>j-1</code></strong>个字节(并非第<code>j</code>个字节)</p>
<p><code>+</code>操作拼接两个字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello, world"</span>		<span class="comment">// len(s) == 12</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>:<span class="number">5</span>])		<span class="comment">// "hello"</span></span><br><span class="line">fmt.Println(s[:])		<span class="comment">// "hello, world"</span></span><br><span class="line">fmt.Println(<span class="string">"goodbye"</span> + <span class="string">" "</span> + s[<span class="number">7</span>:])	<span class="comment">// "goodbye world"</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">"H"</span>		<span class="comment">// cannot assign to s[0]	字符串不可改变</span></span><br><span class="line">Usage := <span class="string">`test	// `</span><span class="string">`表示原生字符串字面值</span><br><span class="line"></span><br><span class="line">Uage: xxx`</span></span><br></pre></td></tr></table></figure>
<p>由于字符串不可改变，所以若想单独修改字符串中的字符，则需要将<code>string</code>转换为<code>[]byte</code>，修改完后再转换回<code>string</code> (<code>[]byte</code>既是<code>[]uint8</code>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello world"</span></span><br><span class="line">b := []<span class="typename">byte</span>(s)</span><br><span class="line">b[<span class="number">0</span>] = <span class="string">'H'</span>	<span class="comment">// 是''而非""</span></span><br><span class="line">fmt.Println(<span class="typename">string</span>(b))</span><br></pre></td></tr></table></figure>
<p><code>string</code>转为<code>rune</code>，<code>rune</code>是<code>int32</code>别名(<code>byte</code>是<code>uint8</code>别名)，代表字符的Unicode编码，使用4个字节存储，将<code>string</code>转成<code>rune</code>就意味着任何一个字符都用<code>4</code>个字节来存储其Unicode值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s2 := <span class="string">"Go语言"</span></span><br><span class="line">fmt.Pringln(<span class="built_in">len</span>(s2))	<span class="comment">// 8 	// len()输出字节个数而非字符个数，一个UTF-8编码的中文等于3字节</span></span><br><span class="line"></span><br><span class="line">r := []<span class="typename">rune</span>(s2)</span><br><span class="line">fmt.Println(r)			<span class="comment">// [71 111 35821 35328]		// 输出的是4个Unicode值</span></span><br><span class="line">fmt.Pringln(<span class="built_in">len</span>(r))		<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p><code>string</code>转为<code>numeric</code>需要使用到<code>strconv</code>包：</p>
<ul>
<li><p><code>strconv.Itoa</code>：<code>int</code> to <code>string</code></p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">123</span></span><br><span class="line">s := strconf.Itoa(i)		<span class="comment">// s 为 string类型，值为"123"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>strconv.Atoi</code>：<code>string</code> to <code>int</code></p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s3 := <span class="string">"123"</span></span><br><span class="line">i, err := strconv.Atoi(s3)		<span class="comment">// i 为 int类型，值为123</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Const"><a href="#Const" class="headerlink" title="Const"></a><strong>Const</strong></h4><p>常量的值在编译阶段确定而非运行时，常量的底层类型都是基础类型(<code>bool</code>/<code>numeric</code>/<code>string</code>)，常量的值不可修改，常量的二元运算结果也是常量</p>
<p>批量声明常量，除第一个必须有初始化表达式外，其余的可省略，省略则默认使用前面的初始化表达式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi <span class="typename">float64</span> = <span class="number">3.14</span>		<span class="comment">// const pi = 3.14 省略type也可，自动根据表达式确认type</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">    b		<span class="comment">// 省略初始化表达式，默认使用前一个变量声明的初始化表达式</span></span><br><span class="line">    c = <span class="number">2</span></span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d)		<span class="comment">// 1 1 2 2</span></span><br></pre></td></tr></table></figure>
<p>iota常量生成器，用于以相似规则生成常量。<code>const</code>声明语句中，第一个变量声明所在行<code>iota</code>将置<code>0</code>，然后每个有常量声明的行都<code>+1</code>，<code>iota</code>按行递增</p>
<p>若<code>iota</code>生成器被打断后，需要显示用<code>iota</code>恢复</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="constant">iota</span></span><br><span class="line">    b				<span class="comment">// iota + 1</span></span><br><span class="line">    c = <span class="string">"test"</span></span><br><span class="line">    d				<span class="comment">// iota被打断，d 省略初始化表达式，默认使用前一个初始化表达式</span></span><br><span class="line">    e				<span class="comment">// 同 d</span></span><br><span class="line">    f = <span class="constant">iota</span>		<span class="comment">// 显示使用iota恢复，iota后每有一行变量声明都会+1，不管是否被打断</span></span><br><span class="line">)</span><br><span class="line">fmt.Pringln(a, b, c, d, e, f)	<span class="comment">// 0 1 test test test 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a, b = <span class="constant">iota</span>, <span class="constant">iota</span> + <span class="number">1</span>		<span class="comment">// iota == 0</span></span><br><span class="line">    _, _						<span class="comment">// iota == 1</span></span><br><span class="line">    c, d						<span class="comment">// iota == 2</span></span><br><span class="line">    e = <span class="constant">iota</span> + <span class="number">10</span>				<span class="comment">// iota == 3</span></span><br><span class="line">)</span><br><span class="line">fmt.Pringln(a, b, c, d, e)		<span class="comment">// 0 1 2 3 13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _ = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="constant">iota</span>)</span><br><span class="line">    KiB <span class="comment">// 1024</span></span><br><span class="line">    MiB <span class="comment">// 1048576</span></span><br><span class="line">    GiB <span class="comment">// 1073741824</span></span><br><span class="line">    TiB <span class="comment">// 1099511627776             (exceeds 1 &lt;&lt; 32)</span></span><br><span class="line">    PiB <span class="comment">// 1125899906842624</span></span><br><span class="line">    EiB <span class="comment">// 1152921504606846976</span></span><br><span class="line">    ZiB <span class="comment">// 1180591620717411303424    (exceeds 1 &lt;&lt; 64)</span></span><br><span class="line">    YiB <span class="comment">// 1208925819614629174706176</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a><strong>复合类型</strong></h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a><strong>Array</strong></h4><p>数组是由特定元素组成的<strong>固定长度</strong>序列(<code>[length]type</code>)，通过索引下标访问元素(<code>0</code> ~ <code>len(array) - 1</code>)</p>
<p>数组长度是数组类型的组成部分，数组长度在编译阶段确定，故<code>[3]int</code>和<code>[4]int</code>是两个不同的数组类型</p>
<p>若<code>[length]type</code>中length用<code>...</code>代替，表示数组长度根据初始化值的个数决定</p>
<p>相同类型的数组(<code>length</code>和<code>type</code>都相同)可进行比较，不同类型的数组进行比较会编译出错panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">3</span>]<span class="typename">int</span></span><br><span class="line">array[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(array[<span class="number">0</span>])	<span class="comment">// 0	// 无初始化值赋值则默认为对应类型的零值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var array1 [3]string = [3]string&#123;"one", "two", "three"&#125;</span></span><br><span class="line">array1 := [<span class="number">3</span>]<span class="typename">string</span>&#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;	<span class="comment">// 声明并初始化赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> array1 &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array2 := [...]<span class="typename">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;		<span class="comment">// [3]int</span></span><br><span class="line"></span><br><span class="line">r := [...]<span class="typename">int</span>&#123;<span class="number">99</span>: -<span class="number">1</span>&#125;			<span class="comment">// 含有100个元素，最后一个元素初始化为-1</span></span><br></pre></td></tr></table></figure>
<h4 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a><strong>Slice</strong></h4><p>切片是由特定元素组成的<strong>可变长</strong>序列(<code>[]type</code>)，通过索引下标访问元素(<code>0</code> ~ <code>cap(slice)</code>)</p>
<p>slice和array不同，slice间不能进行比较，slice唯一能进行比较操作的是和<code>nil</code>，零值slice等于<code>nil</code>(<code>nil</code>值的slice无底层array)，但判断slice是否为空不能用<code>s == nil</code>，使用<code>len(s) == 0</code></p>
<p>slice由3部分组成：</p>
<ul>
<li>指针<code>pointer</code>：指向第一个slice元素对应的底层array元素的地址 (slice的第一个元素不一定就是array的第一个元素)</li>
<li>长度<code>length</code>：slice的元素个数 (length &lt;= capacity)，可使用<code>len(slice)</code>获得</li>
<li>容量<code>capacity</code>：slice元素的最大个数，可使用<code>cap(slice)</code>获得</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/sort.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer	<span class="comment">// 指向所引用的数组指针	// unsafe.Pointer 表示任何可寻址的值的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="typename">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="typename">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice切片操作<code>s[i:j]</code>(<code>0&lt;=i&lt;=j&lt;=cap(s)</code>)，获取第<code>i</code>个元素到第<strong><code>j-1</code></strong>个元素，<code>len(s[i:j])</code>为<code>j-i</code>，<code>cap(s[i:j])</code>为<strong><code>cap(s)-i</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    s := []<span class="typename">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))		<span class="comment">// [1 2 3 4 5] 5 5</span></span><br><span class="line"></span><br><span class="line">    s1 := s[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))	<span class="comment">// [1 2 3] 3 5</span></span><br><span class="line"></span><br><span class="line">    s2 := s[<span class="number">2</span>:]</span><br><span class="line">    fmt.Println(s2, <span class="built_in">len</span>(s2)， <span class="built_in">cap</span>(s2))	<span class="comment">// [3 4 5] 3 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        fmt.Println(i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可使用内置的<code>make()</code>函数创建slice，<code>make()</code>创建一个匿名的数组变量并<strong>初始化赋值对应类型的零值</strong>，然后返回一个slice</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make([]T, len)</span></span><br><span class="line"><span class="comment">// make([]T, len, cap)</span></span><br><span class="line"></span><br><span class="line">s4 := <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="number">3</span>)</span><br><span class="line">s4[<span class="number">1</span>] = <span class="number">222</span></span><br><span class="line">fmt.Println(s4)		<span class="comment">// [0 222 0]</span></span><br></pre></td></tr></table></figure>
<p>使用<strong><code>append()</code></strong>函数向slice追加元素，使用<code>append()</code>函数必须注意一点：调用<code>append()</code>函数是，会先检测slice是否有足够的<strong>capacity</strong>保存新元素，如果有足够容量则直接扩展slice，<strong>保持底层数组不变</strong>；如果没有足够容量会先分配一个<strong><code>capacity * 2</code></strong>的新slice，然后将原slice内容复制到新slice，最后再添加新元素，由于新分配了内存空间，所以<strong>底层数组改变</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="typename">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(s)				<span class="comment">// [1 2 3]</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">fmt.Println(s)				<span class="comment">// [1 2 3 4]</span></span><br><span class="line"></span><br><span class="line">s1 := []<span class="typename">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, s1...)	<span class="comment">// 将一个slice追加到另一个slice</span></span><br><span class="line">fmt.Println(s)				<span class="comment">// [1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="number">0</span>, <span class="number">10</span>)		<span class="comment">// a ---&gt; 0x1234  无(data)  0(length)  10(capacity)</span></span><br><span class="line">b := <span class="built_in">append</span>(a, <span class="number">1</span>)					<span class="comment">// b ---&gt; 0x1234  1(data)   1(length)  10(capacity)		// a和b指向的底层数组是一致的，但a长度为0，b长度为1</span></span><br><span class="line">_ = <span class="built_in">append</span>(a, <span class="number">2</span>)					<span class="comment">// a和b指向的底层数组是相同的，此行修改了底层数组，a长度为0，append 2直接将array[0] = 2 (之前array[0] == 1 被覆盖)</span></span><br><span class="line"><span class="built_in">println</span>(b[<span class="number">0</span>])			<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="typename">int</span>&#123;<span class="number">5</span>&#125;					<span class="comment">// 0x1234(array add)  5(data)      1(length)  1(capacity)</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">7</span>)			<span class="comment">// 0x5678(array add)  5,7(data)    2(length)  2(capacity)		// 由于容量不够，capacity*2生成新slice(地址改变)</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">9</span>)			<span class="comment">// 0x9abc(array add)  5,7,9,[0](data)  3(length)  4(capacity)		// 由于容量不够，capacity*2生成新slice(地址改变)</span></span><br><span class="line">x := <span class="built_in">append</span>(s, <span class="number">11</span>)		<span class="comment">// 0x9abc(array add)  5,7,9,11(data)  4(length)  4(capacity)		// 由于上次的扩容，容量足够，无生成新slice</span></span><br><span class="line">y := <span class="built_in">append</span>(s, <span class="number">12</span>)		<span class="comment">// 0x9abc(array add)  5,7,9,12(data)  4(length)  4(capacity)		// 由于上次的扩容，容量足够，无生成新slice导致数据覆盖</span></span><br><span class="line">fmt.Println(s, x, y)	<span class="comment">// [5 7 9] [5 7 9 12] [5 7 9 12]</span></span><br></pre></td></tr></table></figure>
<p>slice小技巧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个slice</span></span><br><span class="line">a = <span class="built_in">append</span>(a, b...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除[i, j)之间的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[j:]...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除位置i的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置i扩展长度为j的slice</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>(<span class="built_in">make</span>([]T, j), a[i:]...)...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在位置i插入元素j</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]T&#123;j&#125;, a[i:]...)...)</span><br></pre></td></tr></table></figure>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h4><p>map是<strong>无序</strong>的key/value对集合，<strong><code>map[K]V</code></strong>。map中所有key为同一类似，所有value为同一类型</p>
<p>map的key类型必须为支持比较操作<code>==</code>的数据类型，所以<code>slice</code>、<code>map</code> 和 <code>function</code>类型无法做为map的key。map的key类型无任何限制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> echo() <span class="typename">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"testMap"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  ages := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>&#123;<span class="string">"alice"</span>: <span class="number">31</span>&#125;</span><br><span class="line">  ages[echo()]++			<span class="comment">// 使用echo()返回的string作为key</span></span><br><span class="line">  fmt.Println(ages)		<span class="comment">// map[alice:31 testMap:1]</span></span><br><span class="line">  ages[echo]++				<span class="comment">// panic!!!	cannot use echo (type func() string) as type string in map index  echo为函数类型，不能作为key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建map可直接使用内置<code>make()</code>函数，也可用map字面值初始化方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)		<span class="comment">// make()方式创建</span></span><br><span class="line">ages[alice] = <span class="number">31</span></span><br><span class="line"></span><br><span class="line">ages := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span> &#123;			<span class="comment">// map字面值初始化方式创建</span></span><br><span class="line">  <span class="string">"alice"</span>: <span class="number">31</span>,</span><br><span class="line">  <span class="string">"charlie"</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ages := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>&#123;&#125;		<span class="comment">// map字面值创建空map</span></span><br></pre></td></tr></table></figure>
<p>map通过key下标访问value；通过<code>delete()</code>删除元素；通过<code>for/range</code>遍历map，遍历输出的<strong>顺序是随机的</strong>；通过<code>if/ok</code>判断是否存在value</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(ages[<span class="string">'alice'</span>])		<span class="comment">// 31</span></span><br><span class="line"><span class="built_in">delete</span>(ages, <span class="string">"alice"</span>)					<span class="comment">// 删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> ages &#123;	<span class="comment">// map遍历，随机输出</span></span><br><span class="line">  fmt.Println(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过sort.Strings实现顺序输出</span></span><br><span class="line">names := []stirng</span><br><span class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</span><br><span class="line">  names = <span class="built_in">append</span>(names, name)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(names)</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">  fmt.Println(name, ages[name])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在key/value</span></span><br><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">"bob"</span>]; !ok &#123;</span><br><span class="line">  <span class="comment">// not exists</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明map后必须要创建map后才可进行赋值操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testMap <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span></span><br><span class="line">testMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)		<span class="comment">// 声明后必须使用make()创建才可使用</span></span><br><span class="line">testMap[<span class="string">"alice"</span>] = <span class="number">31</span></span><br></pre></td></tr></table></figure>
<p>map中的value是<strong>不可寻址</strong>的，对map的value进行取地址操作或让value出现在赋值语句<code>=</code>左边都会引起panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ := &amp;ages[<span class="string">"alice"</span>]		<span class="comment">// panic!!! cannot take the address of ages["alice"]  map中value不可寻址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  m := <span class="keyword">map</span>[<span class="typename">string</span>]Student&#123;<span class="string">"people"</span>: &#123;<span class="string">"test"</span>&#125;&#125;</span><br><span class="line">  <span class="comment">//m := map[string]*Student&#123;"people": &#123;"test"&#125;&#125;		// 解决办法</span></span><br><span class="line">  m[<span class="string">"people"</span>].name = <span class="string">"test1"</span>				<span class="comment">// panic!!!	赋值语句=的左边对象必须是可寻址的,或者是map的index操作，或者是_，m["people"].name 是不可寻址的，不能在赋值语句左边</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(m[<span class="string">"people"</span>].name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a><strong>Struct</strong></h4><p>struct结构体是由零个或多个任意类型的值组合而成，值称为结构体的成员，成员通过<code>.</code>点操作符访问，如：<code>struct.member</code>，不包含任何成员的结构体为空结构体<code>struct{}</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;		<span class="comment">// 声明struct</span></span><br><span class="line">    ID        <span class="typename">int</span></span><br><span class="line">    Name      <span class="typename">string</span></span><br><span class="line">    Address   <span class="typename">string</span></span><br><span class="line">    DoB       time.Time</span><br><span class="line">    Position  <span class="typename">string</span></span><br><span class="line">    Salary    <span class="typename">int</span></span><br><span class="line">    ManagerID <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dilbert Employee		<span class="comment">// 声明Employee类型变量</span></span><br><span class="line">dilbert.Salary += <span class="number">500</span>		<span class="comment">// 通过点符号操作成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构体字面值构建结构体</span></span><br><span class="line">albert := Empolyee&#123;<span class="number">1</span>, <span class="string">"albert"</span>&#125;			<span class="comment">// 不指定成员名，但顺序比较和声明struct的成员顺序一致</span></span><br><span class="line">lily := Empolyee&#123;ID: <span class="number">2</span>, Name: <span class="string">"lily"</span>, Position: <span class="string">"china"</span>&#125;		<span class="comment">// 使用成员名构建struct，被忽略的其他成员使用对应类型的零值</span></span><br></pre></td></tr></table></figure>
<p>相同类型的结构体是可以进行比较的，结构体是否是相同类型，取决于以下2点：</p>
<ol>
<li>成员类型、成员个数相同</li>
<li>成员<strong>顺序</strong>相同</li>
</ol>
<p>成员名<strong>首字母是否大小写</strong>决定其能否导出，首字母大写的成员可导出(包外可访问)</p>
<p>复合类型(<code>array</code>、<code>struct</code>)的值不能包含其自身，即S结构体类型将不能再有S类型的成员，但可有<code>*S</code>指针类型的成员</p>
<p>struct允许嵌套，即一个struct中嵌入另一个struct</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Center Point</span><br><span class="line">    Radius <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle Circle</span><br><span class="line">    Spokes <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.Circle.Center.X = <span class="number">8</span></span><br><span class="line">w.Circle.Center.Y = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>struct还支持<strong>匿名成员</strong>，即只声明成员的类型，而不指名成员的名称，但<strong>匿名成员的类型必须是命名类型或指向命名类型的指针</strong>。其实匿名成员的名称既是其命名类型的名称(隐式名称)，由于此，所以不能有两个类型相同的匿名成员，否则会导致成员名称冲突</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point						<span class="comment">// 匿名成员</span></span><br><span class="line">    Radius <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle					<span class="comment">// 匿名成员</span></span><br><span class="line">    Spokes <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span>			<span class="comment">// 相当于w.Circle.Point.X</span></span><br><span class="line">w.Y = <span class="number">8</span>     <span class="comment">// 相当于w.Circle.Point.Y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名类型的字面值初始化</span></span><br><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle: Circle&#123;		<span class="comment">// 此处可看出匿名成员的名称既是其命名类型的名称</span></span><br><span class="line">        Point:  Point&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>&#125;,</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Json"><a href="#Json" class="headerlink" title="Json"></a><strong>Json</strong></h4><p>在需要对struct结构体成员添加额外元信息时，会使用到<strong>成员tag</strong>。通常以<strong>key:“value”</strong>形式存在，key为<code>encoding/&lt;key&gt;</code>包的名称，表示添加哪种格式的信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title  <span class="typename">string</span></span><br><span class="line">    Year   <span class="typename">int</span>  <span class="string">`json:"released"`</span>				<span class="comment">// 因为需要被enconding/json包使用，成员名首字母必须大写</span></span><br><span class="line">    Color  <span class="typename">bool</span> <span class="string">`json:"color,omitempty"`</span>	<span class="comment">// omitempty选项，表示当Go语言结构体成员为空或零值时不生成JSON对象</span></span><br><span class="line">    Actors []<span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> movies = []Movie&#123;</span><br><span class="line">    &#123;Title: <span class="string">"Casablanca"</span>, Year: <span class="number">1942</span>, Color: <span class="constant">false</span>,</span><br><span class="line">        Actors: []<span class="typename">string</span>&#123;<span class="string">"Humphrey Bogart"</span>, <span class="string">"Ingrid Bergman"</span>&#125;&#125;,</span><br><span class="line">    &#123;Title: <span class="string">"Cool Hand Luke"</span>, Year: <span class="number">1967</span>, Color: <span class="constant">true</span>,</span><br><span class="line">        Actors: []<span class="typename">string</span>&#123;<span class="string">"Paul Newman"</span>&#125;&#125;,</span><br><span class="line">    &#123;Title: <span class="string">"Bullitt"</span>, Year: <span class="number">1968</span>, Color: <span class="constant">true</span>,</span><br><span class="line">        Actors: []<span class="typename">string</span>&#123;<span class="string">"Steve McQueen"</span>, <span class="string">"Jacqueline Bisset"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="struct-to-json"><a href="#struct-to-json" class="headerlink" title="struct to json"></a><strong>struct to json</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jsonBytes, err := json.Marshal(movies)</span><br><span class="line"><span class="comment">// jsonBytes, err := json.MarshalIndent(movies, "", "    ")				// 格式化输出</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="typename">string</span>(jsonBytes))</span><br></pre></td></tr></table></figure>
<h5 id="json-to-struct"><a href="#json-to-struct" class="headerlink" title="json to struct"></a><strong>json to struct</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := <span class="string">`&#123;</span><br><span class="line">        "title": "Casablanca",</span><br><span class="line">        "released": 1942,</span><br><span class="line">        "actors": ["Humphrey Bogart","Ingrid Bergman"]</span><br><span class="line">        &#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> movie Movie</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="typename">byte</span>(jsonStr), &amp;movie); err != <span class="constant">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(movie)</span><br></pre></td></tr></table></figure>
<h5 id="map-to-json"><a href="#map-to-json" class="headerlink" title="map to json"></a><strong>map to json</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mapJson := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">"title"</span>:    <span class="string">"Casablanca"</span>,</span><br><span class="line">  <span class="string">"released"</span>: <span class="number">1942</span>,</span><br><span class="line">  <span class="string">"actors"</span>:   <span class="string">`["Humphrey Bogart","Ingrid Bergman"]`</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jsonBytes, err := json.Marshal(mapJson)</span></span><br><span class="line">jsonBytes, err := json.MarshalIndent(mapJson, <span class="string">""</span>, <span class="string">"    "</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="typename">string</span>(jsonBytes))</span><br></pre></td></tr></table></figure>
<h5 id="json-to-map"><a href="#json-to-map" class="headerlink" title="json to map"></a><strong>json to map</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := <span class="string">`&#123;</span><br><span class="line">        "title": "Casablanca",</span><br><span class="line">        "released": 1942,</span><br><span class="line">        "actors": ["Humphrey Bogart","Ingrid Bergman"]</span><br><span class="line">    &#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> movieMap <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="typename">byte</span>(jsonStr), &amp;movieMap); err != <span class="constant">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(movieMap)</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a><strong>程序结构</strong></h2><h3 id="命名"><a href="#命名" class="headerlink" tit]]>
    </summary>
    
      <category term="GO" scheme="http://yoursite.com/tags/GO/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenTracing & Jaeger]]></title>
    <link href="http://yoursite.com/2019/04/05/jaeger/"/>
    <id>http://yoursite.com/2019/04/05/jaeger/</id>
    <published>2019-04-05T07:45:33.000Z</published>
    <updated>2019-04-21T15:36:14.080Z</updated>
    <content type="html"><![CDATA[<h2 id="OpenTracing"><a href="#OpenTracing" class="headerlink" title="OpenTracing"></a><strong>OpenTracing</strong></h2><h3 id="微服务诊断分析系统"><a href="#微服务诊断分析系统" class="headerlink" title="微服务诊断分析系统"></a><strong>微服务诊断分析系统</strong></h3><ul>
<li>集中式日志系统(logging)：ELK</li>
<li>集中式度量系统(metrics)：Prometheus</li>
<li>分布式全链路追踪系统(tracing)：Jaeger<ul>
<li>完全实现OpenTracing</li>
<li>Golang编写</li>
<li>UDP传输</li>
</ul>
</li>
</ul>
<h3 id="分布式全链路追踪系统核心步骤"><a href="#分布式全链路追踪系统核心步骤" class="headerlink" title="分布式全链路追踪系统核心步骤"></a><strong>分布式全链路追踪系统核心步骤</strong></h3><ul>
<li>代码埋点</li>
<li>数据存储</li>
<li>查询展示</li>
</ul>
<h3 id="OpenTracing-术语"><a href="#OpenTracing-术语" class="headerlink" title="OpenTracing 术语"></a><strong>OpenTracing 术语</strong></h3><p>为了解决不同的分布式追踪系统 API 不兼容的问题，诞生了 <a href="https://opentracing.io/" target="_blank" rel="external">OpenTracing</a>规范</p>
<p>一条 <strong>Trace</strong>（调用链）可以被认为是一个由多个 <strong>Span</strong> 组成的有向无环图（DAG图），<strong>Span</strong> 与 <strong>Span</strong> 的关系被命名为 <strong>References</strong></p>
<p><strong>Span</strong>，可以被翻译为跨度，可以被理解为一次方法调用, 一个程序块的调用, 或者一次RPC/数据库访问.只要是一个具有完整时间周期的程序访问，都可以被认为是一个 <strong>Span</strong></p>
<p>一个<strong>Span</strong>包含以下状态：</p>
<ul>
<li><strong>An operation name</strong>: 操作名称</li>
<li><strong>A start timestamp</strong>: 起始时间</li>
<li><strong>A finish timestamp</strong>: 结束时间</li>
<li><strong>Span Tag</strong>: 一组键值对构成的 Span 标签集合。键值对中，键必须为 string，值可以是字符串，布尔，或者数字类型。Tag不会被子Span继承</li>
<li><strong>Span Log</strong>: 一组span的日志集合。 每次log操作包含一个<strong>键值对</strong>，以及一个<strong>时间戳</strong>。 键值对中，键必须为string，值可以是任意类型。 但是需要注意，不是所有的支持OpenTracing的Tracer,都需要支持所有的值类型。</li>
<li><strong>SpanContext</strong>: Span 上下文对象。SpanContext代表跨越进程边界，传递到下级span的状态，并用于封装<strong>Baggage</strong>。</li>
<li><strong>References</strong>: Span间关系，相关的零个或者多个 Span(Span 间通过 SpanContext 建立这种关系)<ul>
<li>一个Span可以与一个或者多个Span存在因果关系。OpenTracing目前定义了两种关系：<code>ChildOf</code> 和 <code>FollowsFrom</code></li>
</ul>
</li>
</ul>
<p>其他术语:</p>
<ul>
<li><strong>Baggage</strong>: 存储在SpanContext中的键值对，在整个trace链路中<strong>全局传输</strong>，会被子Span继承。(全局传输代价大，过多baggage会影响性能)</li>
<li><strong>Inject &amp; Extract</strong>: SpanContexts通过Inject/Extract实现跨进程通讯数据。SpanContexts通过Inject操作向Carrier(例如：HTTP header)增加数据，通过EXtract从Carrier中获取数据。</li>
<li><strong>Carrier</strong>: 用于在进场间携带SpanContext，对Carrier可进行Inject及Extract操作。OpenTracing支持2种Carrier格式(允许自定义Carrier格式)：<ul>
<li><strong>text map</strong>，平台惯用的map格式，基于unicode编码的<code>字符串</code>对<code>字符串</code>键值对</li>
<li><strong>binary</strong>，不透明的二进制数组</li>
</ul>
</li>
</ul>
<h2 id="Jaeger"><a href="#Jaeger" class="headerlink" title="Jaeger"></a><strong>Jaeger</strong></h2><h3 id="Jaeger-核心组件"><a href="#Jaeger-核心组件" class="headerlink" title="Jaeger 核心组件"></a><strong>Jaeger 核心组件</strong></h3><ul>
<li><p><strong>jaeger-client</strong>: 为不同语言实现了符合 OpenTracing 标准的 SDK</p>
</li>
<li><p><strong>jaeger-agent</strong>: 监听在 <strong>UDP</strong> 端口上接收 span 数据的网络守护进程，将数据批量发送给 jaeger-collector</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>端口号</th>
<th>协议</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>5775</td>
<td>UDP</td>
<td>通过兼容性 thrift 协议，接收 zipkin thrift 类型的数据</td>
</tr>
<tr>
<td>6831</td>
<td>UDP</td>
<td>通过兼容性 thrift 协议，接收 jaeger thrift 类型的数据</td>
</tr>
<tr>
<td>6832</td>
<td>UDP</td>
<td>通过二进制 thrift 协议，接收 jaeger thrift 类型的数据</td>
</tr>
<tr>
<td>5778</td>
<td>HTTP</td>
<td>可用于配置采样策略</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>jaeger-collector</strong>: 接收 jaeger-agent 发送来的数据，然后将数据写入后端存储。<strong>无状态</strong></li>
</ul>
<table>
<thead>
<tr>
<th>端口号</th>
<th>协议</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>14267</td>
<td>TChannel</td>
<td>用于接收 jaeger-agent 发送来的 jaeger.thrift 格式的 span</td>
</tr>
<tr>
<td>14268</td>
<td>HTTP</td>
<td>能直接接收来自客户端的 jaeger.thrift 格式的 span</td>
</tr>
<tr>
<td>14269</td>
<td>HTTP</td>
<td>健康检测/</td>
</tr>
<tr>
<td>14250</td>
<td>gRPC</td>
<td>用于接收 jaeger-agent 发送来的 model.proto 格式的 span</td>
</tr>
<tr>
<td>9411</td>
<td>HTTP</td>
<td>能通过 JSON 或 Thrift 接收 Zipkin spans，默认关闭</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>Data Store</strong>: Cassandra、ElasticSearch</p>
</li>
<li><p><strong>jaeger-query</strong>: 接收查询请求，然后从后端存储系统中检索 trace 并通过 UI 进行展示。<strong>无状态</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>端口号</th>
<th>协议</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>16686</td>
<td>HTTP</td>
<td>1. /api/* - API 端口路径  2. / - Jaeger UI 路径</td>
</tr>
<tr>
<td>16687</td>
<td>HTTP</td>
<td>健康检测/</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>jaeger-ui</strong>: 查询结果展示</li>
</ul>
<p>jaeger-agent 和 jaeger-collecor 之间使用的是Uber自研的 <a href="https://github.com/uber/tchannel" target="_blank" rel="external">TChannel</a>协议</p>
<p>可以支持 Thrift 和 HTTP+JSON 等, 该协议的设计目标之一是将分布式追踪能力融入协议中, 为了实现这一目标，TChannel协议规范将追踪字段直接定义到了二进制格式中, 形如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spanid:<span class="number">8</span> parentid:<span class="number">8</span> traceid:<span class="number">8</span> traceflags:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>各字段含义如下:</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>spanid</td>
<td>int64</td>
<td>Span 标识</td>
</tr>
<tr>
<td>parentid</td>
<td>int64</td>
<td>父Span标识</td>
</tr>
<tr>
<td>traceid</td>
<td>int64</td>
<td>负责分配的原始操作方</td>
</tr>
<tr>
<td>traceflags</td>
<td>uint8</td>
<td>标志位</td>
</tr>
</tbody>
</table>
<h3 id="Jaeger-二进制部署"><a href="#Jaeger-二进制部署" class="headerlink" title="Jaeger 二进制部署"></a><strong>Jaeger 二进制部署</strong></h3><p><a href="https://www.jaegertracing.io/docs/1.11/deployment/" target="_blank" rel="external">Jaeger 官方文档</a></p>
<p><a href="https://github.com/jaegertracing/jaeger/releases" target="_blank" rel="external">Jaeger 二进制包下载地址</a></p>
<ul>
<li><p>Supervisor</p>
<p>使用Supervisor管理，主配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/supervisord.conf</span></span><br><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ; the path to the socket file</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ; main <span class="built_in">log</span> file; default <span class="variable">$CWD</span>/supervisord.log</span><br><span class="line">logfile_maxbytes=<span class="number">50</span>MB        ; max main logfile bytes b4 rotation; default <span class="number">50</span>MB</span><br><span class="line">logfile_backups=<span class="number">10</span>           ; <span class="comment"># of main logfile backups; 0 means none, default 10</span></span><br><span class="line">loglevel=info                ; <span class="built_in">log</span> level; default info; others: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ; supervisord pidfile; default supervisord.pid</span><br><span class="line">nodaemon=<span class="literal">false</span>               ; start <span class="keyword">in</span> foreground <span class="keyword">if</span> <span class="literal">true</span>; default <span class="literal">false</span></span><br><span class="line">minfds=<span class="number">655350</span>                  ; min. avail startup file descriptors; default <span class="number">1024</span></span><br><span class="line">minprocs=<span class="number">655350</span>                 ; min. avail process descriptors;default <span class="number">200</span></span><br><span class="line"></span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL  <span class="keyword">for</span> a unix socket</span><br><span class="line"></span><br><span class="line">[include]</span><br><span class="line">files = /etc/supervisord.d/*.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>jaeger-collect</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/supervisord.d/jaeger-collect.conf</span></span><br><span class="line">[program:jaeger-collect]</span><br><span class="line"><span class="built_in">command</span>     =  /usr/<span class="built_in">local</span>/jaeger/jaeger-collector --es.server-urls <span class="string">"http://192.168.1.180:9200"</span> --es.timeout <span class="number">30</span>s --es.num-replicas <span class="number">1</span> --es.num-shards <span class="number">5</span></span><br><span class="line">directory   = /usr/<span class="built_in">local</span>/jaeger/</span><br><span class="line">user        = root</span><br><span class="line">startsecs   = <span class="number">3</span></span><br><span class="line">stopwaitsecs= <span class="number">5</span></span><br><span class="line"></span><br><span class="line">redirect_stderr         = <span class="literal">true</span></span><br><span class="line">stdout_logfile_maxbytes = <span class="number">50</span>MB</span><br><span class="line">stdout_logfile_backups  = <span class="number">10</span></span><br><span class="line">stdout_logfile          = /var/<span class="built_in">log</span>/jaeger/jaeger-collect.log</span><br><span class="line">environment=SPAN_STORAGE_TYPE=<span class="string">"elasticsearch"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>jaeger-agent</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/supervisord.d/jaeger-agent.conf</span></span><br><span class="line">[program:jaeger-agent]</span><br><span class="line"><span class="built_in">command</span>     = /usr/<span class="built_in">local</span>/jaeger/jaeger-agent --collector.host-port=<span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">14267</span></span><br><span class="line">directory   = /usr/<span class="built_in">local</span>/jaeger/</span><br><span class="line">user        = root</span><br><span class="line">startsecs   = <span class="number">3</span></span><br><span class="line">stopwaitsecs= <span class="number">5</span></span><br><span class="line"></span><br><span class="line">redirect_stderr         = <span class="literal">true</span></span><br><span class="line">stdout_logfile_maxbytes = <span class="number">50</span>MB</span><br><span class="line">stdout_logfile_backups  = <span class="number">10</span></span><br><span class="line">stdout_logfile          = /var/<span class="built_in">log</span>/jaeger/jaeger-agent.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>jaeger-query</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/supervisord.d/jaeger-query.conf</span></span><br><span class="line">[program:jaeger-query]</span><br><span class="line"><span class="built_in">command</span>     =  /usr/<span class="built_in">local</span>/jaeger/jaeger-query --es.server-urls <span class="string">"http://192.168.1.180:9200"</span></span><br><span class="line">directory   = /usr/<span class="built_in">local</span>/jaeger/</span><br><span class="line">user        = root</span><br><span class="line">startsecs   = <span class="number">3</span></span><br><span class="line">stopwaitsecs= <span class="number">5</span></span><br><span class="line"></span><br><span class="line">redirect_stderr         = <span class="literal">true</span></span><br><span class="line">stdout_logfile_maxbytes = <span class="number">50</span>MB</span><br><span class="line">stdout_logfile_backups  = <span class="number">10</span></span><br><span class="line">stdout_logfile          = /var/<span class="built_in">log</span>/jaeger/jaeger-query.log</span><br><span class="line">environment=SPAN_STORAGE_TYPE=<span class="string">"elasticsearch"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Jaeger-Golang-Demo"><a href="#Jaeger-Golang-Demo" class="headerlink" title="Jaeger Golang Demo"></a><strong>Jaeger Golang Demo</strong></h3><p><a href="https://github.com/yurishkuro/opentracing-tutorial/tree/master/go" target="_blank" rel="external">OpenTracing Tutorial - Go</a></p>
<h4 id="初始化Jaeger"><a href="#初始化Jaeger" class="headerlink" title="初始化Jaeger"></a><strong>初始化Jaeger</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> InitJaeger(service <span class="typename">string</span>) (opentracing.Tracer, io.Closer) &#123;</span><br><span class="line">        cfg := &amp;config.Configuration&#123;</span><br><span class="line">            	<span class="comment">// 设置Sampler，此处为全量采集，按实际情况调整采集率</span></span><br><span class="line">                Sampler: &amp;config.SamplerConfig&#123;</span><br><span class="line">                        Type:  <span class="string">"const"</span>,		<span class="comment">// 全量采集策略</span></span><br><span class="line">                        Param: <span class="number">1</span>,			<span class="comment">// 0 or 1</span></span><br><span class="line">                &#125;,</span><br><span class="line">            	<span class="comment">// 设置Reporter</span></span><br><span class="line">                Reporter: &amp;config.ReporterConfig&#123;</span><br><span class="line">                        LogSpans:           <span class="constant">true</span>,</span><br><span class="line">                    	LocalAgentHostPort: <span class="string">":6831"</span>,	<span class="comment">// jaeger-agent IP:Port</span></span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 创建tracer</span></span><br><span class="line">        tracer, closer, err := cfg.New(service, config.Logger(jaeger.StdLogger))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"ERROR: can't init jaeger: %v\n"</span>, err))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tracer, closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>config.Configuration</code>结构体中最主要的是设置<code>Sampler</code>和<code>Reporter</code>。</p>
<ul>
<li><strong><code>Sampler</code></strong>：采集设置，对应结构体为<code>SamplerConfig</code>，提供4种采集策略(由<code>Type</code>值指定采集策略)：<ul>
<li><code>const</code>：全量采集(0/1)</li>
<li><code>probabilistic</code>：概率采集(0~1, 0.1表示10个trace中只采集1个)</li>
<li><code>rateLimiting</code>：限速采集，每秒采集设定的Span(e.g, 2表示每秒采集2个trace)</li>
<li><code>remote</code>： 动态采集，根据当前访问量调节采集策略(<a href="https://www.jaegertracing.io/docs/1.11/sampling/#adaptive-sampler" target="_blank" rel="external">adaptive sampler</a>)</li>
</ul>
</li>
<li><strong><code>Reporter</code></strong>：上报设置，对应结构体为<code>ReporterConfig</code>，提供2种上报方式：<ul>
<li><code>LocalAgentHostPort</code>：上报至jaeger-agent，设置其IP:Port</li>
<li><code>CollectorEndpoint</code>：上报至jaeger-collector，设置其IP:Port</li>
</ul>
</li>
</ul>
<h4 id="内部函数追踪"><a href="#内部函数追踪" class="headerlink" title="内部函数追踪"></a><strong>内部函数追踪</strong></h4><p>内部函数的追踪通过<code>context.Context</code>来实现span的传递</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">        <span class="comment">// 初始化并创建tracer</span></span><br><span class="line">        tracer, closer := tracing.InitJaeger(<span class="string">"inner"</span>)</span><br><span class="line">        <span class="keyword">defer</span> closer.Close()</span><br><span class="line">        <span class="comment">// opentracing.StartSpanFromContext()需要使用opentracing.SetGlobalTracer()创建新span</span></span><br><span class="line">        opentracing.SetGlobalTracer(tracer)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建root span</span></span><br><span class="line">        span := tracer.StartSpan(<span class="string">"RootSpanOpname"</span>)</span><br><span class="line">        <span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// span中设置tag/log</span></span><br><span class="line">        span.SetTag(<span class="string">"tayKey"</span>, <span class="string">"tagValue"</span>)</span><br><span class="line">        span.LogFields(</span><br><span class="line">            log.String(<span class="string">"event"</span>, <span class="string">"inner-call"</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用context.Context类型传输span</span></span><br><span class="line">        ctx := opentracing.ContextWithSpan(context.Background(), span)</span><br><span class="line">        <span class="comment">// 调用函数</span></span><br><span class="line">        CallService1(ctx, <span class="string">"callService1"</span>)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        <span class="comment">// 调用函数</span></span><br><span class="line">        CallService2(ctx, <span class="string">"callService2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>StartSpan(oprationName string, opts ...StartSpanOption) Span</code>方法创建RootSpan</p>
<p>调用<code>SetTag(key string, value interface{}) Span</code>方法设置tag</p>
<p>调用<code>LogFields(fields ...log.Field)</code>方法设置log</p>
<p>使用<code>opentracing.ContextWithSpan(ctx context.Context, span Span) context.Context</code>函数创建携带span的<code>Context</code>，通过将<code>Context</code>传递给被调函数来传递span</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> CallService1(ctx context.Context, request <span class="typename">string</span>) <span class="typename">string</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子Span</span></span><br><span class="line">        span, ctxService1 := opentracing.StartSpanFromContext(ctx, <span class="string">"Service1Opname"</span>)</span><br><span class="line">        <span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置tag</span></span><br><span class="line">        span.SetTag(<span class="string">"FuncName"</span>, <span class="string">"CallService1"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CallService1函数处理逻辑</span></span><br><span class="line">        fmt.Printf(<span class="string">"req: %v, requesting...\n"</span>, request)</span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">        response := <span class="string">"service1Response"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置log</span></span><br><span class="line">        span.LogFields(</span><br><span class="line">                log.String(<span class="string">"event"</span>, <span class="string">"service1-call"</span>),</span><br><span class="line">                log.String(<span class="string">"request"</span>, request),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用新函数，传入的Context为子Span的新Context</span></span><br><span class="line">        CallService2(ctxService1, <span class="string">"CallService2-2"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>StartSpanFromContext(ctx context.Context, operationName string, opts ...StartSpanOption) (Span, context.Context)</code>函数创建span</p>
<p>如果<code>ctx</code>中存在span，则创建的span为<code>ctx</code>span的子span，否则创建的是RootSpan</p>
<p><code>ctxService1</code>是新创建span的Context，如果<code>CallService1</code>需要调用其他函数创建子span，传递的Context应该为<code>ctxService1</code>而非传入的<code>ctx</code>参数</p>
<p><img src="https://raw.githubusercontent.com/moguol/blogImg/master/jaeger-inner.png" alt="jaeger-inner.png"></p>
<h4 id="HTTP请求跟踪"><a href="#HTTP请求跟踪" class="headerlink" title="HTTP请求跟踪"></a><strong>HTTP请求跟踪</strong></h4><p>HTTP请求的追踪是通过<code>Carrier(HTTP Header)</code>传递span，client通过<code>Inject()</code>函数将SpanContext注入到Carrier，再将Carrier写入到HTTP Header中，server通过<code>Extract()</code>函数从HTTP Header中提取SpanContext，从而实现请求跟踪。</p>
<p>client(:2333/http) —(内部调用)—&gt; CallHttpService1 —(远程调用)—&gt; HttpService1(:2334/httpService1)</p>
<ul>
<li><p>client</p>
<p>client的<code>http.HandleFunc(&quot;/http&quot;, func(w http.ResponseWriter, r *http.Request) {JaegerHttp(w, r, tracer)})</code>Handle函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client handle function</span></span><br><span class="line"><span class="keyword">func</span> JaegerHttp(w http.ResponseWriter, r *http.Request, tracer opentracing.Tracer) &#123;</span><br><span class="line">        <span class="comment">// 服务端从Carrier(http header)中提取span</span></span><br><span class="line">        spanCtx, _ := tracer.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(r.Header))</span><br><span class="line">        <span class="comment">// 创建span</span></span><br><span class="line">        <span class="comment">// ext.RPCServerOption() 如果SpanContext中client==nil，则创建的span为RootSpan</span></span><br><span class="line">        span := tracer.StartSpan(<span class="string">"jaegerHttpOpname"</span>, ext.RPCServerOption(spanCtx))</span><br><span class="line">        <span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置tag</span></span><br><span class="line">        span.SetTag(<span class="string">"httpKey"</span>, <span class="string">"httpValue"</span>)</span><br><span class="line">        <span class="comment">// 设置baggage</span></span><br><span class="line">        span.SetBaggageItem(<span class="string">"baggage"</span>, <span class="string">"123456789"</span>)</span><br><span class="line"></span><br><span class="line">        response := <span class="string">"Jaeger Http"</span></span><br><span class="line">        <span class="comment">// 设置log</span></span><br><span class="line">        span.LogFields(</span><br><span class="line">                log.String(<span class="string">"funcName"</span>, <span class="string">"JaegerHttp"</span>),</span><br><span class="line">                log.String(<span class="string">"response"</span>, response),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部函数间跟踪，使用context.Context类型传输span</span></span><br><span class="line">        ctx := opentracing.ContextWithSpan(context.Background(), span)</span><br><span class="line"></span><br><span class="line">        CallHttpService1(ctx)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        <span class="comment">//CallHttpService2(ctx)</span></span><br><span class="line"></span><br><span class="line">        w.Write([]<span class="typename">byte</span>(response))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CallHttpService1(client)</p>
<p>client <code>http.HandleFunc(&quot;/http&quot;, ...)</code>函数中调用<code>CallHttpService1()</code>函数请求<code>HttpService1</code>接口提供的服务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> CallHttpService1(ctx context.Context) &#123;</span><br><span class="line">        <span class="comment">// 创建子Span</span></span><br><span class="line">        span, _ := opentracing.StartSpanFromContext(ctx, <span class="string">"CallHttpService1Opname"</span>)</span><br><span class="line">        <span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置baggage</span></span><br><span class="line">        span.SetBaggageItem(<span class="string">"baggage1"</span>, <span class="string">"12345"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求设置</span></span><br><span class="line">        httpService1Url := <span class="string">"http://localhost:2334/httpService1"</span></span><br><span class="line">        req, err := http.NewRequest(<span class="string">"GET"</span>, httpService1Url, <span class="constant">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(err.Error())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向span中增加tag</span></span><br><span class="line">        ext.SpanKindRPCClient.Set(span)</span><br><span class="line">        ext.HTTPUrl.Set(span, httpService1Url)</span><br><span class="line">        ext.HTTPMethod.Set(span, <span class="string">"GET"</span>)</span><br><span class="line">        <span class="comment">// 向Carrier(http header)中添加span</span></span><br><span class="line">        span.Tracer().Inject(</span><br><span class="line">                span.Context(),</span><br><span class="line">                opentracing.HTTPHeaders,</span><br><span class="line">                opentracing.HTTPHeadersCarrier(req.Header),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求接口</span></span><br><span class="line">        httpClient := http.Client&#123;&#125;</span><br><span class="line">        resp, err := httpClient.Do(req)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">        body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置log</span></span><br><span class="line">        span.LogFields(</span><br><span class="line">                log.String(<span class="string">"body"</span>, <span class="typename">string</span>(body)),</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HttpService1(server)</p>
<p>server端注册<code>http.HandleFunc(&quot;/httpService1&quot;, ...)</code>路由，Handle处理函数<code>JaegerHttpService1()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> JaegerHttpService1(w http.ResponseWriter, r *http.Request, tracer opentracing.Tracer) &#123;</span><br><span class="line">        <span class="comment">// 服务端从Carrier(http header)中提取span</span></span><br><span class="line">        spanCtx, _ := tracer.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(r.Header))</span><br><span class="line">        <span class="comment">// 创建span</span></span><br><span class="line">        <span class="comment">// ext.RPCServerOption() 如果SpanContext中client==nil，则创建的span为RootSpan</span></span><br><span class="line">        span := tracer.StartSpan(<span class="string">"jaegerHttpService1Opname"</span>, ext.RPCServerOption(spanCtx))</span><br><span class="line">        <span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取baggage</span></span><br><span class="line">        baggage := span.BaggageItem(<span class="string">"baggage"</span>)</span><br><span class="line">        baggage1 := span.BaggageItem(<span class="string">"baggage1"</span>)</span><br><span class="line">        <span class="comment">// 设置tag</span></span><br><span class="line">        span.SetTag(<span class="string">"baggage"</span>, baggage)</span><br><span class="line">        span.SetTag(<span class="string">"baggage1"</span>, baggage1)</span><br><span class="line"></span><br><span class="line">        response := <span class="string">"Jaeger Http Service1"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置log</span></span><br><span class="line">        span.LogFields(</span><br><span class="line">                log.String(<span class="string">"funcName"</span>, <span class="string">"JaegerHttpService1"</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">        w.Write([]<span class="typename">byte</span>(response))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/moguol/blogImg/master/jaeger-http0.png" alt="jaeger-http0"></p>
<p><img src="https://raw.githubusercontent.com/moguol/blogImg/master/jaeger-http1.png" alt="jaeger-http1"></p>
<h4 id="gRPC请求跟踪"><a href="#gRPC请求跟踪" class="headerlink" title="gRPC请求跟踪"></a><strong>gRPC请求跟踪</strong></h4><p>此例子基于<a href="https://github.com/grpc/grpc-go/tree/master/examples/helloworld" target="_blank" rel="external">gRPC helloworld</a> 实现</p>
<p>gRPC同样需要通过<code>Carrier(metadata)</code>来传递Span，client通过<code>Inject()</code>函数将SpanContext注入到<code>Carrier</code>中，再将<code>Carrier</code>写入到metadata中，server通过<code>Extract()</code>函数从metadata中提取SpanContext</p>
<ul>
<li><p>protobuf</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协议版本</span></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> protos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务及方法</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义SayHello方法, 接收HelloRequest参数, 返回HelloReply</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义传入参数</span><br><span class="line">// protoc根据此生成HelloRequest结构体，包含元素Name</span><br><span class="line">// type HelloRequest struct &#123;</span><br><span class="line">//      Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`</span><br><span class="line">//      XXX_NoUnkeyedLiteral struct&#123;&#125; `json:"-"`</span><br><span class="line">//      XXX_unrecognized     []byte   `json:"-"`</span><br><span class="line">//      XXX_sizecache        int32    `json:"-"`</span><br><span class="line">// &#125;</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">    string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义返回参数</span></span><br><span class="line"><span class="comment">// protoc根据此生成HelloReply结构体，包含元素Msg</span></span><br><span class="line"><span class="comment">//type HelloReply struct &#123;</span></span><br><span class="line"><span class="comment">//      Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`</span></span><br><span class="line"><span class="comment">//      <span class="label">XXX_NoUnkeyedLiteral struct&#123;&#125; `json:"-"`</span></span></span><br><span class="line"><span class="comment">//      <span class="label">XXX_unrecognized     []byte   `json:"-"`</span></span></span><br><span class="line"><span class="comment">//      <span class="label">XXX_sizecache        int32    `json:"-"`</span></span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> msg = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>client</p>
<p>client通过<code>Inject()</code>函数将SpanContext注入到Carrier(metadata)中，此操作在client调用<code>grpc.Dial()</code>函数时设置拦截器完成<code>grpc.Dial(address, grpc.WithInsecure(), grpc.WithUnaryInterceptor(gRPCClientInterceptor(tracer)))</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	address     = <span class="string">"localhost:50051"</span></span><br><span class="line">	defaultName = <span class="string">"World"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mdWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	metadata.MD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// opentracing.TextMapWriter method</span></span><br><span class="line"><span class="comment">// 重写Set()方法，将carrier写入metadata(key/value写入到metadata)</span></span><br><span class="line"><span class="keyword">func</span> (mrw mdWriter) Set(key, value <span class="typename">string</span>) &#123;</span><br><span class="line">	mrw.MD[key] = <span class="built_in">append</span>(mrw.MD[key], value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Span注入到metadata</span></span><br><span class="line"><span class="keyword">func</span> InjectClientSpanToMetadata(ctx context.Context, tracer opentracing.Tracer, clientSpan opentracing.Span) (context.Context, error) &#123;</span><br><span class="line">	<span class="comment">// 从context中获取metadata</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		md = metadata.New(<span class="constant">nil</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 不能对md直接进行修改，会产生竞争，需要拷贝然后对副本就行修改</span></span><br><span class="line">		md = md.Copy()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将SpanContext注入到carrier(metadata)中</span></span><br><span class="line">	carrier := mdWriter&#123;md&#125;</span><br><span class="line">	err := tracer.Inject(clientSpan.Context(), opentracing.TextMap, carrier)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ctx, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> metadata.NewOutgoingContext(ctx, md), <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写client interceptor 以传输数据</span></span><br><span class="line"><span class="keyword">func</span> gRPCClientInterceptor(tracer opentracing.Tracer) grpc.UnaryClientInterceptor &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">func</span>(</span><br><span class="line">		ctx context.Context,</span><br><span class="line">		method <span class="typename">string</span>,</span><br><span class="line">		req, reply <span class="keyword">interface</span>&#123;&#125;,</span><br><span class="line">		cc *grpc.ClientConn,</span><br><span class="line">		invoker grpc.UnaryInvoker,</span><br><span class="line">		opts ...grpc.CallOption,</span><br><span class="line">	) error &#123;</span><br><span class="line">		<span class="comment">// 尝试从context中获取父span</span></span><br><span class="line">		<span class="keyword">var</span> parentCtx opentracing.SpanContext</span><br><span class="line">		<span class="keyword">if</span> parentSpan := opentracing.SpanFromContext(ctx); parentSpan != <span class="constant">nil</span> &#123;</span><br><span class="line">			parentCtx = parentSpan.Context()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建client span</span></span><br><span class="line">		clientSpan := tracer.StartSpan(</span><br><span class="line">			method,</span><br><span class="line">			opentracing.ChildOf(parentCtx),</span><br><span class="line">			ext.SpanKindRPCClient,</span><br><span class="line">			opentracing.Tag&#123;Key: <span class="typename">string</span>(ext.Component), Value: <span class="string">"gRPC"</span>&#125;,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">defer</span> clientSpan.Finish()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置baggage</span></span><br><span class="line">		clientSpan.SetBaggageItem(<span class="string">"baggage"</span>, <span class="string">"gRPC-Baggage"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将SpanContext注入到metadata</span></span><br><span class="line">		newCtx, err := InjectClientSpanToMetadata(ctx, tracer, clientSpan)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"inject to metadata err %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = invoker(newCtx, method, req, reply, cc, opts...)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"SpanContext inject to metadata failed: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="comment">// 初始化并创建tracer</span></span><br><span class="line">	tracer, closer := tracing.InitJaeger(<span class="string">"jaeger-gRPC-client"</span>)</span><br><span class="line">	<span class="keyword">defer</span> closer.Close()</span><br><span class="line">	<span class="comment">// opentracing.StartSpanFromContext()需要使用opentracing.SetGlobalTracer()创建新span</span></span><br><span class="line">	opentracing.SetGlobalTracer(tracer)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 与server建立连接</span></span><br><span class="line">	conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithUnaryInterceptor(gRPCClientInterceptor(tracer)))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">"can't connect to the server: %v"</span>, address)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// new client</span></span><br><span class="line">	client := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	name := defaultName</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		name = os.Args[<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接server调用SayHello()函数</span></span><br><span class="line">	resp, err := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">"client call SayHello() failed: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"server response: %v"</span>, resp.Msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>server</p>
<p>server通过<code>Extract()</code>函数从Carrier(metadata)中提取SpanContext，此操作在调用<code>grpc.NewServer()</code>时设置拦截器实现<code>grpc.NewServer(grpc.UnaryInterceptor(gRPCServerInterceptor(tracer)))</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mdReader <span class="keyword">struct</span> &#123;</span><br><span class="line">	metadata.MD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// opentracing.TextMapReader method</span></span><br><span class="line"><span class="comment">// 读取metadata中的所有span</span></span><br><span class="line"><span class="keyword">func</span> (mdr mdReader) ForeachKey(handler <span class="keyword">func</span>(key, value <span class="typename">string</span>) error) error &#123;</span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> mdr.MD &#123;</span><br><span class="line">		<span class="keyword">for</span> _, val := <span class="keyword">range</span> value &#123;</span><br><span class="line">			<span class="keyword">if</span> err := handler(key, val); err != <span class="constant">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从metadata提取SpanContext</span></span><br><span class="line"><span class="keyword">func</span> ExtractSpanFromMetadata(ctx context.Context, tracer opentracing.Tracer) (opentracing.SpanContext, error) &#123;</span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		md = metadata.New(<span class="constant">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	carrier := mdReader&#123;md&#125;</span><br><span class="line">	spanContext, err := tracer.Extract(opentracing.TextMap, carrier)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> spanContext, err</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写server interceptor 以传输数据</span></span><br><span class="line"><span class="keyword">func</span> gRPCServerInterceptor(tracer opentracing.Tracer) grpc.UnaryServerInterceptor &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">func</span>(</span><br><span class="line">		ctx context.Context,</span><br><span class="line">		req <span class="keyword">interface</span>&#123;&#125;,</span><br><span class="line">		info *grpc.UnaryServerInfo,</span><br><span class="line">		handler grpc.UnaryHandler,</span><br><span class="line">	) (resp <span class="keyword">interface</span>&#123;&#125;, err error) &#123;</span><br><span class="line">		<span class="comment">// 从metadata中提取spanContext</span></span><br><span class="line">		spanContext, err := ExtractSpanFromMetadata(ctx, tracer)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"Extract from metadata failed: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建server span</span></span><br><span class="line">		serverSpan := tracer.StartSpan(</span><br><span class="line">			info.FullMethod,</span><br><span class="line">			ext.RPCServerOption(spanContext),</span><br><span class="line">			ext.SpanKindRPCServer,</span><br><span class="line">			opentracing.Tag&#123;Key: <span class="typename">string</span>(ext.Component), Value: <span class="string">"gRPC"</span>&#125;,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">defer</span> serverSpan.Finish()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取baggage，设置tag</span></span><br><span class="line">		baggage := serverSpan.BaggageItem(<span class="string">"baggage"</span>)</span><br><span class="line">		serverSpan.SetTag(<span class="string">"baggage"</span>, baggage)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建新context</span></span><br><span class="line">		newCtx := opentracing.ContextWithSpan(ctx, serverSpan)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> handler(newCtx, req)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/moguol/blogImg/master/jaeger-gRPC.png" alt="jaeger-gRPC"></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="OpenTracing"><a href="#OpenTracing" class="headerlink" title="OpenTracing"></a><strong>OpenTracing</strong></h2><h3 id="微服务诊断分析系统"><]]>
    </summary>
    
      <category term="GO" scheme="http://yoursite.com/tags/GO/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RedisCluster]]></title>
    <link href="http://yoursite.com/2018/12/05/redis-cluster/"/>
    <id>http://yoursite.com/2018/12/05/redis-cluster/</id>
    <published>2018-12-05T07:45:33.000Z</published>
    <updated>2019-04-21T14:46:01.479Z</updated>
    <content type="html"><![CDATA[<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a><strong>基础概念</strong></h3><h4 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a><strong>Slot</strong></h4><p>RedisCluster将key分成<strong>16384</strong>个slot。key和slot的映射关系如下: (CRC16是一种冗余码校验和，可将字符串转换成16位的数字)</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot = CRC16(key) mod <span class="number">16384</span></span><br></pre></td></tr></table></figure>
<p>因为有slot的存在，所以multi-key操作(scan/mget/keys…)无法支持。为此RedisCluster提供<strong><code>hash tags</code></strong>，用于确保多个key能被分配到同一个slot中，并可支持multi-key操作。但<code>hash tags</code>容易引起数据倾斜，需谨慎。直接在key前加入<strong><code>{hash_tag}</code></strong>即可，如：<code>{foo}student</code></p>
<h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a><strong>Gossip协议</strong></h4><p>RedisCluster通过gossip协议，实现集群间状态同步更新、选举自助failover等重要的集群功能。</p>
<p>gossip协议包含多种消息：(RedisCluster使用<code>redis_port+10000</code>端口作为node间通信端口)</p>
<ul>
<li><code>meet</code>: 某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信</li>
<li><code>ping</code>: 每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据</li>
<li><code>pong</code>: 应答ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新</li>
<li><code>fail</code>: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了s</li>
</ul>
<h4 id="Failover机制"><a href="#Failover机制" class="headerlink" title="Failover机制"></a><strong>Failover机制</strong></h4><p>failover是RedisCluster提供的容错机制，failover支持两种方式：</p>
<ul>
<li>故障failover: 自动恢复集群可用性</li>
<li>人为failover: 手动操作恢复集群可用性</li>
</ul>
<p>fail探测：</p>
<ul>
<li>node在<code>node timeout</code>时间内没有响应PING请求，则被标记为 <code>PFAIL</code></li>
<li><code>PFAIL</code>标记随着gossip传播</li>
<li>过半node都标记<code>PFAIL</code>，则更改node状态为<code>FAIL</code>并广播消息</li>
</ul>
<p>故障failover过程：</p>
<ul>
<li>slave探测到master为<code>FAIL</code></li>
<li>slave将记录的<code>currentEpoch + 1</code>，并广播<code>Failover Request</code>消息</li>
<li>所有node接收到广播消息，只有master能响应，判断合法性，合法则发送<code>FAILOVER_AUTH_ACK</code></li>
<li>slave收集<code>FAILOVER_AUTH_ACK</code>消息，过半同意则升级为master</li>
<li>成功升级为master后通过PONG消息通知所有node</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><h4 id="系统参数优化"><a href="#系统参数优化" class="headerlink" title="系统参数优化"></a><strong>系统参数优化</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.overcommit_memory=<span class="number">1</span></span><br><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a><strong>依赖</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install zlib zlib-devel openssl openssl-devel gcc gcc-c++</span><br></pre></td></tr></table></figure>
<h4 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a><strong>ruby</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget -O ruby-<span class="number">2.4</span>.<span class="number">4</span>.tar.gz <span class="string">'https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.4.tar.gz'</span> --no-check-certificate</span><br><span class="line">tar -zxf ruby-<span class="number">2.4</span>.<span class="number">4</span>.tar.gz &amp;&amp; <span class="built_in">cd</span> ruby-<span class="number">2.4</span>.<span class="number">4</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/ruby</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=/usr/local/redis-cluster/bin:/usr/local/tcl/bin:/usr/local/rubygems/bin:/usr/local/ruby/bin:$PATH'</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br><span class="line">ruby <span class="number">2.4</span>.<span class="number">4</span>p296 (<span class="number">2018</span>-<span class="number">03</span>-<span class="number">28</span> revision <span class="number">63013</span>) [x86_64-linux]</span><br></pre></td></tr></table></figure>
<h4 id="rubygems"><a href="#rubygems" class="headerlink" title="rubygems"></a><strong>rubygems</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -O rubygems-<span class="number">2.7</span>.<span class="number">6</span>.tgz <span class="string">'https://rubygems.org/rubygems/rubygems-2.7.6.tgz'</span> --no-check-certificate</span><br><span class="line">tar -zxf rubygems-<span class="number">2.7</span>.<span class="number">6</span>.tgz</span><br><span class="line">mv rubygems-<span class="number">2.7</span>.<span class="number">6</span> /usr/<span class="built_in">local</span>/rubygems</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rubygems &amp;&amp; ruby setup.rb</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gem -v</span><br><span class="line"><span class="number">2.7</span>.<span class="number">6</span></span><br></pre></td></tr></table></figure>
<h4 id="redis-gem"><a href="#redis-gem" class="headerlink" title="redis.gem"></a><strong>redis.gem</strong></h4><p><strong>redis-4.x.x.gem 有bug！不能进行扩容/缩容<code>reshard|rebalance</code>, 报错<code>Syntax error ,try CLIENT (LIST|KILL|GETNAME|SETNAME|PAUSE|REPLY)</code></strong></p>
<p><strong>安装redis-3.x.x.gem版本可调用<code>reshard|rebalance</code>但不支持密码，不适用于有密码验证的集群</strong></p>
<ul>
<li><p>4.x.x 版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -O redis-<span class="number">4.0</span>.<span class="number">2</span>.gem <span class="string">'https://rubygems.org/downloads/redis-4.0.2.gem'</span> --no-check-certificate</span><br><span class="line">gem install <span class="operator">-l</span> redis-<span class="number">4.0</span>.<span class="number">2</span>.gem</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gem list redis</span><br><span class="line"></span><br><span class="line">*** LOCAL GEMS ***</span><br><span class="line"></span><br><span class="line">redis (<span class="number">4.0</span>.<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.x.x 版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gem uninstall redis --version 4.0.2</span></span><br><span class="line">wget -O redis-<span class="number">3.3</span>.<span class="number">3</span>.gem <span class="string">'https://rubygems.org/downloads/redis-3.3.3.gem'</span> --no-check-certificate</span><br><span class="line">gem install <span class="operator">-l</span> redis-<span class="number">3.3</span>.<span class="number">3</span>.gem</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="tcl"><a href="#tcl" class="headerlink" title="tcl"></a><strong>tcl</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -O tcl868-src.zip <span class="string">'https://jaist.dl.sourceforge.net/project/tcl/Tcl/8.6.8/tcl868-src.zip'</span> --no-check-certificate</span><br><span class="line">unzip tcl868-src.zip &amp;&amp; <span class="built_in">cd</span> tcl8.<span class="number">6.8</span>/unix</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/tcl</span><br><span class="line">make &amp;&amp; make install &amp;&amp; make install-private-headers</span><br><span class="line">ln <span class="operator">-s</span> /usr/<span class="built_in">local</span>/tcl/bin/tclsh8.<span class="number">6</span> /usr/<span class="built_in">local</span>/tcl/bin/tclsh</span><br></pre></td></tr></table></figure>
<h4 id="redis-4-0-11"><a href="#redis-4-0-11" class="headerlink" title="redis-4.0.11"></a><strong>redis-4.0.11</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -O redis-<span class="number">4.0</span>.<span class="number">11</span>.tar.gz <span class="string">'http://download.redis.io/releases/redis-4.0.11.tar.gz'</span></span><br><span class="line">tar -zxf redis-<span class="number">4.0</span>.<span class="number">11</span>.tar.gz &amp;&amp; <span class="built_in">cd</span> redis-<span class="number">4.0</span>.<span class="number">11</span></span><br><span class="line">make &amp;&amp; make PREFIX=/usr/<span class="built_in">local</span>/redis-cluster install</span><br><span class="line">cp src/redis-trib.rb /usr/<span class="built_in">local</span>/redis-cluster/bin</span><br><span class="line">chown -R redis:redis /usr/<span class="built_in">local</span>/redis-cluster</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - redis -c <span class="string">"mkdir -p /usr/local/redis-cluster/conf /data/logs/redis/ /data/redis/&#123;8000,8001,8002&#125;"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/local/redis-cluster/redis.conf</span></span><br><span class="line"><span class="built_in">bind</span> <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">protected-mode no</span><br><span class="line">port <span class="number">6379</span></span><br><span class="line">tcp-backlog <span class="number">511</span></span><br><span class="line">timeout <span class="number">300</span></span><br><span class="line">tcp-keepalive <span class="number">300</span></span><br><span class="line">daemonize yes</span><br><span class="line">supervised no</span><br><span class="line">pidfile nodes.pid</span><br><span class="line">loglevel notice</span><br><span class="line">logfile nodes.log</span><br><span class="line">databases <span class="number">16</span></span><br><span class="line">always-show-logo yes</span><br><span class="line">save <span class="string">""</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir ./</span><br><span class="line">masterauth <span class="string">"&lt;password&gt;"</span></span><br><span class="line">requirepass <span class="string">"&lt;password&gt;"</span></span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line">slave-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-sync-delay <span class="number">5</span></span><br><span class="line">repl-timeout <span class="number">120</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">repl-backlog-size <span class="number">100</span>mb</span><br><span class="line">slave-priority <span class="number">100</span></span><br><span class="line">rename-command flushdb rflushdb</span><br><span class="line">rename-command flushall rflushall</span><br><span class="line">rename-command keys rkeys</span><br><span class="line">rename-command shutdown rshutdown</span><br><span class="line">rename-command config rconfig</span><br><span class="line">rename-command slaveof rslaveof</span><br><span class="line">rename-command sync rsync</span><br><span class="line">rename-command monitor rmonitor</span><br><span class="line">rename-command save rsave</span><br><span class="line">rename-command bgsave rbgsave</span><br><span class="line">rename-command bgrewriteaof rbgrewriteaof</span><br><span class="line">maxmemory <span class="number">5</span>gb</span><br><span class="line"><span class="comment">#maxclients 10000</span></span><br><span class="line">maxmemory-policy volatile-lru</span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">slave-lazy-flush no</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line">appendfsync no</span><br><span class="line">no-appendfsync-on-rewrite yes</span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line">auto-aof-rewrite-min-size <span class="number">1</span>gb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line">lua-time-limit <span class="number">5000</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout <span class="number">15000</span></span><br><span class="line">cluster-slave-validity-factor <span class="number">0</span></span><br><span class="line">cluster-migration-barrier <span class="number">1</span></span><br><span class="line">cluster-require-full-coverage no</span><br><span class="line">slowlog-log-slower-than <span class="number">10000</span></span><br><span class="line">slowlog-max-len <span class="number">10000</span></span><br><span class="line">latency-monitor-threshold <span class="number">0</span></span><br><span class="line">notify-keyspace-events <span class="string">""</span></span><br><span class="line"><span class="built_in">hash</span>-max-ziplist-entries <span class="number">512</span></span><br><span class="line"><span class="built_in">hash</span>-max-ziplist-value <span class="number">64</span></span><br><span class="line">list-max-ziplist-size -<span class="number">2</span></span><br><span class="line">list-compress-depth <span class="number">0</span></span><br><span class="line"><span class="built_in">set</span>-max-intset-entries <span class="number">512</span></span><br><span class="line">zset-max-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-max-ziplist-value <span class="number">64</span></span><br><span class="line">hll-sparse-max-bytes <span class="number">3000</span></span><br><span class="line">activerehashing yes</span><br><span class="line">client-output-buffer-limit normal <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">client-output-buffer-limit slave <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></span><br><span class="line">client-output-buffer-limit pubsub <span class="number">32</span>mb <span class="number">8</span>mb <span class="number">60</span></span><br><span class="line">hz <span class="number">10</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/local/redis-cluster/conf/8000.conf</span></span><br><span class="line">include /usr/<span class="built_in">local</span>/redis-cluster/redis.conf</span><br><span class="line">port <span class="number">8000</span></span><br><span class="line">dir <span class="string">"/data/redis/8000"</span></span><br><span class="line">logfile <span class="string">"/data/logs/redis/8000.log"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/local/redis-cluster/conf/8001.conf</span></span><br><span class="line">include /usr/<span class="built_in">local</span>/redis-cluster/redis.conf</span><br><span class="line">port <span class="number">8001</span></span><br><span class="line">dir <span class="string">"/data/redis/8001"</span></span><br><span class="line">logfile <span class="string">"/data/logs/redis/redis_8001.log"</span></span><br></pre></td></tr></table></figure>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h3><h4 id="启动redis实例"><a href="#启动redis实例" class="headerlink" title="启动redis实例"></a><strong>启动redis实例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su - redis -c <span class="string">"/usr/local/redis-cluster/bin/redis-server /usr/local/redis-cluster/conf/8000.conf"</span></span><br><span class="line">su - redis -c <span class="string">"/usr/local/redis-cluster/bin/redis-server /usr/local/redis-cluster/conf/8001.conf"</span></span><br><span class="line">su - redis -c <span class="string">"/usr/local/redis-cluster/bin/redis-server /usr/local/redis-cluster/conf/8002.conf"</span></span><br><span class="line">su - redis -c <span class="string">"/usr/local/redis-cluster/bin/redis-server /usr/local/redis-cluster/conf/8003.conf"</span></span><br></pre></td></tr></table></figure>
<h4 id="创建redis-cluster"><a href="#创建redis-cluster" class="headerlink" title="创建redis cluster"></a><strong>创建redis cluster</strong></h4><ul>
<li><p>iptables</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport <span class="number">8000</span>:<span class="number">8006</span> -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport <span class="number">18000</span>:<span class="number">18006</span> -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改:password</span></span><br><span class="line">/usr/<span class="built_in">local</span>/ruby/lib/ruby/gems/<span class="number">2.4</span>.<span class="number">0</span>/gems/redis-<span class="number">4.0</span>.<span class="number">2</span>/lib/redis/client.rb</span><br><span class="line"><span class="comment">#/usr/local/ruby/lib/ruby/gems/2.4.0/gems/redis-3.3.3/lib/redis/client.rb</span></span><br><span class="line"></span><br><span class="line">    DEFAULTS = &#123;</span><br><span class="line">      :url =&gt; lambda &#123; ENV[<span class="string">"REDIS_URL"</span>] &#125;,</span><br><span class="line">      :scheme =&gt; <span class="string">"redis"</span>,</span><br><span class="line">      :host =&gt; <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      :port =&gt; <span class="number">6379</span>,</span><br><span class="line">      :path =&gt; nil,</span><br><span class="line">      :timeout =&gt; <span class="number">5.0</span>,</span><br><span class="line">      :password =&gt; nil,		<span class="comment">#修改此处</span></span><br><span class="line">      :db =&gt; <span class="number">0</span>,</span><br><span class="line">      :driver =&gt; nil,</span><br><span class="line">      :id =&gt; nil,</span><br><span class="line">      :tcp_keepalive =&gt; <span class="number">0</span>,</span><br><span class="line">      :reconnect_attempts =&gt; <span class="number">1</span>,</span><br><span class="line">      :inherit_socket =&gt; <span class="literal">false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建集群</p>
<ul>
<li><p>自动分配主从角色</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb create --replicas <span class="number">1</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span> <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8003</span> <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8004</span> <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8005</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>手动分配主从角色</p>
<ul>
<li><p>创建master</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb create <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on <span class="number">3</span> nodes...</span><br><span class="line">Using <span class="number">3</span> masters:</span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span></span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span></span><br><span class="line">M: <span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line">   slots:<span class="number">0</span>-<span class="number">5460</span> (<span class="number">5461</span> slots) master</span><br><span class="line">M: <span class="number">605950</span>ea5c2214f50d5f3dddd87c80f4e7d1b631 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span></span><br><span class="line">   slots:<span class="number">5461</span>-<span class="number">10922</span> (<span class="number">5462</span> slots) master</span><br><span class="line">M: a923e10183ef356bcadc1566503be4ab1ea1adb6 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span></span><br><span class="line">   slots:<span class="number">10923</span>-<span class="number">16383</span> (<span class="number">5461</span> slots) master</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">'yes'</span> to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span>)</span><br><span class="line">M: <span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line">   slots:<span class="number">0</span>-<span class="number">5460</span> (<span class="number">5461</span> slots) master</span><br><span class="line">   <span class="number">0</span> additional replica(s)</span><br><span class="line">M: <span class="number">605950</span>ea5c2214f50d5f3dddd87c80f4e7d1b631 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span></span><br><span class="line">   slots:<span class="number">5461</span>-<span class="number">10922</span> (<span class="number">5462</span> slots) master</span><br><span class="line">   <span class="number">0</span> additional replica(s)</span><br><span class="line">M: a923e10183ef356bcadc1566503be4ab1ea1adb6 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span></span><br><span class="line">   slots:<span class="number">10923</span>-<span class="number">16383</span> (<span class="number">5461</span> slots) master</span><br><span class="line">   <span class="number">0</span> additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All <span class="number">16384</span> slots covered.</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建slave</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加slave：将192.168.1.181:8003加入到192.168.1.180:8000集群中，并且作为指定&lt;node_id&gt;的slave</span></span><br><span class="line">redis-trib.rb add-node --slave --master-id <span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8003</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Adding node <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8003</span> to cluster <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span>)</span><br><span class="line">M: <span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line">   slots:<span class="number">0</span>-<span class="number">5460</span> (<span class="number">5461</span> slots) master</span><br><span class="line">   <span class="number">0</span> additional replica(s)</span><br><span class="line">M: <span class="number">605950</span>ea5c2214f50d5f3dddd87c80f4e7d1b631 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span></span><br><span class="line">   slots:<span class="number">5461</span>-<span class="number">10922</span> (<span class="number">5462</span> slots) master</span><br><span class="line">   <span class="number">0</span> additional replica(s)</span><br><span class="line">M: a923e10183ef356bcadc1566503be4ab1ea1adb6 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span></span><br><span class="line">   slots:<span class="number">10923</span>-<span class="number">16383</span> (<span class="number">5461</span> slots) master</span><br><span class="line">   <span class="number">0</span> additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All <span class="number">16384</span> slots covered.</span><br><span class="line">&gt;&gt;&gt; Send CLUSTER MEET to node <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8003</span> to make it join the cluster.</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join...</span><br><span class="line">&gt;&gt;&gt; Configure node as replica of <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span>.</span><br><span class="line">[OK] New node added correctly.</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb add-node --slave --master-id <span class="number">605950</span>ea5c2214f50d5f3dddd87c80f4e7d1b631 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8004</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line"></span><br><span class="line">redis-trib.rb add-node --slave --master-id a923e10183ef356bcadc1566503be4ab1ea1adb6 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8005</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看集群信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb check <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span>)M: <span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line">   slots:<span class="number">0</span>-<span class="number">5460</span> (<span class="number">5461</span> slots) master</span><br><span class="line">   <span class="number">1</span> additional replica(s)</span><br><span class="line">S: dea85bf87e560b6a5074f60965b8ad334bfeb5e8 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8004</span></span><br><span class="line">   slots: (<span class="number">0</span> slots) slave</span><br><span class="line">   replicates <span class="number">605950</span>ea5c2214f50d5f3dddd87c80f4e7d1b631</span><br><span class="line">M: a923e10183ef356bcadc1566503be4ab1ea1adb6 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span></span><br><span class="line">   slots:<span class="number">10923</span>-<span class="number">16383</span> (<span class="number">5461</span> slots) master</span><br><span class="line">   <span class="number">1</span> additional replica(s)</span><br><span class="line">M: <span class="number">605950</span>ea5c2214f50d5f3dddd87c80f4e7d1b631 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span></span><br><span class="line">   slots:<span class="number">5461</span>-<span class="number">10922</span> (<span class="number">5462</span> slots) master</span><br><span class="line">   <span class="number">1</span> additional replica(s)</span><br><span class="line">S: <span class="number">6</span>f12a4c4e1c60f435f68fbce1b72dc60ac73de83 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8005</span></span><br><span class="line">   slots: (<span class="number">0</span> slots) slave</span><br><span class="line">   replicates a923e10183ef356bcadc1566503be4ab1ea1adb6</span><br><span class="line">S: <span class="number">74</span>bfaa76306dd6bc59e559d012203ceed2a8ab24 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8003</span></span><br><span class="line">   slots: (<span class="number">0</span> slots) slave</span><br><span class="line">   replicates <span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All <span class="number">16384</span> slots covered.</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span>&gt; CLUSTER NODES</span><br><span class="line">dea85bf87e560b6a5074f60965b8ad334bfeb5e8 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8004</span>@<span class="number">18004</span> slave <span class="number">605950</span>ea5c2214f50d5f3dddd87c80f4e7d1b631 <span class="number">0</span> <span class="number">1541155161000</span> <span class="number">2</span> connected</span><br><span class="line"><span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span>@<span class="number">18000</span> myself,master - <span class="number">0</span> <span class="number">1541155160000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line">a923e10183ef356bcadc1566503be4ab1ea1adb6 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span>@<span class="number">18002</span> master - <span class="number">0</span> <span class="number">1541155162973</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br><span class="line"><span class="number">605950</span>ea5c2214f50d5f3dddd87c80f4e7d1b631 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span>@<span class="number">18001</span> master - <span class="number">0</span> <span class="number">1541155160000</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line"><span class="number">6</span>f12a4c4e1c60f435f68fbce1b72dc60ac73de83 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8005</span>@<span class="number">18005</span> slave a923e10183ef356bcadc1566503be4ab1ea1adb6 <span class="number">0</span> <span class="number">1541155162000</span> <span class="number">3</span> connected</span><br><span class="line"><span class="number">74</span>bfaa76306dd6bc59e559d012203ceed2a8ab24 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8003</span>@<span class="number">18003</span> slave <span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47 <span class="number">0</span> <span class="number">1541155162000</span> <span class="number">1</span> connected</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span>&gt; CLUSTER INFO</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:<span class="number">16384</span></span><br><span class="line">cluster_slots_ok:<span class="number">16384</span></span><br><span class="line">cluster_slots_pfail:<span class="number">0</span></span><br><span class="line">cluster_slots_fail:<span class="number">0</span></span><br><span class="line">cluster_known_nodes:<span class="number">6</span></span><br><span class="line">cluster_size:<span class="number">3</span></span><br><span class="line">cluster_current_epoch:<span class="number">3</span></span><br><span class="line">cluster_my_epoch:<span class="number">1</span></span><br><span class="line">cluster_stats_messages_ping_sent:<span class="number">1756</span></span><br><span class="line">cluster_stats_messages_pong_sent:<span class="number">1713</span></span><br><span class="line">cluster_stats_messages_sent:<span class="number">3469</span></span><br><span class="line">cluster_stats_messages_ping_received:<span class="number">1708</span></span><br><span class="line">cluster_stats_messages_pong_received:<span class="number">1756</span></span><br><span class="line">cluster_stats_messages_meet_received:<span class="number">5</span></span><br><span class="line">cluster_stats_messages_received:<span class="number">3469</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span>&gt; CLUSTER SLOTS</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) (<span class="built_in">integer</span>) <span class="number">0</span></span><br><span class="line">   <span class="number">2</span>) (<span class="built_in">integer</span>) <span class="number">5460</span></span><br><span class="line">   <span class="number">3</span>) <span class="number">1</span>) <span class="string">"192.168.1.180"</span></span><br><span class="line">      <span class="number">2</span>) (<span class="built_in">integer</span>) <span class="number">8000</span></span><br><span class="line">      <span class="number">3</span>) <span class="string">"673e32925e0a6f9beefac8aeaad8a397758c5e47"</span></span><br><span class="line">   <span class="number">4</span>) <span class="number">1</span>) <span class="string">"192.168.1.181"</span></span><br><span class="line">      <span class="number">2</span>) (<span class="built_in">integer</span>) <span class="number">8003</span></span><br><span class="line">      <span class="number">3</span>) <span class="string">"74bfaa76306dd6bc59e559d012203ceed2a8ab24"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) (<span class="built_in">integer</span>) <span class="number">10923</span></span><br><span class="line">   <span class="number">2</span>) (<span class="built_in">integer</span>) <span class="number">16383</span></span><br><span class="line">   <span class="number">3</span>) <span class="number">1</span>) <span class="string">"192.168.1.180"</span></span><br><span class="line">      <span class="number">2</span>) (<span class="built_in">integer</span>) <span class="number">8002</span></span><br><span class="line">      <span class="number">3</span>) <span class="string">"a923e10183ef356bcadc1566503be4ab1ea1adb6"</span></span><br><span class="line">   <span class="number">4</span>) <span class="number">1</span>) <span class="string">"192.168.1.181"</span></span><br><span class="line">      <span class="number">2</span>) (<span class="built_in">integer</span>) <span class="number">8005</span></span><br><span class="line">      <span class="number">3</span>) <span class="string">"6f12a4c4e1c60f435f68fbce1b72dc60ac73de83"</span></span><br><span class="line"><span class="number">3</span>) <span class="number">1</span>) (<span class="built_in">integer</span>) <span class="number">5461</span></span><br><span class="line">   <span class="number">2</span>) (<span class="built_in">integer</span>) <span class="number">10922</span></span><br><span class="line">   <span class="number">3</span>) <span class="number">1</span>) <span class="string">"192.168.1.180"</span></span><br><span class="line">      <span class="number">2</span>) (<span class="built_in">integer</span>) <span class="number">8001</span></span><br><span class="line">      <span class="number">3</span>) <span class="string">"605950ea5c2214f50d5f3dddd87c80f4e7d1b631"</span></span><br><span class="line">   <span class="number">4</span>) <span class="number">1</span>) <span class="string">"192.168.1.181"</span></span><br><span class="line">      <span class="number">2</span>) (<span class="built_in">integer</span>) <span class="number">8004</span></span><br><span class="line">      <span class="number">3</span>) <span class="string">"dea85bf87e560b6a5074f60965b8ad334bfeb5e8"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb info <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span> (<span class="number">673</span>e3292...) -&gt; <span class="number">1</span> keys | <span class="number">5461</span> slots | <span class="number">1</span> slaves.<span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span> (a923e101...) -&gt; <span class="number">1</span> keys | <span class="number">5461</span> slots | <span class="number">1</span> slaves.</span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span> (<span class="number">605950</span>ea...) -&gt; <span class="number">1</span> keys | <span class="number">5462</span> slots | <span class="number">1</span> slaves.</span><br><span class="line">[OK] <span class="number">3</span> keys <span class="keyword">in</span> <span class="number">3</span> masters.</span><br><span class="line"><span class="number">0.00</span> keys per slot on average.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="常用管理命令"><a href="#常用管理命令" class="headerlink" title="常用管理命令"></a><strong>常用管理命令</strong></h3><h4 id="cluster-cmd"><a href="#cluster-cmd" class="headerlink" title="cluster cmd"></a><strong>cluster cmd</strong></h4><ul>
<li><p>原生redis cluster命令集</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//cluster</span><br><span class="line">CLUSTER INFO 打印集群的信息</span><br><span class="line">CLUSTER NODES 列出集群当前已知的所有节点（node），以及这些节点的相关信息。</span><br><span class="line">//node</span><br><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt; 将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。</span><br><span class="line">CLUSTER FORGET &lt;node_id&gt; 从集群中移除 node_id 指定的节点。</span><br><span class="line">CLUSTER REPLICATE &lt;node_id&gt; 将当前节点设置为 node_id 主节点的从节点。</span><br><span class="line">CLUSTER SAVECONFIG 将节点的配置文件保存到硬盘里面。</span><br><span class="line">//slot</span><br><span class="line">CLUSTER ADDSLOTS &lt;slot&gt; [slot ...] 将一个或多个槽（slot）指派（assign）给当前节点。</span><br><span class="line">CLUSTER DELSLOTS &lt;slot&gt; [slot ...] 移除一个或多个槽对当前节点的指派。</span><br><span class="line">CLUSTER FLUSHSLOTS 移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。</span><br><span class="line">CLUSTER SETSLOT &lt;slot&gt; NODE &lt;node_id&gt; 将槽 slot 指派给 node_id 指定的节点。</span><br><span class="line">CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;node_id&gt; 将本节点的槽 slot 迁移到 node_id 指定的节点中。</span><br><span class="line">CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;node_id&gt; 从 node_id 指定的节点中导入槽 slot 到本节点。</span><br><span class="line">CLUSTER SETSLOT &lt;slot&gt; STABLE 取消对槽 slot 的导入（import）或者迁移（migrate）。</span><br><span class="line">//key</span><br><span class="line">CLUSTER KEYSLOT &lt;key&gt; 计算键 key 应该被放置在哪个槽上。</span><br><span class="line">CLUSTER COUNTKEYSINSLOT &lt;slot&gt; 返回槽 slot 目前包含的键值对数量。</span><br><span class="line">CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt; 返回 count 个 slot 槽中的键。</span><br><span class="line">//新增</span><br><span class="line">CLUSTER SLAVES node-id 返回一个master节点的slaves 列表</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改slave隶属master</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录需要修改的slave</span></span><br><span class="line">redis-cli -c -h <span class="number">192.168</span>.<span class="number">1.181</span> -p <span class="number">8006</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用cluster命令修改隶属master</span></span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8006</span>&gt; CLUSTER REPLICATE &lt;new_master_id&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动缩容master(迁移slot)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看集群状态</span></span><br><span class="line">&gt; CLUSTER NODES</span><br><span class="line"><span class="number">74</span>bfaa76306dd6bc59e559d012203ceed2a8ab24 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8003</span>@<span class="number">18003</span> slave a923e10183ef356bcadc1566503be4ab1ea1adb6 <span class="number">0</span> <span class="number">1542794664779</span> <span class="number">3</span> connected</span><br><span class="line">d976e1cc897744d5e5c2a0f754662c9d2a7cc077 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8006</span>@<span class="number">18006</span> myself,master - <span class="number">0</span> <span class="number">1542794660000</span> <span class="number">12</span> connected <span class="number">5461</span>-<span class="number">5558</span> <span class="number">10923</span>-<span class="number">10950</span></span><br><span class="line">a923e10183ef356bcadc1566503be4ab1ea1adb6 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span>@<span class="number">18002</span> master - <span class="number">0</span> <span class="number">1542794663778</span> <span class="number">3</span> connected <span class="number">10951</span>-<span class="number">16383</span></span><br><span class="line">dea85bf87e560b6a5074f60965b8ad334bfeb5e8 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8004</span>@<span class="number">18004</span> slave <span class="number">6</span>f12a4c4e1c60f435f68fbce1b72dc60ac73de83 <span class="number">0</span> <span class="number">1542794661000</span> <span class="number">11</span> connected</span><br><span class="line"><span class="number">605950</span>ea5c2214f50d5f3dddd87c80f4e7d1b631 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span>@<span class="number">18001</span> master - <span class="number">0</span> <span class="number">1542794664000</span> <span class="number">10</span> connected <span class="number">5559</span>-<span class="number">10922</span></span><br><span class="line"><span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47 <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span>@<span class="number">18000</span> slave <span class="number">605950</span>ea5c2214f50d5f3dddd87c80f4e7d1b631 <span class="number">0</span> <span class="number">1542794664000</span> <span class="number">10</span> connected</span><br><span class="line"><span class="number">6</span>f12a4c4e1c60f435f68fbce1b72dc60ac73de83 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8005</span>@<span class="number">18005</span> master - <span class="number">0</span> <span class="number">1542794665780</span> <span class="number">11</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"></span><br><span class="line">将<span class="number">8006</span>迁移到<span class="number">8001</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迁移步骤说明</span></span><br><span class="line">&gt; 在迁移目的节点执行cluster setslot &lt;slot&gt; IMPORTING &lt;<span class="built_in">source</span> node ID&gt;命令，指明需要迁移的slot和迁移源节点。</span><br><span class="line">&gt; 在迁移源节点执行cluster setslot &lt;slot&gt; MIGRATING &lt;node ID&gt;命令，指明需要迁移的slot和迁移目的节点。</span><br><span class="line">&gt; 在迁移源节点执行cluster getkeysinslot获取该slot的key列表。</span><br><span class="line">&gt; 在迁移源节点执行对每个key执行migrate命令，该命令会同步把该key迁移到目的节点。</span><br><span class="line">&gt; 在迁移源节点反复执行cluster getkeysinslot命令，直到该slot的列表为空。</span><br><span class="line">&gt; 在迁移源节点和目的节点执行cluster setslot &lt;slot&gt; NODE &lt;target node ID&gt;，完成迁移操作。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用脚本进行迁移slot</span></span><br><span class="line">migrate_slot.sh <span class="number">192.168</span>.<span class="number">1.181</span> <span class="number">8006</span> <span class="number">192.168</span>.<span class="number">1.180</span> <span class="number">8001</span> <span class="number">5461</span> <span class="number">5558</span> <span class="string">"&lt;redis_password&gt;"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="redis-trib-rb-cmd"><a href="#redis-trib-rb-cmd" class="headerlink" title="redis-trib.rb cmd"></a><strong>redis-trib.rb cmd</strong></h4><p>官方redis cluster集群管理工具命令集</p>
<ul>
<li><p>创建集群<code>redis-trib.rb create</code></p>
<ul>
<li><p>只创建master节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb create &lt;master1 ip:port&gt; &lt;master2 ip:port&gt; &lt;master3 ip:port&gt;</span><br><span class="line">e.g. redis-trib.rb create <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自动分配master/slave节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb create --replicas <span class="number">1</span> &lt;redis1 ip:port&gt; &lt;redis2 ip:port&gt; &lt;redis3 ip:port&gt; &lt;redis4 ip:port&gt; &lt;redis5 ip:port&gt; &lt;redis6 ip:port&gt;</span><br><span class="line">e.g. redis-trib.rb create --replicas <span class="number">1</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8001</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8002</span> <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8003</span> <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8004</span> <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8005</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>检查集群<code>redis-trib.rb check</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb check &lt;redis ip:port&gt;</span><br><span class="line">e.g. redis-trib.rb check <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看集群信息<code>redis-trib.rb info</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb info &lt;redis ip:port&gt;</span><br><span class="line">e.g. redis-trib.rb info <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修复集群<code>redis-trib.rb fix</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb fix &lt;redis ip:port&gt;</span><br><span class="line">e.g. redis-trib.rb fix <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新增节点<code>redis-trib.rb add-node</code></p>
<ul>
<li><p>加入master节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb add-node &lt;new master ip:port&gt; &lt;one of cluster ip:port&gt;</span><br><span class="line">e.g. redis-trib.rb add-node <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8006</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加入slave节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将&lt;new slave ip:port&gt;节点加入集群，并作为&lt;master_id&gt;节点的slave</span></span><br><span class="line">redis-trib.rb add-node --slave --master-id &lt;master node id&gt; &lt;new slave ip:port&gt; &lt;one of cluster ip:port&gt;</span><br><span class="line">e.g. redis-trib.rb add-node --slave --master-id <span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47 <span class="number">192.168</span>.<span class="number">1.181</span>:<span class="number">8007</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>删除节点<code>redis-trib.rb del-node</code></p>
<p><strong><code>redis-trib.rb del-node</code>只能删除没有分配slot的节点</strong> (slave or 空master)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb del-node &lt;one of cluster ip:port&gt; &lt;delete node id&gt;</span><br><span class="line">e.g. redis-trib.rb del-node <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span> <span class="number">6</span>f12a4c4e1c60f435f68fbce1b72dc60ac73de83</span><br></pre></td></tr></table></figure>
</li>
<li><p>在线迁移slot<code>redis-trib.rb reshard</code></p>
<p><strong>redis-4.x.x.gem 有bug！不能进行扩容/缩容<code>reshard|rebalance</code>, 报错<code>Syntax error ,try CLIENT (LIST|KILL|GETNAME|SETNAME|PAUSE|REPLY)</code></strong></p>
<p><strong>安装redis-3.x.x.gem版本可调用<code>reshard|rebalance</code>但不支持密码，不适用于有密码验证的集群</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交互式</span></span><br><span class="line">redis-trib.rb reshard &lt;one of cluster ip:port&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非交互式</span></span><br><span class="line">redis-trib.rb reshard --from &lt;all|node1_id,node2_id,node3_id&gt; --to &lt;dest node_id&gt; --slots &lt;numbers of slots&gt; &lt;one of cluster ip:port&gt;</span><br><span class="line">e.g. redis-trib.rb reshard --from all --to <span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47 --slots <span class="number">5461</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line">e.g. redis-trib.rb reshard --from <span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47,a923e10183ef356bcadc1566503be4ab1ea1adb6 --to <span class="number">673</span>e32925e0a6f9beefac8aeaad8a397758c5e47 --slots <span class="number">5461</span> <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>平衡slot<code>redis-trib.rb rebalance</code></p>
<p><strong>redis-4.x.x.gem 有bug！不能进行扩容/缩容<code>reshard|rebalance</code>, 报错<code>Syntax error ,try CLIENT (LIST|KILL|GETNAME|SETNAME|PAUSE|REPLY)</code></strong></p>
<p><strong>安装redis-3.x.x.gem版本可调用<code>reshard|rebalance</code>但不支持密码，不适用于有密码验证的集群</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单平衡所有节点</span></span><br><span class="line">redis-trib.rb rebalance <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment"># 复杂平衡</span></span><br><span class="line">redis-trib.rb rebalance --threshold <span class="number">1</span> --weight b31e3a2e=<span class="number">5</span> --weight <span class="number">60</span>b8e3a1=<span class="number">5</span> --use-empty-masters  --simulate <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置node间心跳超时时间<code>redis-trib.rb set-timeout</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb <span class="built_in">set</span>-timeout &lt;one of cluster ip:port&gt; &lt;timeout&gt;</span><br><span class="line">e.g. redis-trib.rb <span class="built_in">set</span>-timeout <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span> <span class="number">30000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>集群所有node执行命令<code>redis-trib.rb call</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb call &lt;one of cluster ip:port&gt; &lt;redis <span class="built_in">command</span>&gt;</span><br><span class="line">e.g. redis-trib.rb call <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span> get key</span><br><span class="line">e.g. redis-trib.rb call <span class="number">192.168</span>.<span class="number">1.180</span>:<span class="number">8000</span> rconfig rewrite</span><br><span class="line"></span><br><span class="line">redis-trib.rb call <span class="number">10.10</span>.<span class="number">10.171</span>:<span class="number">7004</span> rconfig <span class="built_in">set</span> masterauth <span class="string">"bincentTO*TOredis"</span></span><br><span class="line">redis-trib.rb call <span class="number">10.10</span>.<span class="number">10.171</span>:<span class="number">7004</span> rconfig <span class="built_in">set</span> requirepass <span class="string">"bincentTO*TOredis"</span></span><br><span class="line">redis-trib.rb call <span class="number">10.10</span>.<span class="number">10.171</span>:<span class="number">7004</span> rconfig rewrite</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入数据<code>redis-trib.rb import</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb import --from &lt;<span class="built_in">source</span> ip:port&gt; &lt;one of cluster ip:port&gt;</span><br><span class="line"><span class="comment"># --copy  选项可以保存旧redis上的key</span></span><br><span class="line"><span class="comment"># --replace  选项可以替换集群中相同名称的key，如果不使用，此类key不会被导入</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Redis-工具"><a href="#Redis-工具" class="headerlink" title="Redis 工具"></a><strong>Redis 工具</strong></h3><p><a href="https://github.com/facebookarchive/redis-faina" target="_blank" rel="external">redis-faina</a>: 分析hot key和top commands。需要注意的是，此脚本使用<code>monitor</code>命令进行分析</p>
<p><a href="https://github.com/sripathikrishnan/redis-rdb-tools" target="_blank" rel="external">redis-rdb-tools</a>: 通过RDB文件全量分析bigkey。redis原本支持查询bigkey<code>redis-cli  --bigkeys</code></p>
<h3 id="RedisCluster-测试"><a href="#RedisCluster-测试" class="headerlink" title="RedisCluster 测试"></a><strong>RedisCluster 测试</strong></h3><table>
<thead>
<tr>
<th>模拟场景</th>
<th>是否达到预期</th>
<th>业务功能是否受损预期</th>
<th>结论</th>
</tr>
</thead>
<tbody>
<tr>
<td>宕1个slave</td>
<td>是 (耗时15s自动故障迁移)</td>
<td>业务不受损</td>
<td>当master无slave时，若有冗余slave，会自动进行切换，不影响集群功能。<strong>15s由cluster-node-timeout参数决定</strong></td>
</tr>
<tr>
<td>宕2个slave</td>
<td>是</td>
<td>业务不受损</td>
<td>master无slave不影响集群功能，slave宕机不影响集群功能</td>
</tr>
<tr>
<td>宕3个slave</td>
<td>是</td>
<td>业务不受损</td>
<td>master无slave不影响集群功能，slave宕机不影响集群功能</td>
</tr>
<tr>
<td>宕1个master</td>
<td>是 (耗时15s自动slave切换master)</td>
<td>业务受影响15s</td>
<td>slave自动切换成master期间(15s)，宕掉的master对应的slot不可用，所有对此slot的操作皆会受影响，由于设置cluster-require-full-coverage=no，没宕的2个master可正常提供服务。<strong>15s由cluster-node-timeout参数决定</strong></td>
</tr>
<tr>
<td>宕2个master</td>
<td>FAILOVER FORCE / TAKEOVER恢复</td>
<td>业务受损</td>
<td>集群超过半数master宕，集群进入fail状态，slave不会自动切换成master，整个集群不可用。<strong>不要将多个master部署在一台机器上</strong></td>
</tr>
<tr>
<td>宕3个master</td>
<td>是</td>
<td>业务受损</td>
<td>集群所有master宕，集群进入fail状态，slave不会自动切换成master。整个集群不可用</td>
</tr>
<tr>
<td>宕1组master/slave</td>
<td>是</td>
<td>业务受影响</td>
<td>一组主从同时宕机，会导致对应宕掉master的slot无法操作，由于设置cluster-require-full-coverage=no没宕的master可正常提供服务。<strong>不要将一组主从部署在一台机器上</strong></td>
</tr>
<tr>
<td>扩容/缩容1个master</td>
<td>是</td>
<td>业务不受损</td>
<td>迁移slot，不影响对集群读写操作。由于官方工具redis-trib.rb有bug，扩容/缩容需手动迁移slot，极易误操作，建议尽量不要纯手工迁移slot，非要迁移尽量使用脚本迁移，避免纯手动迁移</td>
</tr>
</tbody>
</table>
<h3 id="标准化规范"><a href="#标准化规范" class="headerlink" title="标准化规范"></a><strong>标准化规范</strong></h3><ul>
<li>公共配置文件路径: <code>/usr/local/redis-cluster/redis.conf</code></li>
<li>实例配置文件路径: <code>/usr/local/redis-cluster/conf</code></li>
<li>配置文件命名: <code>{redis_port}.conf</code>，以redis端口命名配置文件名。(e.g., /usr/local/redis-cluster/conf/8000.conf)</li>
<li>数据存放路径: <code>/data/redis/{redis_port}</code>，以redis端口命名文件夹目录。(e.g., dir “/data/redis/8000”)</li>
<li>日志存放路径: <code>/data/logs/redis/</code></li>
<li>日志文件命名: <code>redis_{redis_port}.log</code>，以redis端口命名日志。(e.g., logfile “/data/logs/redis/redis_8000.log”)</li>
<li>端口范围: redis_port &gt; 20000</li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迁移slot脚本</span></span><br><span class="line">. /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -eu</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span>_ip=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">source</span>_port=<span class="variable">$2</span></span><br><span class="line">target_ip=<span class="variable">$3</span></span><br><span class="line">target_port=<span class="variable">$4</span></span><br><span class="line">start_slot=<span class="variable">$5</span></span><br><span class="line">end_slot=<span class="variable">$6</span></span><br><span class="line">password=<span class="variable">$7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$#</span> != <span class="number">7</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"Usage: <span class="variable">$0</span> source_ip source_port target_ip target_port start_slot end_slot password"</span></span><br><span class="line">    <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在目的节点执行cluster setslot &lt;slot&gt; IMPORTING &lt;source node ID&gt;命令，指明需要迁移的slot和迁移源节点</span></span><br><span class="line"><span class="keyword">for</span> slot <span class="keyword">in</span> `seq <span class="variable">$&#123;start_slot&#125;</span> <span class="variable">$&#123;end_slot&#125;</span>`; <span class="keyword">do</span></span><br><span class="line">    redis-cli -c -h <span class="variable">$&#123;target_ip&#125;</span> -p <span class="variable">$&#123;target_port&#125;</span> <span class="operator">-a</span> <span class="variable">$&#123;password&#125;</span> cluster setslot <span class="variable">$&#123;slot&#125;</span> IMPORTING `redis-cli -c -h <span class="variable">$&#123;source_ip&#125;</span> -p <span class="variable">$&#123;source_port&#125;</span> <span class="operator">-a</span> <span class="variable">$&#123;password&#125;</span> cluster nodes | grep <span class="variable">$&#123;source_ip&#125;</span> | grep <span class="variable">$&#123;source_port&#125;</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在源节点执行cluster setslot &lt;slot&gt; MIGRATING &lt;target node ID&gt;命令，指明需要迁移的slot和迁移目的节点</span></span><br><span class="line"><span class="keyword">for</span> slot <span class="keyword">in</span> `seq <span class="variable">$&#123;start_slot&#125;</span> <span class="variable">$&#123;end_slot&#125;</span>`; <span class="keyword">do</span></span><br><span class="line">    redis-cli -c -h <span class="variable">$&#123;source_ip&#125;</span> -p <span class="variable">$&#123;source_port&#125;</span> <span class="operator">-a</span> <span class="variable">$&#123;password&#125;</span> cluster setslot <span class="variable">$&#123;slot&#125;</span> MIGRATING `redis-cli -c -h <span class="variable">$&#123;target_ip&#125;</span> -p <span class="variable">$&#123;target_port&#125;</span> <span class="operator">-a</span> <span class="variable">$&#123;password&#125;</span> cluster nodes | grep <span class="variable">$&#123;target_ip&#125;</span> | grep <span class="variable">$&#123;target_port&#125;</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> slot <span class="keyword">in</span> `seq <span class="variable">$&#123;start_slot&#125;</span> <span class="variable">$&#123;end_slot&#125;</span>`; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></span><br><span class="line">        <span class="comment">#源节点执行getkeysinslot命令，从slot中取出count(20)个键值对的key</span></span><br><span class="line">        allkeys=`redis-cli -c -h <span class="variable">$&#123;source_ip&#125;</span> -p <span class="variable">$&#123;source_port&#125;</span> <span class="operator">-a</span> <span class="variable">$&#123;password&#125;</span> cluster getkeysinslot <span class="variable">$&#123;slot&#125;</span> <span class="number">20</span>`</span><br><span class="line">        <span class="comment">#若slot中有key，则需先迁移key再迁移slot</span></span><br><span class="line">        <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$&#123;allkeys&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="comment">#slot无key</span></span><br><span class="line">            <span class="comment">#源节点和目标节点执行setslot命令，将slot分配给目标节点</span></span><br><span class="line">            redis-cli -c -h <span class="variable">$&#123;source_ip&#125;</span> -p <span class="variable">$&#123;source_port&#125;</span> <span class="operator">-a</span> <span class="variable">$&#123;password&#125;</span> cluster setslot <span class="variable">$&#123;slot&#125;</span> NODE `redis-cli -c -h <span class="variable">$&#123;source_ip&#125;</span> -p <span class="variable">$&#123;source_port&#125;</span> <span class="operator">-a</span> <span class="variable">$&#123;password&#125;</span> cluster nodes | grep <span class="variable">$&#123;target_ip&#125;</span> | grep <span class="variable">$&#123;target_port&#125;</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">            redis-cli -c -h <span class="variable">$&#123;target_ip&#125;</span> -p <span class="variable">$&#123;target_port&#125;</span> <span class="operator">-a</span> <span class="variable">$&#123;password&#125;</span> cluster setslot <span class="variable">$&#123;slot&#125;</span> NODE `redis-cli -c -h <span class="variable">$&#123;source_ip&#125;</span> -p <span class="variable">$&#123;source_port&#125;</span> <span class="operator">-a</span> <span class="variable">$&#123;password&#125;</span> cluster nodes | grep <span class="variable">$&#123;target_ip&#125;</span> | grep <span class="variable">$&#123;target_port&#125;</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;allkeys&#125;</span>; <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"migrate slot:<span class="variable">$&#123;slot&#125;</span> key:<span class="variable">$&#123;key&#125;</span>"</span></span><br><span class="line">                <span class="comment">#源节点执行migrate命令，将key迁移到目标节点</span></span><br><span class="line">                <span class="comment"># MIGRATE target_ip target_port key db timeout(millisecond) AUTH password</span></span><br><span class="line">                redis-cli -c -h <span class="variable">$&#123;source_ip&#125;</span> -p <span class="variable">$&#123;source_port&#125;</span> <span class="operator">-a</span> <span class="variable">$&#123;password&#125;</span> MIGRATE <span class="variable">$&#123;target_ip&#125;</span> <span class="variable">$&#123;target_port&#125;</span> <span class="variable">$&#123;key&#125;</span> <span class="number">0</span> <span class="number">5000</span> AUTH <span class="variable">$&#123;password&#125;</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a><strong>基础概念</strong></h3><h4 id="Slot"><a href="#Slot" class="headerlink"]]>
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="OPS" scheme="http://yoursite.com/categories/OPS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Prometheus]]></title>
    <link href="http://yoursite.com/2018/10/05/prometheus/"/>
    <id>http://yoursite.com/2018/10/05/prometheus/</id>
    <published>2018-10-05T07:45:33.000Z</published>
    <updated>2019-04-21T15:36:19.244Z</updated>
    <content type="html"><![CDATA[<p>参考资料</p>
<ul>
<li><a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="external">Prometheus中文</a></li>
<li><a href="https://www.bookstack.cn/books/prometheus_practice" target="_blank" rel="external">Prometheus 实战</a></li>
</ul>
<h2 id="Prometheus-核心组件"><a href="#Prometheus-核心组件" class="headerlink" title="Prometheus 核心组件"></a><strong>Prometheus 核心组件</strong></h2><p><img src="https://prometheus.io/assets/architecture.png" alt="Prometheus 架构图"></p>
<ul>
<li><p><strong>Prometheus Server</strong></p>
<p>Prometheus组件中的核心部分，负责实现对监控数据的获取，存储以及查询。</p>
<p>Prometheus Server本身就是一个时序数据库，将采集到的监控数据按照时间序列的方式存储在本地磁盘当中。</p>
<p>Prometheus Server对外提供了自定义的PromQL语言，实现对数据的查询以及分析。</p>
</li>
<li><p><strong>AlertManager</strong></p>
<p>AlertManager为告警处理中心。Prometheus Server中支持基于PromQL创建告警规则，如果满足PromQL定义的规则，则会产生一条告警，而告警的后续处理流程则由AlertManager进行管理。</p>
</li>
<li><p><strong>Exporters</strong></p>
<p>Exporter将监控数据采集通过HTTP方式暴露，Prometheus Server通过拉的方式获取监控数据</p>
</li>
<li><p><strong>PushGateway</strong></p>
<p>如果监控数据不能通过Pull方式采集，可以将监控数据Push到PushGateway，然后Prometheus Server到PushGateway Pull</p>
</li>
</ul>
<h2 id="PromQL"><a href="#PromQL" class="headerlink" title="PromQL"></a><strong>PromQL</strong></h2><h3 id="time-series-时间序列"><a href="#time-series-时间序列" class="headerlink" title="time-series(时间序列)"></a><strong>time-series(时间序列)</strong></h3><p>Prometheus Server将采集到的数据以<strong><code>time-series</code>(时间序列)</strong>方式保存在内存数据库中，并定时落到磁盘中。</p>
<p><code>time-series</code>按照<strong>时间戳</strong>和<strong>值的序列</strong>顺序存放，<code>time-series</code>中的每个数据称之为<strong><code>sample</code>(样本)</strong>。</p>
<p><strong><code>sample</code>(样本)</strong> 由3部分组成：</p>
<ul>
<li><strong><code>metric</code>(指标)</strong>: metric name + labelsets</li>
<li><strong><code>timestamp</code>(时间戳)</strong>: 精确到毫秒</li>
<li><strong><code>value</code>(样本值)</strong>: folat64的浮点型数据表示当前样本的值</li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;--------------- metric ---------------------&gt;&lt;-timestamp -&gt;&lt;-value-&gt;</span><br><span class="line">http_request_total<span class="special">&#123;</span>status="200", method="GET"<span class="special">&#125;</span>@1434417560938 =&gt; 94355</span><br><span class="line">http_request_total<span class="special">&#123;</span>status="200", method="GET"<span class="special">&#125;</span>@1434417561287 =&gt; 94334</span><br></pre></td></tr></table></figure>
<h3 id="metric-指标"><a href="#metric-指标" class="headerlink" title="metric(指标)"></a><strong>metric(指标)</strong></h3><p><code>metric</code> 是 <code>time-series</code>数据中重要组成部分，<code>metric</code>格式如下:</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;-metric name-&gt;&lt;----------labelsets---------&gt;</span><br><span class="line">&lt;metric name&gt;<span class="special">&#123;</span>&lt;label name&gt;=&lt;label value&gt;, ...<span class="special">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><code>metric name</code></strong>: 反映被监控样本的含义，可由ASCII字符、数字、下划线以及冒号组成并必须符合正则表达式<code>[a-zA-Z_:][a-zA-Z0-9_:]*</code></p>
</li>
<li><p><strong><code>labelsets</code></strong>: 反映当前样本的<strong>特征维度</strong>，通过这些维度Prometheus可以对样本数据进行过滤，聚合等。<code>label = label name + label value</code>， <code>label name</code>由ASCII字符、数字以及下划线组成并满足正则表达式<code>[a-zA-Z_][a-zA-Z0-9_]*</code> 。以<code>__</code>作为前缀的标签，是系统保留的关键字，只能在系统内部使用。以下两个metric是完成相同的</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">api_http_requests_total<span class="special">&#123;</span>method="POST", handler="/messages"<span class="special">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="special">&#123;</span>__name__="api_http_requests_total"，method="POST", handler="/messages"<span class="special">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="metric-type-指标类型"><a href="#metric-type-指标类型" class="headerlink" title="metric type(指标类型)"></a><strong>metric type(指标类型)</strong></h3><p>Prometheus 定义了4种metric type(指标类型)</p>
<ul>
<li>Counter (计数器)</li>
<li>Gauge (仪表盘)</li>
<li>Histogram (直方图)</li>
<li>Summary (摘要)</li>
</ul>
<h4 id="Counter-计数器"><a href="#Counter-计数器" class="headerlink" title="Counter 计数器"></a><strong>Counter 计数器</strong></h4><p>Counter类型的指标<strong>只增不减</strong>(除非系统发生重置)，侧重于累计。一般在定义Counter类型指标的名称时推荐使用<code>_total</code>作为后缀，如: <code>http_requests_total</code>。</p>
<h4 id="Gauge-仪表盘"><a href="#Gauge-仪表盘" class="headerlink" title="Gauge 仪表盘"></a><strong>Gauge 仪表盘</strong></h4><p>Gauge类型的指标<strong>可增可减</strong>，侧重于反应系统的当前状态。</p>
<h4 id="Histogram-直方图"><a href="#Histogram-直方图" class="headerlink" title="Histogram 直方图"></a><strong>Histogram 直方图</strong></h4><p>Histogram类型的指标主用用于<strong>统计和分析样本的分布情况</strong>。主要用于表示一段时间范围内对数据进行采样，并能够对其指定区间以及总数进行统计，如: <code>http_response_time</code>、<code>http_response_size</code>。</p>
<p><code>&lt;basename&gt;_bucket{le=&quot;&lt;upper inclusive bound&gt;&quot;}</code>、<code>&lt;basename&gt;_bucket{le=&quot;+Inf&quot;}</code>、<code>&lt;basename&gt;_sum</code>、<code>&lt;basename&gt;_count</code> 组成。</p>
<p>Histogram 需要通过 <basename>_bucket 计算 quantile(分位数), 而 Summary 直接存储了 quantile(分位数)的值。Histogram通过<code>histogram_quantile</code>函数在<strong>服务器端</strong>计算出分位数，Sumamry的分位数则是直接在<strong>客户端</strong>计算完成</basename></p>
<h4 id="Summary-摘要"><a href="#Summary-摘要" class="headerlink" title="Summary 摘要"></a><strong>Summary 摘要</strong></h4><p>Summary类型和Histogram类型类似，主要用于表示一段时间内数据采样结果，它直接存储了quantile数据，而不是根据统计区间计算出来的。</p>
<p><code>&lt;basename&gt;{quantile=&quot;&lt;φ&gt;&quot;}</code>、<code>&lt;basename&gt;_sum</code>、<code>&lt;basename&gt;_count</code> 组成。</p>
<p>Histogram 需要通过 <basename>_bucket 计算 quantile(分位数), 而 Summary 直接存储了 quantile(分位数)的值。Histogram通过<code>histogram_quantile</code>函数在<strong>服务器端</strong>计算出分位数，Sumamry的分位数则是直接在<strong>客户端</strong>计算完成</basename></p>
<h3 id="PromeQL-语法"><a href="#PromeQL-语法" class="headerlink" title="PromeQL 语法"></a><strong>PromeQL 语法</strong></h3><h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a><strong>匹配模式</strong></h4><ul>
<li><p>完全匹配 <strong><code>=</code></strong> 、<strong><code>!=</code></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;instance="localhost:9090"&#125;</span><br><span class="line">http_requests_total&#123;instance!="localhost:9090"&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则匹配 <strong><code>=~</code></strong>、<strong><code>!~</code></strong></p>
<p>PromQL支持使用正则表达式作为匹配条件，多个表达式之间使用<code>|</code>进行分离</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;environment=~"staging|testing|development",method!="GET"&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a><strong>范围查询</strong></h4><p>PromQL支持查询一段时间范围内的样本数据，时间范围通过时间范围选择器<code>[]</code>进行定义。时间单位支持如下：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s - 秒</span><br><span class="line">m - 分钟</span><br><span class="line">h - 小时</span><br><span class="line">d - 天</span><br><span class="line">w - 周</span><br><span class="line">y - 年</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_request_total&#123;&#125;[5m]</span><br></pre></td></tr></table></figure>
<h4 id="时间位移操作"><a href="#时间位移操作" class="headerlink" title="时间位移操作"></a><strong>时间位移操作</strong></h4><p>PromQL支持时间位移操作以查询过去某时间数据，位移操作关键字为 <code>offset</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http_request_total&#123;&#125; offset 5m</span><br><span class="line">-- 昨天一天的请求总量</span><br><span class="line">http_request_total&#123;&#125;[1d] offset 1d</span><br></pre></td></tr></table></figure>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a><strong>操作符</strong></h4><h5 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a><strong>数学运算符</strong></h5><ul>
<li><code>+</code> (加法)</li>
<li><code>-</code> (减法)</li>
<li><code>*</code> (乘法)</li>
<li><code>/</code> (除法)</li>
<li><code>%</code> (求余)</li>
<li><code>^</code> (幂运算)</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_memory_free_bytes_total / (<span class="number">1024</span> * <span class="number">1024</span>)</span><br></pre></td></tr></table></figure>
<h5 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a><strong>布尔运算符</strong></h5><ul>
<li><code>==</code> (相等)</li>
<li><code>!=</code> (不相等)</li>
<li><code>&gt;</code> (大于)</li>
<li><code>&lt;</code> (小于)</li>
<li><code>&gt;=</code> (大于等于)</li>
<li><code>&lt;=</code> (小于等于)</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(node_memory_bytes_total - node_memory_free_bytes_total) / node_memory_bytes_total &gt; <span class="number">0.95</span></span><br></pre></td></tr></table></figure>
<h5 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a><strong>集合运算符</strong></h5><ul>
<li><code>and</code> (并且)</li>
<li><code>or</code> (或者)</li>
<li><code>unless</code> (排除)</li>
</ul>
<h5 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a><strong>操作符优先级</strong></h5><ul>
<li><code>^</code></li>
<li><code>*, /, %</code></li>
<li><code>+, -</code></li>
<li><code>==, !=, &lt;=, &lt;, &gt;=, &gt;</code></li>
<li><code>and, unless</code></li>
<li><code>or</code></li>
</ul>
<h4 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a><strong>聚合操作</strong></h4><p>PromeQL内置聚合操作符</p>
<ul>
<li><code>sum</code> (求和)</li>
<li><code>min</code> (最小值)</li>
<li><code>max</code> (最大值)</li>
<li><code>avg</code> (平均值)</li>
<li><code>stddev</code> (标准差)</li>
<li><code>stdvar</code> (标准差异)</li>
<li><code>count</code> (计数)</li>
<li><code>count_values</code> (对value进行计数)</li>
<li><code>bottomk</code> (后n条时序)</li>
<li><code>topk</code> (前n条时序)</li>
<li><code>quantile</code> (分位数)</li>
</ul>
<p>聚合操作语法</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aggr-op&gt;(<span class="special">[</span>parameter,<span class="special">]</span> &lt;vector expression&gt;) <span class="special">[</span>without|by (&lt;label list&gt;)<span class="special">]</span></span><br></pre></td></tr></table></figure>
<p>只有<code>count_values</code>, <code>quantile</code>, <code>topk</code>, <code>bottomk</code>支持parameter(参数)</p>
<p>without用于从计算结果中移除列举的标签，而保留其它标签。by则正好相反，结果向量中只保留列出的标签，其余标签则移除。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total) without (instance)</span><br><span class="line">sum(http_requests_total) by (code,<span class="operator"><span class="keyword">handler</span>,job,method)</span></span><br></pre></td></tr></table></figure>
<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a><strong>内置函数</strong></h4><p><a href="https://prometheus.io/docs/prometheus/latest/querying/functions/" target="_blank" rel="external">Prometheus 内置函数 官方文档</a></p>
<p><a href="https://ryanyang.gitbook.io/prometheus/di-san-zhang-prometheus/di-4-jie-cha-xun/functions" target="_blank" rel="external">Prometheus 内置函数 中文文档</a></p>
<h2 id="Prometheus-Server"><a href="#Prometheus-Server" class="headerlink" title="Prometheus Server"></a><strong>Prometheus Server</strong></h2><h3 id="Prometheus-Server-部署启动"><a href="#Prometheus-Server-部署启动" class="headerlink" title="Prometheus Server 部署启动"></a><strong>Prometheus Server 部署启动</strong></h3><ul>
<li><p>安装</p>
<p>直接下载二进制包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://prometheus.io/download/<span class="comment">#prometheus</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /usr/<span class="built_in">local</span>/prometheus/prometheus --config.file=/usr/<span class="built_in">local</span>/prometheus/prometheus.yml --storage.tsdb.path=/data/prometheus --storage.tsdb.retention=<span class="number">1</span>d --web.enable-lifecycle &amp;&gt;/var/<span class="built_in">log</span>/prometheus.log &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--config.file</code>: Prometheus默认加载当前目录下的<code>prometheus.yaml</code>配置文件，可使用此启动参数修改</li>
<li><code>--storage.tsdb.path</code>: Prometheus也是一个时间序列数据库，其采集的数据会以文件的形似存储在本地中，默认的存储路径为<code>data/</code>，使用此启动参数修改本地存储路径</li>
<li><code>--storage.tsdb.retention</code>: 数据保留时间</li>
<li><code>--web.enable-lifecycle</code>: 开启此参数后，可通过HTTP请求平滑重启Prometheus</li>
</ul>
</li>
<li><p>平滑重启加载配置文件</p>
<p>需开启<code>--web.enable-lifecycle</code>参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:<span class="number">9090</span>/-/reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>Prometheus UI 地址</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:9090</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Prometheus-Server-配置文件"><a href="#Prometheus-Server-配置文件" class="headerlink" title="Prometheus Server 配置文件"></a><strong>Prometheus Server 配置文件</strong></h3><p>Prometheus默认使用<code>prometheus.yaml</code>配置文件，也在启动时使用<code>--config.file</code>指定。<code>prometheus.yaml</code>主要由以下部分组成:</p>
<ul>
<li><strong><code>global</code></strong>: 全局配置</li>
<li><strong><code>alerting</code></strong>: alertmanager 相关配置</li>
<li><strong><code>rule_files</code></strong>: 告警规则相关配置</li>
<li><strong><code>scrape_configs</code></strong>: 数据拉取相关配置</li>
<li><strong><code>remote_write</code></strong>: 远程写相关配置</li>
<li><strong><code>remote_read</code></strong>: 远程读相关配置</li>
</ul>
<h4 id="global-全局配置"><a href="#global-全局配置" class="headerlink" title="global 全局配置"></a><strong>global 全局配置</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global:&#10;  scrape_interval:     15s # &#25289;&#21462; targets &#30340;&#26102;&#38388;&#38388;&#38548;&#10;  evaluation_interval: 15s # &#25191;&#34892; rules &#30340;&#26102;&#38388;&#38388;&#38548;&#10;  scrape_timeout: 10s # &#25289;&#21462;&#19968;&#20010; target &#30340;&#36229;&#26102;&#26102;&#38388;&#10;  external_labels:&#9;# &#39069;&#22806;&#30340;&#23646;&#24615;&#65292;&#20250;&#28155;&#21152;&#21040;&#25289;&#21462;&#30340;&#25968;&#25454;&#24182;&#23384;&#21040;&#25968;&#25454;&#24211;&#20013;&#10;  monitor: &#39;codelab-monitor&#39;</span><br></pre></td></tr></table></figure>
<h4 id="alerting-告警配置"><a href="#alerting-告警配置" class="headerlink" title="alerting 告警配置"></a><strong>alerting 告警配置</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alerting:&#10;  alertmanagers:&#9;# &#29992;&#20110;&#21160;&#24577;&#21457;&#29616; Alertmanager &#30340;&#37197;&#32622;&#10;  - static_configs:&#10;    - targets:&#10;      - 192.168.1.180:9093&#10;      - 192.168.1.181:9093&#10;  #alert_relabel_configs:&#9;# &#21160;&#24577;&#20462;&#25913; alert &#23646;&#24615;&#30340;&#35268;&#21017;&#37197;&#32622;&#10;  #-</span><br></pre></td></tr></table></figure>
<h4 id="rule-files-规则配置"><a href="#rule-files-规则配置" class="headerlink" title="rule_files 规则配置"></a><strong>rule_files 规则配置</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule_files:&#9;# &#20027;&#35201;&#29992;&#20110;&#37197;&#32622; rules &#25991;&#20214;&#65292;&#23427;&#25903;&#25345;&#22810;&#20010;&#25991;&#20214;&#20197;&#21450;&#25991;&#20214;&#30446;&#24405;&#10;  - &#34;rules/*.yml&#34;</span><br></pre></td></tr></table></figure>
<h5 id="自定义告警规则"><a href="#自定义告警规则" class="headerlink" title="自定义告警规则"></a><strong>自定义告警规则</strong></h5><p>指定告警文件后，可针对具体服务配置自定义告警规则。将一组相关的规则设置定义在一个group下，在每个group中定义多个告警规则(rule)。</p>
<ul>
<li>alert：告警规则的名称。</li>
<li>expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。</li>
<li>for：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。</li>
<li>labels：自定义标签，允许用户指定要附加到告警上的一组附加标签。</li>
<li>annotations：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。</li>
<li>record: Prometheus支持根据现有metric通过计算生产新的metric，此特性可用于由于性能提高查询效率，也可以用于生成新的metric值</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups:&#10;- name: redis&#10;  rules:&#10;  - alert: RedisDownProblem&#10;    expr: sum by (addr) (redis_up) != 1&#10;    for: 1m&#10;    labels:&#10;      tag: &#34;&#123;&#123; $labels.addr &#125;&#125;&#34;&#10;      level: CRITICAL&#10;    annotations:&#10;      message: &#34;&#123;&#123; $labels.addr &#125;&#125; &#123;&#123; $labels.rgroup &#125;&#125; redis is down!&#34;&#10;&#10;  - alert: RedisConnectionProblem&#10;    expr: sum by (addr) (redis_connected_clients / redis_config_maxclients) * 100 &#62;= 95&#10;    for: 2m&#10;    labels:&#10;      tag: &#34;&#123;&#123; $labels.addr &#125;&#125;&#34;&#10;    annotations:&#10;      info: &#34;&#123;&#123; $labels.addr &#125;&#125; redis connected connections &#123;&#123; $value &#125;&#125;, reach 95%&#34;&#10;&#10;  - record: elasticsearch_transport_rx_bps&#10;    expr: ( elasticsearch_transport_rx_size_bytes_total - ( elasticsearch_transport_rx_size_bytes_total offset 60s)) /8/60</span><br></pre></td></tr></table></figure>
<h4 id="scrape-configs-数据拉取配置"><a href="#scrape-configs-数据拉取配置" class="headerlink" title="scrape_configs 数据拉取配置"></a><strong>scrape_configs 数据拉取配置</strong></h4><ul>
<li>job_name：任务名称</li>
<li>honor_labels： 用于解决拉取数据标签有冲突，当设置为 true, 以拉取数据为准，否则以服务配置为准</li>
<li>params：数据拉取访问时带的请求参数</li>
<li>scrape_interval： 拉取时间间隔</li>
<li>scrape_timeout: 拉取超时时间</li>
<li>metrics_path： 拉取节点的 metric 路径</li>
<li>scheme： 拉取数据访问协议</li>
<li>sample_limit： 存储的数据标签个数限制，如果超过限制，该数据将被忽略，不入存储；默认值为0，表示没有限制</li>
<li>relabel_configs： 拉取数据重置标签配置</li>
<li>metric_relabel_configs：metric 重置标签配置</li>
<li>static_configs：exporter地址配置</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrape_configs:&#10;  - job_name: &#39;redis&#39;&#10;    static_configs:&#10;    - targets: [&#39;192.168.1.180:9121&#39;]&#10;      labels:&#10;        group: ops</span><br></pre></td></tr></table></figure>
<h4 id="remote-write-远程写"><a href="#remote-write-远程写" class="headerlink" title="remote_write 远程写"></a><strong>remote_write 远程写</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;remote_write:&#10;  - url: &#34;http://localhost:8088/prometheus&#34;&#9;# &#35775;&#38382;&#22320;&#22336;&#10;  #- remote_timeout: 30s&#9;# &#35831;&#27714;&#36229;&#26102;&#26102;&#38388;&#10;  #- write_relabel_configs: # &#26631;&#31614;&#37325;&#32622;&#37197;&#32622;, &#25289;&#21462;&#21040;&#30340;&#25968;&#25454;&#65292;&#32463;&#36807;&#37325;&#32622;&#22788;&#29702;&#21518;&#65292;&#21457;&#36865;&#32473;&#36828;&#31243;&#23384;&#20648;&#10;     #- [ - &#60;relabel_config&#62; ... ]</span><br></pre></td></tr></table></figure>
<h4 id="remote-read-远程读"><a href="#remote-read-远程读" class="headerlink" title="remote_read 远程读"></a><strong>remote_read 远程读</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote_read:&#10;  - url: &#34;http://localhost:8088&#34;&#9;# &#35775;&#38382;&#22320;&#22336;&#10;  - remote_timeout: 30s&#9;&#9;# &#35831;&#27714;&#36229;&#26102;&#26102;&#38388;</span><br></pre></td></tr></table></figure>
<h2 id="AlertManager"><a href="#AlertManager" class="headerlink" title="AlertManager"></a><strong>AlertManager</strong></h2><p>AlertManager对收到的告警信息进行处理，包括去重，降噪，分组，策略路由告警通知等。AlertManager还提供了静默和告警抑制机制来对告警通知行为进行优化。</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBdoxo9EmQ0bJP2BuUi%2F-LVMF4RtPS-2rjW9R-hG%2F-LPS9QhUbi37E1ZK8mXF%2Fprometheus-alert-artich.png?generation=1546578333144123&amp;alt=media" alt="Prometheus告警流程"></p>
<h3 id="AlertManager-部署启动"><a href="#AlertManager-部署启动" class="headerlink" title="AlertManager 部署启动"></a><strong>AlertManager 部署启动</strong></h3><ul>
<li><p>安装</p>
<p>直接下载二进制包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://prometheus.io/download/<span class="comment">#alertmanager</span></span><br><span class="line"><span class="comment"># https://github-production-release-asset-2e65be.s3.amazonaws.com/11452538/99c4aad8-10a1-11e8-9ead-55da24ff8da3?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20180615%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20180615T062841Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=11da1a2b6bb688ca0e92bcb1cd5c2b6c14f796f3a8530fed1242523c2798b48e&amp;X-Amz-SignedHeaders=host&amp;actor_id=0&amp;response-content-disposition=attachment%3B%20filename%3Dalertmanager-0.14.0.linux-amd64.tar.gz&amp;response-content-type=application%2Foctet-stream</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/alertmanager</span><br><span class="line">/usr/<span class="built_in">local</span>/alertmanager/alertmanager --web.listen-address=:<span class="number">9093</span> --mesh.listen-address=:<span class="number">9094</span> --mesh.nickname=:<span class="number">9094</span> --config.file=/usr/<span class="built_in">local</span>/alertmanager/alertmanager.yaml --storage.path=/data1/alert/ --data.retention=<span class="number">24</span>h</span><br><span class="line"><span class="comment"># ./alertmanager --config.file=alertmanager.yaml --storage.path=/data1/alert/ --data.retention=24h --log.level=debug</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>平滑重启加载配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:<span class="number">9093</span>/-/reload</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="AlertManager-特性"><a href="#AlertManager-特性" class="headerlink" title="AlertManager 特性"></a><strong>AlertManager 特性</strong></h3><p>AlertManager除了基础的告警功能外，还提供: 去重、抑制和静默等功能</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBdoxo9EmQ0bJP2BuUi%2F-LVMF4RtPS-2rjW9R-hG%2F-LPS9QhWQUhAIdLAiEfH%2Falertmanager-features.png?generation=1546578326190496&amp;alt=media" alt="AlertManager 特性"></p>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a><strong>分组</strong></h4><p>分组机制将详细的告警信息合并成一个通知，按照设定的关键字对告警进行分组，能有效将告警内聚在一起成为一个通知，防止告警风暴</p>
<h4 id="抑制"><a href="#抑制" class="headerlink" title="抑制"></a><strong>抑制</strong></h4><p>当某一告警发出后，可以停止重复发送由此告警引发的其它告警的机制。</p>
<h4 id="静默"><a href="#静默" class="headerlink" title="静默"></a><strong>静默</strong></h4><p>AlertManager提供简单机制，可根据<code>label</code>对告警进行临时静默，访问AlertManager的Web界面可进行设置</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:9093</span></span><br></pre></td></tr></table></figure>
<h3 id="AlertManager-配置文件"><a href="#AlertManager-配置文件" class="headerlink" title="AlertManager 配置文件"></a><strong>AlertManager 配置文件</strong></h3><p>AlertManager默认加载<code>alertmanager.yaml</code>配置文件，可通过启动参数<code>--config.file</code>指定配置文件</p>
<p>AlertManager配置主要包含以下部分:</p>
<ul>
<li><strong><code>global</code></strong>: 全局配置，用于定义全局的公共参数，如全局的SMTP配置，Slack配置等内容</li>
<li><strong><code>templates</code></strong>: 模板，用于定义告警通知时的模板，如HTML模板，邮件模板等</li>
<li><strong><code>route</code></strong>: 告警路由，根据标签匹配，确定当前告警应该如何处理</li>
<li><strong><code>receivers</code></strong>: 接收对象，可以是一个邮箱也可以是微信，Slack或者Webhook等，接收对象一般配合告警路由使用</li>
<li><strong><code>inhibit_rules</code></strong>: 抑制规则，抑制告警风暴</li>
</ul>
<h4 id="global-全局配置-1"><a href="#global-全局配置-1" class="headerlink" title="global 全局配置"></a><strong>global 全局配置</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global:&#10;  resolve_timeout: 5m&#9;# &#25345;&#32493;&#22810;&#38271;&#26102;&#38388;&#26410;&#25509;&#25910;&#21040;&#21578;&#35686;&#21518;&#26631;&#35760;&#21578;&#35686;&#29366;&#24577;&#20026;resolved&#10;&#10;  smtp_smarthost: &#39;&#60;smtp_host&#62;:25&#39;&#10;  smtp_from: &#39;&#60;user&#62;@&#60;smtp_domain&#62;&#39;&#10;  smtp_auth_username: &#39;&#60;user&#62;&#39;&#10;  smtp_auth_password: &#39;&#60;password&#62;&#39;</span><br></pre></td></tr></table></figure>
<h4 id="route-路由配置"><a href="#route-路由配置" class="headerlink" title="route 路由配置"></a><strong>route 路由配置</strong></h4><p>route定义一个基于标签匹配规则的告警路由树，AlertManager根据route决定receiver。</p>
<p>每一个告警都会从顶级的route进入路由树，默认情况下，告警进入到顶级route后会遍历所有的子节点，直到找到最深的匹配route(最长匹配原则)，并将告警发送到该route定义的receiver中，但可通过<code>continue: [true|false]</code>决定是否继续匹配后续子route。</p>
<p>路由匹配有两种方式:</p>
<ul>
<li>基于字符串验证<code>match</code>: 根据<code>labelname</code>是否等于<code>labelvalue</code>进行匹配</li>
<li>基于正则表达式<code>match_re</code>: 根据<code>labelvalue</code>是否满意正则表达式进行匹配</li>
</ul>
<p>告警分组是通过<code>group_by</code>来定义，基于告警中包含的<code>label</code>进行分组，分组主要由4个配置项:</p>
<ul>
<li><code>group_by</code>: 根据label定义分组，相同label会被合并成一个通知。<code>group_by: [key1, key2]</code>，只有在key1和key2都一样，才会被分到一个组</li>
<li><code>group_wait</code>: 等待时间以收集多个告警，以便进行分组、去重和合并</li>
<li><code>group_interval</code>: 定义相同分组之间发送告警的时间间隔</li>
<li><code>repeat_interval</code>: 警报已经成功发送通知, 设置下次发送告警通知之前要等待时间</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route:&#10;  receiver: &#39;default-receiver&#39;&#9;&#9;# &#40664;&#35748;receiver&#10;  group_wait: 30s&#10;  group_interval: 5m&#10;  repeat_interval: 4h&#10;  group_by: [cluster, alertname]&#9;# &#40664;&#35748;&#25353;&#29031;cluster &#21644; alertname &#36827;&#34892;&#20998;&#32452;&#10;&#10;  routes:&#10;  # DB&#23376;route&#65292;&#21578;&#35686;&#21253;&#21547;service label&#65292;&#33509;service&#26631;&#31614;&#21253;&#21547;mysql&#25110;cassandra&#20851;&#38190;&#23383;&#65292;&#21017;&#21457;&#36865;&#32473;&#21517;&#20026;`database-pager`&#30340;receiver&#12290;&#10;  # &#30001;&#20110;DB&#23376;route&#27809;&#26377;&#35774;&#32622;`group_by`&#65292;&#32487;&#25215;&#40664;&#35748;&#35774;&#32622;group_by: [cluster, alertname]&#10;  - receiver: &#39;database-pager&#39;&#10;    group_wait: 10s&#10;    match_re:&#10;      service: mysql|cassandra&#10;  #&#10;  - receiver: &#39;frontend-pager&#39;&#10;    group_by: [product, environment]&#10;    match:&#10;      team: frontend</span><br></pre></td></tr></table></figure>
<h4 id="receiver-接收配置"><a href="#receiver-接收配置" class="headerlink" title="receiver 接收配置"></a><strong>receiver 接收配置</strong></h4><p>每个receiver具有全局唯一名称，一个receiver可有多种通知方式(email/webhook/slack…)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receivers:&#10;- name: &#39;webhook&#39;&#10;  webhook_configs:&#10;    - url: &#39;http://xxxxxx/xxxxxx&#39;&#10;&#10;- name: &#39;email&#39;&#10;  email_configs:&#10;    - to: &#39;&#39;&#10;&#10;- name: &#39;default&#39;&#10;  webhook_configs:&#10;    - url: &#39;http://xxxxxx/xxxxxx&#39;&#10;  email_configs:&#10;    - to: &#39;&#39;</span><br></pre></td></tr></table></figure>
<h4 id="inhibit-rules-抑制配置"><a href="#inhibit-rules-抑制配置" class="headerlink" title="inhibit_rules 抑制配置"></a><strong>inhibit_rules 抑制配置</strong></h4><p>抑制规则能有效防止告警风暴，主要有3个配置项目:</p>
<ul>
<li><code>target_match|target_match_re</code>:  匹配已发送告警</li>
<li><code>source_match|source_match_re</code>:  匹配新入告警</li>
<li><code>equal</code>:  定义label，匹配新告警的label和target_match|target_match_re中的label</li>
</ul>
<p>已经发送的告警通知匹配到target_match或target_match_re规则，当有新的告警规则如果满足source_match或source_match_re，并且已发送的告警与新产生的告警中equal定义的标签完全相同，则启动抑制机制，新的告警不会发送。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- source_match:&#10;    alertname: NodeDown&#10;    severity: critical&#10;  target_match:&#10;    severity: critical&#10;  equal:&#10;    - node</span><br></pre></td></tr></table></figure>
<p>当集群中的某一个主机节点异常宕机导致告警NodeDown被触发，同时在告警规则中定义了告警级别severity=critical。由于主机异常宕机，该主机上部署的所有服务，中间件会不可用并触发报警。根据抑制规则的定义，如果有新的告警级别为severity=critical，并且告警中标签node的值与NodeDown告警的相同，则说明新的告警是由NodeDown导致的，则启动抑制机制停止向接收器发送通知。</p>
<h2 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a><strong>Exporter</strong></h2><h3 id="elasticsearch-exporter"><a href="#elasticsearch-exporter" class="headerlink" title="elasticsearch_exporter"></a><strong>elasticsearch_exporter</strong></h3><p><a href="https://github.com/justwatchcom/elasticsearch_exporter" target="_blank" rel="external">elasticsearch_exporter</a></p>
<ul>
<li><p>安装</p>
<p>直接下载二进制包 <a href="https://github.com/justwatchcom/elasticsearch_exporter/releases" target="_blank" rel="external">elasticsearch_exporter release</a></p>
</li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./elasticsearch_exporter -es.uri "http://192.168.1.180:9200" -es.all -es.indices</span></span><br><span class="line"><span class="comment"># nohup ./elasticsearch_exporter -es.uri "http://localhost:9200" &amp;&gt; elasticsearch_exporter.log &amp;</span></span><br><span class="line"><span class="comment"># nohup ./elasticsearch_exporter -es.uri "http://192.168.1.181:9200" -web.listen-address "192.168.1.181:9108" &amp;&gt; elasticsearch_exporter.log &amp;</span></span><br><span class="line">./elasticsearch_exporter -es.uri <span class="string">"http://192.168.1.180:9200"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>prometheus配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># prometheus.yml&#10;  - job_name: &#39;elasticsearch&#39;&#10;    static_configs:&#10;    - targets: [&#39;localhost:9108&#39;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="redis-exporter"><a href="#redis-exporter" class="headerlink" title="redis_exporter"></a><strong>redis_exporter</strong></h3><p><a href="https://github.com/oliver006/redis_exporter" target="_blank" rel="external">redis_exporter</a></p>
<ul>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/oliver006/redis_exporter</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/oliver006/redis_exporter</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./redis_exporter -redis.addr <span class="number">10.10</span>.<span class="number">10.68</span>:<span class="number">63910</span>,<span class="number">10.10</span>.<span class="number">10.49</span>:<span class="number">63910</span> -redis.password <span class="string">'&lt;redis_password&gt;'</span> &amp;&gt; redis_exporter.log &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>prometheus配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># prometheus.yml&#10;  - job_name: &#39;redis&#39;&#10;    static_configs:&#10;    - targets: [&#39;localhost:9121&#39;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="rabbitmq-exporter"><a href="#rabbitmq-exporter" class="headerlink" title="rabbitmq_exporter"></a><strong>rabbitmq_exporter</strong></h3><p><a href="https://github.com/kbudde/rabbitmq_exporter" target="_blank" rel="external">rabbitmq_exporter</a></p>
<ul>
<li><p>安装</p>
<p>二进制包 <a href="https://github.com/kbudde/rabbitmq_exporter/releases" target="_blank" rel="external">rabbitmq_exporter release</a></p>
</li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PUBLISH_PORT=9419 RABBIT_CAPABILITIES=bert,no_sort RABBIT_URL="http://192.168.1.180:15672" RABBIT_USER="&lt;user&gt;" RABBIT_PASSWORD="&lt;password&gt;" nohup ./rabbitmq_exporter &amp;&gt; rabbitmq_exporexporter.log &amp;</span></span><br><span class="line">PUBLISH_PORT=<span class="number">9419</span>  RABBIT_URL=<span class="string">"http://10.10.10.32:15672"</span> RABBIT_EXPORTERS=<span class="string">"exchange,node,overview,queue,connections"</span> RABBIT_USER=<span class="string">"&lt;user&gt;"</span> RABBIT_PASSWORD=<span class="string">"&lt;password&gt;"</span> nohup ./rabbitmq_exporter &amp;&gt; /var/<span class="built_in">log</span>/rabbitmq_exporter.log &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>prometheus配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># prometheus.yml&#10;  - job_name: &#39;rabbitmq&#39;&#10;    static_configs:&#10;    - targets: [&#39;localhost:9419&#39;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="node-exporter"><a href="#node-exporter" class="headerlink" title="node_exporter"></a><strong>node_exporter</strong></h3><p><a href="https://github.com/prometheus/node_exporter" target="_blank" rel="external">node_exporter</a></p>
<ul>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum install glibc-static</span><br><span class="line">mkdir -p <span class="variable">$GOPATH</span>/src/golang.org/x/</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/golang.org/x/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/tools.git</span><br><span class="line"></span><br><span class="line">go get github.com/prometheus/node_exporter</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;GOPATH-$HOME/go&#125;</span>/src/github.com/prometheus/node_exporter</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_exporter &lt;flags&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># prometheus.yml&#10;  - job_name: &#39;node&#39;&#10;    static_configs:&#10;    - targets: [&#39;localhost:9100&#39;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="mysql-exporter"><a href="#mysql-exporter" class="headerlink" title="mysql_exporter"></a><strong>mysql_exporter</strong></h3><p><a href="https://github.com/prometheus/mysqld_exporter" target="_blank" rel="external">mysql_exporter</a></p>
<ul>
<li><p>mysql授权</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#39;exporter&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;mysql_exporter&#39; WITH MAX_USER_CONNECTIONS 3;&#10;GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO &#39;exporter&#39;@&#39;localhost&#39;;&#10;FLUSH PRIVILEGES;&#10;&#10;# 5.1&#10;# CREATE USER &#39;exporter&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;mysql_exporter&#39;;&#10;# GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO &#39;exporter&#39;@&#39;localhost&#39; WITH MAX_USER_CONNECTIONS 3;&#10;# FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<p>二进制包 <a href="https://github.com/prometheus/mysqld_exporter/releases/" target="_blank" rel="external">mysql_exporter release</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O mysqld_exporter-<span class="number">0.10</span>.<span class="number">0</span>.linux-amd64.tar.gz <span class="string">'https://github.com/prometheus/mysqld_exporter/releases/download/v0.10.0/mysqld_exporter-0.10.0.linux-amd64.tar.gz'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#.my.cnf</span></span><br><span class="line">[client]</span><br><span class="line">user=exporter</span><br><span class="line">password=<span class="string">"&lt;mysql_password&gt;"</span></span><br><span class="line">port=<span class="number">3306</span></span><br><span class="line">host=localhost</span><br><span class="line"></span><br><span class="line">./mysqld_exporter -config.my-cnf=<span class="string">".my.cnf"</span></span><br><span class="line"><span class="comment">#./mysqld_exporter -config.my-cnf=".my.cnf" -web.listen-address="192.168.1.181:9104"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>prometheus配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># prometheus.yml&#10;  - job_name: &#39;mysql&#39;&#10;    static_configs:&#10;    - targets: [&#39;10.10.10.136:9115&#39;]&#10;      labels:&#10;        db_instance: db1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="mongodb-exporter"><a href="#mongodb-exporter" class="headerlink" title="mongodb_exporter"></a><strong>mongodb_exporter</strong></h3><p><a href="https://github.com/dcu/mongodb_exporter" target="_blank" rel="external">mongodb_exporter</a></p>
<ul>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl https://glide.sh/get | sh</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/dcu/mongodb_exporter <span class="variable">$GOPATH</span>/src/github.com/dcu/mongodb_exporter</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/dcu/mongodb_exporter</span><br><span class="line">make build</span><br><span class="line">./mongodb_exporter -h</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./mongodb_exporter -mongodb.uri mongodb://<span class="number">10.10</span>.<span class="number">10.20</span>:<span class="number">27003</span></span><br><span class="line"><span class="comment"># nohup ./mongodb_exporter -mongodb.uri mongodb://10.10.10.20:27003 -web.listen-address ":9001" &amp;&gt; /var/log/mongodb_exporter1.log &amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>prometheus配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># promethues&#10;  - job_name: &#39;mongodb&#39;&#10;    static_configs:&#10;    - targets: [&#39;10.10.11.15:9001&#39;]&#10;      labels:&#10;        mgroup: APP&#10;        maddr: 10.10.10.20:27003</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a><strong>Adapter</strong></h2><h3 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a><strong>InfluxDB</strong></h3><p>prometheus默认的adapter支持<code>Graphite</code>、<code>OpenTSDB</code>、<code>InfluxDB</code>，<a href="https://github.com/prometheus/prometheus/tree/master/documentation/examples/remote_storage/remote_storage_adapter" target="_blank" rel="external">remote_storage_adapter</a></p>
<ul>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/prometheus/prometheus/documentation/examples/remote_storage/remote_storage_adapter</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/github.com/prometheus/prometheus/documentation/examples/remote_storage/remote_storage_adapter</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./remote_storage_adapter -influxdb-url=http://localhost:<span class="number">8086</span>/ -influxdb.database=prometheus -influxdb.retention-policy=autogen</span><br></pre></td></tr></table></figure>
</li>
<li><p>prometheus配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#prometheus.yml&#10;remote_write:&#10;  - url: &#34;http://localhost:9201/write&#34;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a><strong>ElasticSearch</strong></h3><p>使用<a href="https://github.com/infonova/prometheusbeat" target="_blank" rel="external">Prometheusbeat</a>(Go &gt;= 1.9)作为adapter进行远程写，此adapter处于<strong>alpha</strong>版本</p>
<ul>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/elastic/beats</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;GOPATH&#125;</span>/github.com/infonova/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/infonova/prometheusbeat</span><br><span class="line"><span class="built_in">cd</span> prometheusbeat</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># prometheusbeat.yml&#10;prometheusbeat:&#10;  listen: &#34;:8080&#34;&#10;  context: &#34;/prometheus&#34;&#10;  version: 2&#10;setup.kibana:&#10;output.elasticsearch:&#10;  hosts: [&#34;localhost:9200&#34;]</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># prometheus.yml&#10;remote_write:&#10;  - url: &#34;http://localhost:8080/prometheus&#34;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#./prometheusbeat -c prometheusbeat.yml -e -d "*"</span></span><br><span class="line">./prometheusbeat -c prometheusbeat.yml</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a><strong>高可用</strong></h2><p>待续…</p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a><strong>服务发现</strong></h2><p>待续…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>参考资料</p>
<ul>
<li><a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="external">Prometheus中文</a></li>
<li><a hre]]>
    </summary>
    
      <category term="GO" scheme="http://yoursite.com/tags/GO/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CDH集群运维杂记]]></title>
    <link href="http://yoursite.com/2017/12/05/cdh-ops/"/>
    <id>http://yoursite.com/2017/12/05/cdh-ops/</id>
    <published>2017-12-05T07:45:33.000Z</published>
    <updated>2019-03-31T04:24:48.664Z</updated>
    <content type="html"><![CDATA[<p>整理笔记时简单汇总了有关日常运维配置CDH集群相关的内容，比较杂乱而且许多地方本应该有截图，但由于在七牛的图床废弃了，导致只能用文字说明。权当总结记录备忘吧。</p>
<h2 id="CDH集群集成LDAP服务"><a href="#CDH集群集成LDAP服务" class="headerlink" title="CDH集群集成LDAP服务"></a><strong>CDH集群集成LDAP服务</strong></h2><p>使用的是OpenLDAP，OpenLDAP的安装配置详见：<a href="http://moguol.github.io/2017/11/22/OpenLDAP/" target="_blank" rel="external">OpenLDAP</a></p>
<h3 id="Hive集成OpenLDAP"><a href="#Hive集成OpenLDAP" class="headerlink" title="Hive集成OpenLDAP"></a><strong>Hive集成OpenLDAP</strong></h3><ol>
<li>Hive -&gt; 配置 -&gt; 搜索框输入”LDAP”</li>
<li>勾选<strong>启用 LDAP 身份验证 Hive(服务范围)</strong></li>
<li>修改配置:</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>LDAP URL</strong><br><code>hive.server2.authentication.ldap.url</code></td>
<td style="text-align:left"><code>ldap://hadoop222</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>LDAP BaseDN</strong><br><code>hive.server2.authentication.ldap.baseDN</code></td>
<td style="text-align:left"><code>ou=users,dc=your_domain,dc=com</code></td>
</tr>
</tbody>
</table>
<h4 id="验证Hive-OpenLDAP"><a href="#验证Hive-OpenLDAP" class="headerlink" title="验证Hive OpenLDAP"></a><strong>验证Hive OpenLDAP</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原生Hive</span></span><br><span class="line">beeline -u <span class="string">"jdbc:hive2://hadoop222:10000"</span> -n &lt;user_name&gt; -p &lt;user_password&gt; <span class="operator">-d</span> org.apache.hive.jdbc.HiveDriver</span><br><span class="line"><span class="comment"># Hive结合ZooKeeper</span></span><br><span class="line">beeline -u <span class="string">"jdbc:hive2://hadoop222:2181,hadoop223:2181,hadoop224:2181/;serviceDiscoveryMode=zooKeeper;zooKeeperNamespace=hiveserver2"</span> -n &lt;user_name&gt; -p &lt;user_password&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Impala集成OpenLDAP"><a href="#Impala集成OpenLDAP" class="headerlink" title="Impala集成OpenLDAP"></a><strong>Impala集成OpenLDAP</strong></h3><ol>
<li>Impala -&gt; 配置 -&gt; 搜索框输入”LDAP”</li>
<li>勾选<strong>启用 LDAP 身份验证 Impala(服务范围)</strong>(<code>enable_ldap_auth</code>)</li>
<li>修改配置:</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>LDAP URL</strong><br><code>ldap_uri</code></td>
<td style="text-align:left"><code>ldap://hadoop222</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>LDAP BaseDN</strong><br><code>ldap_baseDN</code></td>
<td style="text-align:left"><code>ou=users,dc=your_domain,dc=com</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>Impala 命令行参数高级配置代码段（安全阀）</strong></td>
<td style="text-align:left"><strong><code>--ldap_passwords_in_clear_ok</code></strong></td>
</tr>
</tbody>
</table>
<p>因为使用的是<code>ldap</code>而非<code>ldaps</code>，所以需要配置<code>--ldap_passwords_in_clear_ok</code>。</p>
<h4 id="验证Impala-OpenLDAP"><a href="#验证Impala-OpenLDAP" class="headerlink" title="验证Impala OpenLDAP"></a><strong>验证Impala OpenLDAP</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impala-shell <span class="operator">-l</span> -u &lt;user_name&gt; --auth_creds_ok_<span class="keyword">in</span>_clear</span><br></pre></td></tr></table></figure>
<h3 id="HUE集成OpenLDAP"><a href="#HUE集成OpenLDAP" class="headerlink" title="HUE集成OpenLDAP"></a><strong>HUE集成OpenLDAP</strong></h3><ol>
<li>HUE -&gt; 配置 -&gt; 搜索框输入”LDAP”</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>身份验证后端</strong><br><code>backend</code></td>
<td style="text-align:left"><strong>desktop.auth.backend.LdapBackend</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>LDAP URL</strong><br><code>ldap_uri</code></td>
<td style="text-align:left"><code>ldap://hadoop222</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>LDAP 用户名模式</strong><br><code>ldap_username_pattern</code></td>
<td style="text-align:left"><strong><code>uid=&lt;username&gt;,ou=users,dc=your_domain,dc=com</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>hue_safety_valve.ini 的 Hue 服务高级配置代码段（安全阀）</strong></td>
<td style="text-align:left">[impala]<br>server_host=hadoop222<br>server_interface=hiveserver2<br>server_port=21050<br>query_timeout_s=100<br>impersonation_enabled=True<br>auth_username=hue<br>auth_password=<code>&lt;hue_password&gt;</code><br><br>[beeswax]<br>close_queries=True<br>use_sasl=False<br>auth_username=hue<br>auth_password=<code>&lt;hue_password&gt;</code></td>
</tr>
</tbody>
</table>
<p>Hue登录时，需要使用一个预设的用户名和密码去连接hive/impala，连接成功之后，当真正执行SQL的时候，还使用登录时的账号来做鉴权，所以需要设置<code>hue_safety_valve.ini</code></p>
<h3 id="配置LDAP组映射"><a href="#配置LDAP组映射" class="headerlink" title="配置LDAP组映射"></a><strong>配置LDAP组映射</strong></h3><p>HDFS默认是基于系统用户组进行管理，若新增一个组需要在所有集群节点机器上创建用户组，管理起来非常繁琐。配置LDAP组映射，让HDFS使用LDAP组方便管理。</p>
<ol>
<li>HDFS -&gt; 配置 -&gt; 范围 -&gt; HDFS(服务范围) -&gt; 类别 -&gt; 安全性 -&gt; 搜索框输入”LDAP”</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Hadoop 用户组映射实现</strong> <br>(<code>hadoop.security.group.mapping</code>)</td>
<td style="text-align:left"><strong><code>org.apache.hadoop.security.LdapGroupsMapping</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Hadoop 用户组 进程ping LDAP URL</strong><br>(<code>hadoop.security.group.mapping.ldap.url</code>)</td>
<td style="text-align:left"><strong><code>ldap://hadoop222</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Hadoop 用户组映射 LDAP 绑定用户可分辨名称</strong><br>(<code>hadoop.security.group.mapping.ldap.bind.user</code>)</td>
<td style="text-align:left"><strong><code>cn=admin,dc=your_domain,dc=com</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Hadoop 用户组 进程ping LDAP 绑定用户密码</strong><br>(<code>hadoop.security.group.mapping.ldap.bind.password</code>)</td>
<td style="text-align:left"><code>&lt;admin_password&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>Hadoop 用户组 进程ping 搜索基础</strong><br>(<code>hadoop.security.group.mapping.ldap.base</code>)</td>
<td style="text-align:left"><strong><code>dc=your_domain,dc=com</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Hadoop 用户组 进程ping LDAP 用户搜索筛选器</strong><br>(<code>hadoop.security.group.mapping.ldap.search.filter.user</code>)</td>
<td style="text-align:left"><strong><code>(&amp;(objectClass=inetOrgPerson)(uid={0}))</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Hadoop 用户组 进程ping LDAP 组搜索筛选器</strong><br>(<code>hadoop.security.group.mapping.ldap.search.filter.group</code>)</td>
<td style="text-align:left"><strong><code>(objectClass=groupOfNames)</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Hadoop 用户组 进程ping LDAP 组成员身份属性</strong><br>(<code>hadoop.security.group.mapping.ldap.search.attr.member</code>)</td>
<td style="text-align:left"><strong><code>member</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Hadoop 用户组 进程ping LDAP 组名称属性</strong><br>(<code>hadoop.security.group.mapping.ldap.search.attr.group.name</code>)</td>
<td style="text-align:left"><strong><code>cn</code></strong></td>
</tr>
</tbody>
</table>
<h2 id="CDH配置Sentry"><a href="#CDH配置Sentry" class="headerlink" title="CDH配置Sentry"></a><strong>CDH配置Sentry</strong></h2><h3 id="Sentry准备工作"><a href="#Sentry准备工作" class="headerlink" title="Sentry准备工作"></a><strong>Sentry准备工作</strong></h3><h4 id="设置Hive-warehouse目录权限"><a href="#设置Hive-warehouse目录权限" class="headerlink" title="设置Hive warehouse目录权限"></a><strong>设置Hive warehouse目录权限</strong></h4><p>如果HDFS没有开启Sentry同步服务，则需要执行以下准备工作，否则跳过。Hive warehouse默认设置为<code>/user/hive/warehouse</code>(<code>hive-site.xml</code>/<strong><code>hive.metastore.warehouse.dir</code></strong>)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果开启了Kerberos则需要执行kinit</span></span><br><span class="line"><span class="comment"># sudo -u hdfs kinit -kt &lt;hdfs.keytab&gt; hdfs</span></span><br><span class="line">sudo -u hdfs hdfs dfs -chmod -R <span class="number">771</span> /user/hive/warehouse</span><br><span class="line">sudo -u hdfs hdfs dfs -chown -R hive:hive /user/hive/warehouse</span><br></pre></td></tr></table></figure></p>
<h4 id="禁止HiveServer2-启用模拟"><a href="#禁止HiveServer2-启用模拟" class="headerlink" title="禁止HiveServer2 启用模拟"></a><strong>禁止HiveServer2 启用模拟</strong></h4><ol>
<li>Hive -&gt; 配置 -&gt; 范围 -&gt; HiveServer2 -&gt; 类别 -&gt; 主要 -&gt; 取消<strong>HiveServer2 启用模拟</strong>(<code>hive.server2.enable.impersonation, hive.server2.enable.doAs</code>)</li>
</ol>
<h4 id="允许Hive用户提交YARN任务"><a href="#允许Hive用户提交YARN任务" class="headerlink" title="允许Hive用户提交YARN任务"></a><strong>允许Hive用户提交YARN任务</strong></h4><ol>
<li>YARN -&gt; 配置 -&gt; 范围 -&gt; NodeManager -&gt; 类别 -&gt; 安全性 -&gt; <strong>允许的系统用户</strong>(<code>allowed.system.users</code>) -&gt; 添加<code>hive</code>、<code>impala</code>用户等用户</li>
</ol>
<h4 id="禁止Hive命令行用户访问Hive-metastore"><a href="#禁止Hive命令行用户访问Hive-metastore" class="headerlink" title="禁止Hive命令行用户访问Hive metastore"></a><strong>禁止Hive命令行用户访问Hive metastore</strong></h4><ol>
<li>Hive -&gt; 配置 -&gt; <strong>Hive Metastore 访问控制和代理用户组覆盖</strong>(<code>hadoop.proxyuser.hive.groups</code>) -&gt; 添加<code>hive</code>、<code>hue</code>用户(允许<code>hive</code>/<code>hue</code>用户访问hive metastore，若使用sqoop，确保<code>sqoop</code>用户也添加)</li>
<li>Hive/Impala -&gt; <strong>使用政策文件启用 Sentry 授权</strong>(<code>hive.sentry.enabled</code>/<code>impala.sentry.enabled</code>)没有勾选</li>
</ol>
<h3 id="Hive配置Sentry"><a href="#Hive配置Sentry" class="headerlink" title="Hive配置Sentry"></a><strong>Hive配置Sentry</strong></h3><ol>
<li>Hive -&gt; 配置 -&gt; 范围 -&gt; Hive(服务范围) -&gt; 类别 -&gt; 主要 -&gt; <strong>Sentry服务</strong> -&gt; <strong>Sentry</strong></li>
<li>由于Hive要求使用SSL安全传输，暂时没有配置，需要将<code>sentry.hive.testing.mode</code>设置为<code>true</code><ul>
<li>Hive -&gt; 配置 -&gt; <strong>sentry-site.xml 的 Hive 服务高级配置代码段（安全阀）</strong><ul>
<li><strong>sentry.hive.testing.mode</strong></li>
<li><strong>true</strong></li>
</ul>
</li>
</ul>
</li>
<li>重启Hive</li>
</ol>
<h4 id="Hive-授权"><a href="#Hive-授权" class="headerlink" title="Hive 授权"></a><strong>Hive 授权</strong></h4><p>Hive在配置了Sentry、OpenLDAP和HDFS LDAP组映射环境下的授权操作</p>
<ol>
<li>创建OpenLDAP用户</li>
<li>Hive用户授权 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create role &lt;ldap_user_name&gt;;</span><br><span class="line">grant role &lt;ldap_user_name&gt; to group &lt;ldap_user_name&gt;;</span><br><span class="line">grant [all|alert|update|create|drop|index|lock|select|show_database] on database &lt;db_name&gt; to role &lt;ldap_user_name&gt;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Impala配置Sentry"><a href="#Impala配置Sentry" class="headerlink" title="Impala配置Sentry"></a><strong>Impala配置Sentry</strong></h3><ol>
<li>需要先执行Hive配置Sentry</li>
<li>Impala -&gt; 配置 -&gt; 范围 -&gt; Impala(服务范围) -&gt; 类别 -&gt; 主要 -&gt; <strong>Sentry服务</strong> -&gt; <strong>Sentry</strong></li>
<li>由于Hive要求使用SSL安全传输，暂时没有配置，需要将<code>sentry.hive.testing.mode</code>设置为<code>true</code><ul>
<li>Hive -&gt; 配置 -&gt; <strong>sentry-site.xml 的 Impala 服务高级配置代码段（安全阀）</strong><ul>
<li><strong>sentry.hive.testing.mode</strong></li>
<li><strong>true</strong></li>
</ul>
</li>
</ul>
</li>
<li>重启Impala</li>
</ol>
<h3 id="HUE配置Sentry"><a href="#HUE配置Sentry" class="headerlink" title="HUE配置Sentry"></a><strong>HUE配置Sentry</strong></h3><ol>
<li>需要先执行Hive &amp; Impala配置Sentry</li>
<li>HUE -&gt; 配置 -&gt; 范围 -&gt; HUE(服务范围) -&gt; 类别 -&gt; 主要 -&gt; <strong>Sentry服务</strong> -&gt; <strong>Sentry</strong></li>
<li>由于Hive要求使用SSL安全传输，暂时没有配置，需要将<code>sentry.hive.testing.mode</code>设置为<code>true</code><ul>
<li>HUE -&gt; 配置 -&gt; <strong>sentry-site.xml 的 HUE 服务高级配置代码段（安全阀）</strong><ul>
<li><strong>sentry.hive.testing.mode</strong></li>
<li><strong>true</strong></li>
</ul>
</li>
</ul>
</li>
<li>重启HUE</li>
</ol>
<h3 id="将Hive、Impala和HUE组加入到Sentry管理员组"><a href="#将Hive、Impala和HUE组加入到Sentry管理员组" class="headerlink" title="将Hive、Impala和HUE组加入到Sentry管理员组"></a><strong>将Hive、Impala和HUE组加入到Sentry管理员组</strong></h3><ol>
<li>Sentry -&gt; 配置 -&gt; 范围 -&gt; Sentry(服务范围) -&gt; 类别 -&gt; 主要 -&gt; <strong>管理员组</strong>(<code>sentry.service.admin.group</code>) -&gt; 添加<code>hive</code>、<code>impala</code>和<code>hue</code>组</li>
</ol>
<h2 id="HUE配置MySQL数据库"><a href="#HUE配置MySQL数据库" class="headerlink" title="HUE配置MySQL数据库"></a><strong>HUE配置MySQL数据库</strong></h2><p>HUE默认使用<strong>Sqlite3</strong>作为存储<code>/var/lib/hue/desktop.db</code>。<br>如果不需要Sqlite3里面的数据，就不需要进行<code>migration</code>迁移数据，直接创建HUE数据库并指定MySQL做存储，重启即可。<br>若有多个HUE Server，注意多个HUE Server都需要能登录MySQL。</p>
<h3 id="创建HUE数据库"><a href="#创建HUE数据库" class="headerlink" title="创建HUE数据库"></a><strong>创建HUE数据库</strong></h3><p>在配置前需要在MySQL中手动创建HUE数据库。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE hue DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br><span class="line">mysql&gt; GRANT all on hue.* to <span class="string">'hue'</span>@<span class="string">'%'</span> identified by <span class="string">'huepassword'</span>;</span><br><span class="line">mysql&gt; GRANT all on hue.* to <span class="string">'hue'</span>@<span class="string">'localhost'</span> identified by <span class="string">'huepassword'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="HUE连接MySQL"><a href="#HUE连接MySQL" class="headerlink" title="HUE连接MySQL"></a><strong>HUE连接MySQL</strong></h3><p>如果还需要Sqlite3的数据则需要<strong><code>migration</code></strong>(以下带有<strong><code>migration only</code></strong>字样)，否则就不需要(<code>2/4/5</code>不需要做)。</p>
<ol>
<li>停止HUE服务<br> 在Cloudera Manager中将HUE服务停止</li>
<li><p>导出现有数据(<strong>migration only</strong>)</p>
<ul>
<li>操作 -&gt; 转储数据库 / (HUE -&gt; Actions -&gt; Dump Database.)</li>
<li>转储数据库(Dump Database.)，数据会导出到HUE服务器的<code>/tmp/hue_database_dump.json</code>中。</li>
<li>编辑<code>/tmp/hue_database_dump.json</code>，把<strong>所有</strong><code>model</code>中的<code>useradmin.userprofile</code>相关内容删除  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"pk"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"model"</span>: <span class="string">"useradmin.userprofile"</span>,</span><br><span class="line">    <span class="string">"fields"</span>: &#123;</span><br><span class="line">        <span class="string">"last_activity"</span>: <span class="string">"2016-10-03T10:06:13"</span>,</span><br><span class="line">        <span class="string">"creation_method"</span>: <span class="string">"HUE"</span>,</span><br><span class="line">        <span class="string">"first_login"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"user"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"home_directory"</span>: <span class="string">"/user/admin"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>连接MySQL<br> Cloudera Manager中打开HUE -&gt; 配置 -&gt; 类别-数据库</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DB Hostname = IP</span><br><span class="line">DB Port = <span class="number">3306</span></span><br><span class="line">DB Type = MySQL</span><br><span class="line">DB Name = hue</span><br><span class="line">Username = hue</span><br><span class="line">Password = &lt;hue_password&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步数据(<strong>migration only</strong>)</p>
<ul>
<li>HUE -&gt; 操作 -&gt; 同步数据库 / (HUE -&gt; Actions -&gt; Synchronize Database)</li>
<li>同步数据库 / (Synchronize Database)</li>
</ul>
</li>
<li><p>导入旧数据(<strong>migration only</strong>)</p>
<ul>
<li><p>清除外键 &amp; 删除<code>django_content_type</code></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE table hue.auth_permission;</span><br><span class="line">mysql&gt; ALTER TABLE hue.auth_permission DROP FOREIGN KEY &lt;content_<span class="built_in">type</span>_id_refs_id_xxxxxx&gt;;</span><br><span class="line">mysql&gt; DELETE FROM hue.django_content_<span class="built_in">type</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cloudera Manager中加载json文件</p>
<ul>
<li>HUE -&gt; 操作 -&gt; 加载数据库 / (HUE -&gt; Actions -&gt; Load Database)</li>
<li>加载数据库 / (Load Database)</li>
</ul>
</li>
<li>重新创建外键  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use hue;</span><br><span class="line">mysql&gt; ALTER TABLE hue.auth_permission ADD FOREIGN KEY (content_<span class="built_in">type</span>_id REFERENCES django_content_<span class="built_in">type</span> (id;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>启动HUE</p>
</li>
</ol>
<h2 id="启用HDFS-High-Availability"><a href="#启用HDFS-High-Availability" class="headerlink" title="启用HDFS High Availability"></a><strong>启用HDFS High Availability</strong></h2><h3 id="配置HDFS-High-Availability"><a href="#配置HDFS-High-Availability" class="headerlink" title="配置HDFS High Availability"></a><strong>配置HDFS High Availability</strong></h3><p>启用HDFS HA，就是不使用存在单点故障的旧版<code>NameNode</code>、<code>Secondary NameNode</code>，采用新的两个<code>NameNode</code>(<code>active NameNode</code>、<code>standby NameNode</code>)的高可用架构。配置前确保部署了ZooKeeper。<br>CDH 5的HDFS HA是使用<strong>Quorum-based storage</strong>实现的，也即是需要使用到<strong>JournalNode</strong>。<br>Cloudera Manager中执行以下操作：</p>
<ol>
<li>HDFS -&gt; 操作 -&gt; 启用High Availability</li>
<li>设置<strong>nameservice</strong>名称，默认为<code>nameservice1</code></li>
<li>添加一个新<strong>NameNode</strong>(standby namenode)、添加<strong>JournalNode</strong>(至少3个以上奇数个JournalNode)</li>
<li>启用HDFS High Availability</li>
</ol>
<h3 id="更新Hive-Metastore-NameNode-Nameservice名称"><a href="#更新Hive-Metastore-NameNode-Nameservice名称" class="headerlink" title="更新Hive Metastore NameNode Nameservice名称"></a><strong>更新Hive Metastore NameNode Nameservice名称</strong></h3><ol>
<li>停止Hive。Hive -&gt; 操作 -&gt; 停止 (若有HUE或Impala，先停止HUE或Impala再停Hive)</li>
<li>保险起见可先使用<code>mysqldump</code>备份Hive metastore数据库</li>
<li>Hive -&gt; 操作 -&gt; 更新Hive Metastore NameNodes</li>
<li>启动Hive。Hive -&gt; 操作 -&gt; 启动 (若有HUE或Impala则启动)</li>
</ol>
<h3 id="启用HUE-High-Availability"><a href="#启用HUE-High-Availability" class="headerlink" title="启用HUE High Availability"></a><strong>启用HUE High Availability</strong></h3><p>启用HDFS HA后，HUE也可启用HA。</p>
<h4 id="添加HttpFS角色"><a href="#添加HttpFS角色" class="headerlink" title="添加HttpFS角色"></a><strong>添加HttpFS角色</strong></h4><ol>
<li>HDFS -&gt; 实例 -&gt; 操作 -&gt; 添加角色实例 -&gt; 选择HttpFS主机并添加角色</li>
<li>HDFS -&gt; 实例 -&gt; 启动HttpFS</li>
</ol>
<h4 id="配置HUE-High-Availability"><a href="#配置HUE-High-Availability" class="headerlink" title="配置HUE High Availability"></a><strong>配置HUE High Availability</strong></h4><ol>
<li>HUE -&gt; 配置 -&gt; HDFS Web 界面角色 -&gt; 选择HttpFS</li>
<li>重启HUE</li>
</ol>
<h2 id="启用YARN-High-Availability"><a href="#启用YARN-High-Availability" class="headerlink" title="启用YARN High Availability"></a><strong>启用YARN High Availability</strong></h2><p>YARN HA其实就是对ResourceManager做HA，增加一个standby ResourceManager。</p>
<ol>
<li>YARN -&gt; 操作 -&gt; 启用High Availability</li>
<li>选择一台主机作为standby ResourceManager。Cloudera Manager会执行停止YARN、添加standby ResourceManager、在ZooKeeper中初始化ResourceManager HA状态、重启YARN等一系列动作。</li>
</ol>
<h2 id="启用HBase-High-Availability"><a href="#启用HBase-High-Availability" class="headerlink" title="启用HBase High Availability"></a><strong>启用HBase High Availability</strong></h2><p>HBase HA直接添加一个backup Master即可，当active Master宕掉后，backup Master会接替其工作。</p>
<ol>
<li>HBase -&gt; 添加角色实例 -&gt; Master</li>
</ol>
<h2 id="启用Hive-High-Availability"><a href="#启用Hive-High-Availability" class="headerlink" title="启用Hive High Availability"></a><strong>启用Hive High Availability</strong></h2><p>Sentry<code>1.8.0</code>以下版本，<strong>如果开启了HDFS的Sentry同步则Hive Metastore HA不可用。</strong></p>
<h3 id="启用Hive-Metastore-High-Availability"><a href="#启用Hive-Metastore-High-Availability" class="headerlink" title="启用Hive Metastore High Availability"></a><strong>启用Hive Metastore High Availability</strong></h3><ol>
<li>Hive -&gt; 配置 -&gt; 范围 -&gt; Hive Metastore Server -&gt; 类别 -&gt; 高级</li>
<li>Hive Metastore 代理令牌存储 -&gt; <strong>org.apache.hadoop.hive.thrift.DBTokenStore</strong></li>
<li>Hive -&gt; 实例 -&gt; 操作 -&gt; 添加角色实例</li>
<li>添加<strong>Hive Metastore Server</strong>，使得Hive Metastore Server机器数目至少<strong>3</strong>台。</li>
<li>Hive -&gt; 实例。启动新增的Hive Metastore Server角色。</li>
<li>重启Hive服务。(确保所有Hive Metastore Server的服务器都能登录到MySQL)、(Hive Metastore Server需要连接MySQL，会出现红色抑制异常，等待一段时间恢复绿色正常)。</li>
</ol>
<h3 id="启用HiveServer2-Load-Balance-amp-High-Availability"><a href="#启用HiveServer2-Load-Balance-amp-High-Availability" class="headerlink" title="启用HiveServer2 Load Balance &amp; High Availability"></a><strong>启用HiveServer2 Load Balance &amp; High Availability</strong></h3><p>为确保HiveServer2的高可用，Hive结合ZooKeeper提供动态服务发现功能。启用后client(<code>beeline</code>)不直接连接HiveServer2，而是直接连接ZooKeeper然后随机选择一个注册到ZooKeeper中的HiveServer2实例。</p>
<ol>
<li>Hive -&gt; 操作 -&gt; 添加角色实例 -&gt; HiveServer2</li>
<li>新增HiveServer2实例，保证HiveServer2机器数目至少<strong>3</strong>台</li>
<li>启动新增的HiveServer2实例</li>
<li>Hive -&gt; 配置 -&gt; 类别 -&gt; 高级 -&gt; <strong>hive-site.xml 的 HiveServer2 高级配置代码段(安全阀)</strong><ul>
<li>名称: <strong>hive.server2.support.dynamic.service.discovery</strong></li>
<li>值: <strong>true</strong></li>
<li>名称: <strong>hive.zookeeper.quorum</strong></li>
<li>值: <strong>hadoop222:2181,hadoop223:2181,hadoop224:2181</strong></li>
</ul>
</li>
<li>重启Hive</li>
</ol>
<p><code>beeline</code>测试使用ZooKeeper连接Hive<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beeline -u <span class="string">"jdbc:hive2://hadoop222:2181,hadoop223:2181,hadoop224:2181/;serviceDiscoveryMode=zooKeeper;zooKeeperNamespace=hiveserver2"</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>整理笔记时简单汇总了有关日常运维配置CDH集群相关的内容，比较杂乱而且许多地方本应该有截图，但由于在七牛的图床废弃了，导致只能用文字说明。权当总结记录备忘吧。</p>
<h2 id="CDH集群集成LDAP服务"><a href="#CDH集群集成LDAP服务" class]]>
    </summary>
    
      <category term="CDH" scheme="http://yoursite.com/tags/CDH/"/>
    
      <category term="Bigdata" scheme="http://yoursite.com/categories/Bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenLDAP简录]]></title>
    <link href="http://yoursite.com/2017/11/22/OpenLDAP/"/>
    <id>http://yoursite.com/2017/11/22/OpenLDAP/</id>
    <published>2017-11-22T06:23:11.000Z</published>
    <updated>2019-03-31T04:24:48.688Z</updated>
    <content type="html"><![CDATA[<p>此文只是在配置Hive、Impala、HUE和HDFS时需要用到OpenLDAP，故简要的记录了一下有关OpenLDAP相关的内容而已。</p>
<h3 id="OpenLDAP-安装"><a href="#OpenLDAP-安装" class="headerlink" title="OpenLDAP 安装"></a><strong>OpenLDAP 安装</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install openldap openldap-servers openldap-clients openldap-devel compat-openldap</span><br></pre></td></tr></table></figure>
<h3 id="OpenLDAP-配置"><a href="#OpenLDAP-配置" class="headerlink" title="OpenLDAP 配置"></a><strong>OpenLDAP 配置</strong></h3><h4 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a><strong>基础信息</strong></h4><ul>
<li><code>/etc/openldap/slapd.conf</code>: OpenLDAP的主配置文件，记录根域信息，管理员名称，密码，日志，权限等</li>
<li><code>/etc/openldap/slapd.d/</code>: 根据slapd.conf配置信息生成的文件</li>
<li><code>/etc/openldap/schema/</code>: OpenLDAP的schema存放目录</li>
<li><code>/var/lib/ldap/</code>: OpenLDAP数据目录</li>
<li><code>/usr/share/openldap-servers/</code>: OpenLDAP模板文件</li>
<li><code>389端口</code>: 默认监听端口(明文)</li>
<li><code>636端口</code>: 密文监听端口</li>
</ul>
<h4 id="OpenLDAP配置"><a href="#OpenLDAP配置" class="headerlink" title="OpenLDAP配置"></a><strong>OpenLDAP配置</strong></h4><ul>
<li><p>复制模板配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制模板配置文件</span></span><br><span class="line">cp /usr/share/openldap-servers/DB_CONFIG.example /var/lib/ldap/DB_CONFIG</span><br><span class="line">cp /usr/share/openldap-servers/slapd.conf.obsolete /etc/openldap/slapd.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改dc</p>
<p>将<code>dc</code>中的<code>your_domain</code>修改为自定义的<code>dc</code><br>默认<code>cn</code>为<code>Manager</code>，此处修改成<code>cn=admin</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slapd.conf</span></span><br><span class="line"><span class="comment"># enable server status monitoring (cn=monitor)</span></span><br><span class="line">database monitor</span><br><span class="line">access to *</span><br><span class="line">        by dn.exact=<span class="string">"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth"</span> <span class="built_in">read</span></span><br><span class="line">        by dn.exact=<span class="string">"cn=admin,dc=your_domain,dc=com"</span> <span class="built_in">read</span></span><br><span class="line">        by * none</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slapd.conf</span></span><br><span class="line">suffix          <span class="string">"dc=your_domain,dc=com"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slapd.conf</span></span><br><span class="line">rootdn          <span class="string">"cn=admin,dc=your_domain,dc=com"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改LDAP管理员密码</p>
<p>使用<strong><code>slappasswd</code></strong>命令生成密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&gt; slappasswd</span><br><span class="line">New password:</span><br><span class="line">Re-enter new password:</span><br><span class="line">&#123;SSHA&#125;bFTucfZs/ZoWasy4qkZ1JDrggQqt76Oi</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slapd.conf</span></span><br><span class="line">rootpw  &#123;SSHA&#125;bFTucfZs/ZoWasy4qkZ1JDrggQqt76Oi</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置目录权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R ldap:ldap /var/lib/ldap/</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动OpenLDAP</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/slapd start</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试配置文件正确性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次测试需要先启动OpenLDAP</span></span><br><span class="line"><span class="comment"># /etc/init.d/slapd start</span></span><br><span class="line">slaptest <span class="operator">-f</span> /etc/openldap/slapd.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除旧配置、重新生成配置</p>
<p>修改配置文件<code>slapd.conf</code>后都需要移除旧有配置重新生成新配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份移除旧配置文件</span></span><br><span class="line">mv /etc/openldap/slapd.d/* /tmp/</span><br><span class="line"><span class="comment"># 测试配置文件并重新生成配置</span></span><br><span class="line">slaptest <span class="operator">-f</span> /etc/openldap/slapd.conf -F /etc/openldap/slapd.d/ &amp;&amp; chown -R ldap:ldap /etc/openldap/slapd.d/</span><br><span class="line"><span class="comment"># 查看新生成配置</span></span><br><span class="line">egrep <span class="string">'olcSuffix|olcRootDN'</span> /etc/openldap/slapd.d/cn\=config/olcDatabase\=\&#123;<span class="number">2</span>\&#125;bdb.ldif</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启OpenLDAP</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/slapd restart</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="OpenLDAP开启日志"><a href="#OpenLDAP开启日志" class="headerlink" title="OpenLDAP开启日志"></a><strong>OpenLDAP开启日志</strong></h4><ul>
<li><p>OpenLDAP添加配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/openldap/slapd.conf</span></span><br><span class="line">loglevel        <span class="number">4095</span></span><br><span class="line"><span class="comment">#loglevel		256</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置rsyslog</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/rsyslog.conf</span></span><br><span class="line"><span class="built_in">local</span>4.*	/var/<span class="built_in">log</span>/slapd/slapd.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建日志目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/<span class="built_in">log</span>/slapd</span><br><span class="line">chown ldap:ldap /var/<span class="built_in">log</span>/slapd/</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启OpenLDAP &amp; Rsyslog</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rsyslog</span></span><br><span class="line">/etc/init.d/rsyslog restart</span><br><span class="line"><span class="comment"># OpenLDAP</span></span><br><span class="line">rm -rf /etc/openldap/slapd.d/*</span><br><span class="line">slaptest <span class="operator">-f</span> /etc/openldap/slapd.conf -F /etc/openldap/slapd.d/ &amp;&amp; chown -R ldap:ldap /etc/openldap/slapd.d/</span><br><span class="line">/etc/init.d/slapd restart</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="导入管理员信息"><a href="#导入管理员信息" class="headerlink" title="导入管理员信息"></a><strong>导入管理员信息</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root.ldif</span></span><br><span class="line">dn: dc=your_domain,dc=com</span><br><span class="line">objectclass: dcObject</span><br><span class="line">objectclass: organization</span><br><span class="line">o: your_company,Inc.</span><br><span class="line">dc: your_domain</span><br><span class="line"></span><br><span class="line">dn: cn=admin,dc=your_domain,dc=com</span><br><span class="line">objectclass: organizationalRole</span><br><span class="line">cn: admin</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ldapadd -x -W -D <span class="string">"cn=admin,dc=your_domain,dc=com"</span> <span class="operator">-f</span> root.ldif</span><br><span class="line"><span class="comment">#Enter LDAP Password:</span></span><br><span class="line"><span class="comment">#adding new entry "dc=your_domain,dc=com"</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#adding new entry "cn=admin,dc=your_domain,dc=com"</span></span><br><span class="line"><span class="comment">#ldap_add: Server is unwilling to perform (53)</span></span><br><span class="line"><span class="comment">#	additional info: no global superior knowledge</span></span><br></pre></td></tr></table></figure>
<h4 id="新增组"><a href="#新增组" class="headerlink" title="新增组"></a><strong>新增组</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ou.ldif</span></span><br><span class="line">dn: ou=users,dc=your_domain,dc=com</span><br><span class="line">objectClass: organizationalUnit</span><br><span class="line">ou: users</span><br><span class="line"></span><br><span class="line">dn: ou=groups,dc=your_domain,dc=com</span><br><span class="line">objectClass: organizationalUnit</span><br><span class="line">ou: groups</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldapadd -x -W -D <span class="string">"cn=admin,dc=your_domain,dc=com"</span> <span class="operator">-f</span> ou.ldif</span><br></pre></td></tr></table></figure>
<h4 id="新增用户-样例"><a href="#新增用户-样例" class="headerlink" title="新增用户(样例)"></a><strong>新增用户(样例)</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user.ldif</span></span><br><span class="line">dn: uid=mogl,ou=users,dc=your_domain,dc=com</span><br><span class="line">objectClass: inetOrgPerson</span><br><span class="line">sn: mogl</span><br><span class="line">cn: mogl</span><br><span class="line">uid: mogl</span><br><span class="line"></span><br><span class="line">dn: cn=mogl,ou=groups,dc=your_domain,dc=com</span><br><span class="line">objectClass: groupOfNames</span><br><span class="line">cn: mogl</span><br><span class="line">member: uid=mogl,ou=users,dc=your_domain,dc=com</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">ldapadd -x -W -D <span class="string">"cn=admin,dc=your_domain,dc=com"</span> <span class="operator">-f</span> user.ldif</span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line">ldappasswd <span class="operator">-s</span> &lt;password&gt; -W -D <span class="string">"cn=admin,dc=your_domain,dc=com"</span> -x <span class="string">"uid=mogl,ou=users,dc=your_domain,dc=com"</span></span><br></pre></td></tr></table></figure>
<h3 id="OpenLDAP-常用操作"><a href="#OpenLDAP-常用操作" class="headerlink" title="OpenLDAP 常用操作"></a><strong>OpenLDAP 常用操作</strong></h3><h4 id="ldapsearch-搜索"><a href="#ldapsearch-搜索" class="headerlink" title=" ldapsearch 搜索"></a><strong> ldapsearch 搜索</strong></h4><p>-b: 指定查找的节点<br>-D: bindDN 指定查找的DN<br>-v: 详细输出<br>-x: 使用简单的认证 不使用任何加密算法<br>-W: 在查询时 会提示输入密码 如果不想输入密码 使用-w password<br>-h: 指定LDAP主机<br>-H: LDAP URL<br>-p: 指定OpenLDAP的监听端口 默认389 加密为635<br>-LLL: 禁止输出与过滤条件不匹配的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 管理员帐号admin</span></span><br><span class="line">ldapsearch -z max -LLL -Wx -D <span class="string">"cn=admin,dc=your_domain,dc=com"</span> -b <span class="string">"dc=your_domain,dc=com"</span></span><br></pre></td></tr></table></figure>
<h4 id="ldapadd-新增"><a href="#ldapadd-新增" class="headerlink" title="ldapadd 新增"></a><strong>ldapadd 新增</strong></h4><p>-x: 进行简单认证<br>-D: 用来绑定服务器的DN<br>-h: 目录服务的地址<br>-w: 绑定DN的密码<br>-f: 使用ldif文件进行条目添加的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldapadd -x -W -D <span class="string">"cn=admin,dc=your_domain,dc=com"</span> <span class="operator">-f</span> &lt;ldif_file&gt;</span><br></pre></td></tr></table></figure>
<p>脚本添加用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">tmp_ldif=<span class="string">'./tmp_new_user.ldif'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> uid <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"dn: uid=<span class="variable">$uid</span>,ou=users,dc=your_domain,dc=com"</span> &gt;&gt; <span class="variable">$tmp_ldif</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"objectClass: inetOrgPerson"</span> &gt;&gt; <span class="variable">$tmp_ldif</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"sn: <span class="variable">$uid</span>\ncn: <span class="variable">$uid</span>\nuid: <span class="variable">$uid</span>\n"</span> &gt;&gt; <span class="variable">$tmp_ldif</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"dn: cn=<span class="variable">$uid</span>,ou=groups,dc=your_domain,dc=com"</span> &gt;&gt; <span class="variable">$tmp_ldif</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"objectClass: groupOfNames"</span> &gt;&gt; <span class="variable">$tmp_ldif</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"cn: <span class="variable">$uid</span>"</span> &gt;&gt; <span class="variable">$tmp_ldif</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"member: uid=<span class="variable">$uid</span>,ou=users,dc=your_domain,dc=com\n"</span> &gt;&gt; <span class="variable">$tmp_ldif</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">ldapadd -x -W -D <span class="string">"cn=admin,dc=your_domain,dc=com"</span> <span class="operator">-f</span> <span class="variable">$&#123;tmp_ldif&#125;</span></span><br><span class="line"></span><br><span class="line">rm -i <span class="variable">$tmp_ldif</span></span><br></pre></td></tr></table></figure>
<h4 id="ldapdelete-删除"><a href="#ldapdelete-删除" class="headerlink" title="ldapdelete 删除"></a><strong>ldapdelete 删除</strong></h4><p>-c: 持续操作模式 在操作过程中出现错误 也会进行后续相关操作<br>-D: 指定查找的DN<br>-n: 显示正在进行的相关操作 但不实际修改数据 一般用于测试<br>-x: 使用简单的认证<br>-f: 使用目标文件名作为命令的输入<br>-W: 提示输入密码<br>-w: passwd<br>-y: passwdfile 可以将密码写入文件进行验证<br>-r: 递归删除<br>-h: HOST<br>-H: LDAP-URL<br>-p: port</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldapdelete -W -D <span class="string">"cn=admin,dc=your_domain,dc=com"</span> -v <span class="string">"uid=mogl,ou=users,dc=your_domain,dc=com"</span></span><br><span class="line">ldapdelete -W -D <span class="string">"cn=admin,dc=your_domain,dc=com"</span> -v <span class="string">"cn=mogl,ou=groups,dc=your_domain,dc=com"</span></span><br></pre></td></tr></table></figure>
<h3 id="高可用设置"><a href="#高可用设置" class="headerlink" title="高可用设置"></a><strong>高可用设置</strong></h3><h4 id="OpenLDAP-主主配置"><a href="#OpenLDAP-主主配置" class="headerlink" title="OpenLDAP 主主配置"></a><strong>OpenLDAP 主主配置</strong></h4><p>主主两台OpenLDAP中<strong><code>serverID</code></strong>必须一致，<strong><code>rid</code></strong>必须不一样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启模块</span></span><br><span class="line">moduleload syncprov.la</span><br><span class="line"></span><br><span class="line">index entryCSN,entryUUID eq</span><br><span class="line"><span class="comment"># overlay模式</span></span><br><span class="line">overlay syncprov</span><br><span class="line"><span class="comment"># 修改100个条目或者10分钟的条件时主动以推的方式同步</span></span><br><span class="line">syncprov-checkpoint <span class="number">100</span> <span class="number">10</span></span><br><span class="line"><span class="comment"># 会话日志条目的最大数量</span></span><br><span class="line">syncprov-sessionlog <span class="number">100</span></span><br><span class="line"></span><br><span class="line">serverID  <span class="number">1</span></span><br><span class="line">syncrepl  rid=<span class="number">222</span></span><br><span class="line">          provider=ldap://<span class="number">10.201</span>.<span class="number">7.223</span></span><br><span class="line">          bindmethod=simple</span><br><span class="line">          binddn=<span class="string">"cn=admin,dc=your_domain,dc=com"</span></span><br><span class="line">          credentials=mogl</span><br><span class="line">          searchbase=<span class="string">"dc=your_domain,dc=com"</span></span><br><span class="line">          schemachecking=off</span><br><span class="line">          <span class="built_in">type</span>=refreshAndPersist</span><br><span class="line">          retry=<span class="string">"60 +"</span></span><br><span class="line">mirrormode on</span><br></pre></td></tr></table></figure>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h3><h4 id="OpenLDAP配置文件"><a href="#OpenLDAP配置文件" class="headerlink" title="OpenLDAP配置文件"></a><strong>OpenLDAP配置文件</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">include		/etc/openldap/schema/corba.schema</span><br><span class="line">include		/etc/openldap/schema/core.schema</span><br><span class="line">include		/etc/openldap/schema/cosine.schema</span><br><span class="line">include		/etc/openldap/schema/duaconf.schema</span><br><span class="line">include		/etc/openldap/schema/dyngroup.schema</span><br><span class="line">include		/etc/openldap/schema/inetorgperson.schema</span><br><span class="line">include		/etc/openldap/schema/java.schema</span><br><span class="line">include		/etc/openldap/schema/misc.schema</span><br><span class="line">include		/etc/openldap/schema/nis.schema</span><br><span class="line">include		/etc/openldap/schema/openldap.schema</span><br><span class="line">include		/etc/openldap/schema/ppolicy.schema</span><br><span class="line">include		/etc/openldap/schema/collective.schema</span><br><span class="line">allow <span class="built_in">bind</span>_v2</span><br><span class="line">pidfile		/var/run/openldap/slapd.pid</span><br><span class="line">argsfile	/var/run/openldap/slapd.args</span><br><span class="line">TLSCACertificatePath /etc/openldap/certs</span><br><span class="line">TLSCertificateFile <span class="string">"\"OpenLDAP Server\""</span></span><br><span class="line">TLSCertificateKeyFile /etc/openldap/certs/password</span><br><span class="line">database config</span><br><span class="line">access to *</span><br><span class="line">	by dn.exact=<span class="string">"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth"</span> manage</span><br><span class="line">	by * none</span><br><span class="line">database monitor</span><br><span class="line">access to *</span><br><span class="line">	by dn.exact=<span class="string">"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth"</span> <span class="built_in">read</span></span><br><span class="line">        by dn.exact=<span class="string">"cn=admin,dc=your_domain,dc=com"</span> <span class="built_in">read</span></span><br><span class="line">        by * none</span><br><span class="line">database	bdb</span><br><span class="line">suffix		<span class="string">"dc=your_domain,dc=com"</span></span><br><span class="line">checkpoint	<span class="number">1024</span> <span class="number">15</span></span><br><span class="line">rootdn		<span class="string">"cn=admin,dc=your_domain,dc=com"</span></span><br><span class="line">rootpw	&#123;SSHA&#125;wQgz54gQ7/F7/u6N/nJuNG/XOJ2mwhBA</span><br><span class="line">directory	/var/lib/ldap</span><br><span class="line">index objectClass                       eq,pres</span><br><span class="line">index ou,cn,mail,surname,givenname      eq,pres,sub</span><br><span class="line">index uidNumber,gidNumber,loginShell    eq,pres</span><br><span class="line">index uid,memberUid                     eq,pres,sub</span><br><span class="line">index nisMapName,nisMapEntry            eq,pres,sub</span><br><span class="line">loglevel        <span class="number">4095</span></span><br></pre></td></tr></table></figure>
<h4 id="OpenLDAP主主配置文件"><a href="#OpenLDAP主主配置文件" class="headerlink" title="OpenLDAP主主配置文件"></a><strong>OpenLDAP主主配置文件</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### **222**</span></span><br><span class="line">include		/etc/openldap/schema/corba.schema</span><br><span class="line">include		/etc/openldap/schema/core.schema</span><br><span class="line">include		/etc/openldap/schema/cosine.schema</span><br><span class="line">include		/etc/openldap/schema/duaconf.schema</span><br><span class="line">include		/etc/openldap/schema/dyngroup.schema</span><br><span class="line">include		/etc/openldap/schema/inetorgperson.schema</span><br><span class="line">include		/etc/openldap/schema/java.schema</span><br><span class="line">include		/etc/openldap/schema/misc.schema</span><br><span class="line">include		/etc/openldap/schema/nis.schema</span><br><span class="line">include		/etc/openldap/schema/openldap.schema</span><br><span class="line">include		/etc/openldap/schema/ppolicy.schema</span><br><span class="line">include		/etc/openldap/schema/collective.schema</span><br><span class="line">allow <span class="built_in">bind</span>_v2</span><br><span class="line">pidfile		/var/run/openldap/slapd.pid</span><br><span class="line">argsfile	/var/run/openldap/slapd.args</span><br><span class="line">moduleload syncprov.la</span><br><span class="line">TLSCACertificatePath /etc/openldap/certs</span><br><span class="line">TLSCertificateFile <span class="string">"\"OpenLDAP Server\""</span></span><br><span class="line">TLSCertificateKeyFile /etc/openldap/certs/password</span><br><span class="line">database config</span><br><span class="line">access to *</span><br><span class="line">	by dn.exact=<span class="string">"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth"</span> manage</span><br><span class="line">	by * none</span><br><span class="line">database monitor</span><br><span class="line">access to *</span><br><span class="line">	by dn.exact=<span class="string">"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth"</span> <span class="built_in">read</span></span><br><span class="line">        by dn.exact=<span class="string">"cn=admin,dc=your_domain,dc=com"</span> <span class="built_in">read</span></span><br><span class="line">        by * none</span><br><span class="line">database	bdb</span><br><span class="line">suffix		<span class="string">"dc=your_domain,dc=com"</span></span><br><span class="line">checkpoint	<span class="number">1024</span> <span class="number">15</span></span><br><span class="line">rootdn		<span class="string">"cn=admin,dc=your_domain,dc=com"</span></span><br><span class="line">rootpw	&#123;SSHA&#125;CG7ijOa8s1Q/t4MAk4xXFC9yYSa0z47D</span><br><span class="line">directory	/var/lib/ldap</span><br><span class="line">index objectClass                       eq,pres</span><br><span class="line">index ou,cn,mail,surname,givenname      eq,pres,sub</span><br><span class="line">index uidNumber,gidNumber,loginShell    eq,pres</span><br><span class="line">index uid,memberUid                     eq,pres,sub</span><br><span class="line">index nisMapName,nisMapEntry            eq,pres,sub</span><br><span class="line">loglevel        <span class="number">256</span></span><br><span class="line"><span class="comment"># 主主配置</span></span><br><span class="line">index entryCSN,entryUUID eq</span><br><span class="line">overlay syncprov</span><br><span class="line">syncprov-checkpoint <span class="number">100</span> <span class="number">10</span></span><br><span class="line">syncprov-sessionlog <span class="number">100</span></span><br><span class="line">serverID  <span class="number">1</span></span><br><span class="line">syncrepl  rid=<span class="number">222</span></span><br><span class="line">          provider=ldap://<span class="number">10.201</span>.<span class="number">7.223</span></span><br><span class="line">          bindmethod=simple</span><br><span class="line">          binddn=<span class="string">"cn=admin,dc=your_domain,dc=com"</span></span><br><span class="line">          credentials=mogl</span><br><span class="line">          searchbase=<span class="string">"dc=your_domain,dc=com"</span></span><br><span class="line">          schemachecking=off</span><br><span class="line">          <span class="built_in">type</span>=refreshAndPersist</span><br><span class="line">          retry=<span class="string">"60 +"</span></span><br><span class="line">mirrormode on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### **223**</span></span><br><span class="line">include		/etc/openldap/schema/corba.schema</span><br><span class="line">include		/etc/openldap/schema/core.schema</span><br><span class="line">include		/etc/openldap/schema/cosine.schema</span><br><span class="line">include		/etc/openldap/schema/duaconf.schema</span><br><span class="line">include		/etc/openldap/schema/dyngroup.schema</span><br><span class="line">include		/etc/openldap/schema/inetorgperson.schema</span><br><span class="line">include		/etc/openldap/schema/java.schema</span><br><span class="line">include		/etc/openldap/schema/misc.schema</span><br><span class="line">include		/etc/openldap/schema/nis.schema</span><br><span class="line">include		/etc/openldap/schema/openldap.schema</span><br><span class="line">include		/etc/openldap/schema/ppolicy.schema</span><br><span class="line">include		/etc/openldap/schema/collective.schema</span><br><span class="line">allow <span class="built_in">bind</span>_v2</span><br><span class="line">pidfile		/var/run/openldap/slapd.pid</span><br><span class="line">argsfile	/var/run/openldap/slapd.args</span><br><span class="line">moduleload syncprov.la</span><br><span class="line">TLSCACertificatePath /etc/openldap/certs</span><br><span class="line">TLSCertificateFile <span class="string">"\"OpenLDAP Server\""</span></span><br><span class="line">TLSCertificateKeyFile /etc/openldap/certs/password</span><br><span class="line">database config</span><br><span class="line">access to *</span><br><span class="line">	by dn.exact=<span class="string">"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth"</span> manage</span><br><span class="line">	by * none</span><br><span class="line">database monitor</span><br><span class="line">access to *</span><br><span class="line">	by dn.exact=<span class="string">"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth"</span> <span class="built_in">read</span></span><br><span class="line">        by dn.exact=<span class="string">"cn=admin,dc=your_domain,dc=com"</span> <span class="built_in">read</span></span><br><span class="line">        by * none</span><br><span class="line">database	bdb</span><br><span class="line">suffix		<span class="string">"dc=your_domain,dc=com"</span></span><br><span class="line">checkpoint	<span class="number">1024</span> <span class="number">15</span></span><br><span class="line">rootdn		<span class="string">"cn=admin,dc=your_domain,dc=com"</span></span><br><span class="line">rootpw	&#123;SSHA&#125;CG7ijOa8s1Q/t4MAk4xXFC9yYSa0z47D</span><br><span class="line">directory	/var/lib/ldap</span><br><span class="line">index objectClass                       eq,pres</span><br><span class="line">index ou,cn,mail,surname,givenname      eq,pres,sub</span><br><span class="line">index uidNumber,gidNumber,loginShell    eq,pres</span><br><span class="line">index uid,memberUid                     eq,pres,sub</span><br><span class="line">index nisMapName,nisMapEntry            eq,pres,sub</span><br><span class="line">loglevel        <span class="number">256</span></span><br><span class="line"><span class="comment"># 主主配置</span></span><br><span class="line">index entryCSN,entryUUID eq</span><br><span class="line">overlay syncprov</span><br><span class="line">syncprov-checkpoint <span class="number">100</span> <span class="number">10</span></span><br><span class="line">syncprov-sessionlog <span class="number">100</span></span><br><span class="line">serverID  <span class="number">1</span></span><br><span class="line">syncrepl  rid=<span class="number">223</span></span><br><span class="line">          provider=ldap://<span class="number">10.201</span>.<span class="number">7.222</span></span><br><span class="line">          bindmethod=simple</span><br><span class="line">          binddn=<span class="string">"cn=admin,dc=your_domain,dc=com"</span></span><br><span class="line">          credentials=mogl</span><br><span class="line">          searchbase=<span class="string">"dc=your_domain,dc=com"</span></span><br><span class="line">          schemachecking=off</span><br><span class="line">          <span class="built_in">type</span>=refreshAndPersist</span><br><span class="line">          retry=<span class="string">"60 +"</span></span><br><span class="line">mirrormode on</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>此文只是在配置Hive、Impala、HUE和HDFS时需要用到OpenLDAP，故简要的记录了一下有关OpenLDAP相关的内容而已。</p>
<h3 id="OpenLDAP-安装"><a href="#OpenLDAP-安装" class="headerlink" t]]>
    </summary>
    
      <category term="OpenLDAP" scheme="http://yoursite.com/tags/OpenLDAP/"/>
    
      <category term="OPS" scheme="http://yoursite.com/categories/OPS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka & ZooKeeper]]></title>
    <link href="http://yoursite.com/2017/08/31/Kafka/"/>
    <id>http://yoursite.com/2017/08/31/Kafka/</id>
    <published>2017-08-31T04:17:30.000Z</published>
    <updated>2019-08-10T10:20:24.154Z</updated>
    <content type="html"><![CDATA[<h2 id="Kafka原理"><a href="#Kafka原理" class="headerlink" title="Kafka原理"></a><strong>Kafka原理</strong></h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a><strong>基础概念</strong></h3><ul>
<li><p><strong>producer</strong>: 生产者，将消息发到<code>topic</code>里的为生产者</p>
</li>
<li><p><strong>consumer</strong>: 消费者，从<code>topic</code>里读取消息的为消费者。Kafka以<code>group</code>为单位组织<code>consumer</code>，同一个<code>topic</code>可有多个<code>consumer group</code>，一条消息会发到所有<code>consumer group</code>中，一个<code>consumer group</code>可能会有多个<code>consumer</code>，但一条消息只会被<code>consumer group</code>内的一个<code>consumer</code>消费，即一条消息在同一个<code>consumer group</code>内只会被消费一次。Kafka有<strong>consumer rebalance</strong>机制，自动平衡消费者，但在平衡期间不会进行消费，consumer或broker的增减都会触发rebalance，Kafka也会将无法消费或消费过慢的consumer剔除后自动引发rebalance。</p>
</li>
<li><p><strong>broker</strong>: 每个Kafka实例称之为<code>broker</code></p>
</li>
<li><p><strong>topic</strong>: Kafka以<code>topic</code>为单位对消息进行分类，相同类型的消息分到同一个<code>topic</code>进行生成消费管理。一个<code>topic</code>由一个或多个<code>partition</code>组成。</p>
</li>
<li><p><strong>partition</strong>: Kafka中可将一个<code>topic</code>切分成一个或多个<code>partition</code>，<code>partition</code>是Kafka横向扩展及并行处理的关键。每个<code>partition</code>都是一个顺序、不可变的消息队列。Kafka会将消息持久化到磁盘，但官方建议消息的高可用应由partition replication来保证。可为每个partition设置replicas，每个partition会选举出唯一一个leader partition，<strong>所有的读写请求都由leader处理</strong>，replicas只负责将消息同步到本地确保高可用。</p>
<ul>
<li><strong>Isr</strong>: In-Sync Replica，表示能与leader保持数据同步的replicas。如果replicas同步leader消息的<strong>延迟时间</strong>或<strong>延迟条数</strong>其中一个超出阀值，则会将延迟的replicas剔出Isr。当leader partition挂掉后，<strong>只有在Isr队列里的replicas才可参与leader partition的选举过程</strong>。</li>
<li><strong>replication-factor</strong>: 复制因子，topic partition的副本数目，默认<code>1</code>，即无副本。若<code>replication-factor=N</code>，则允许<code>N-1</code>台机器宕机以确保消息的高可用。</li>
</ul>
</li>
<li><p><strong>offset</strong>: 每个<code>partition</code>内的消息都有一个序列号，称之为<code>offset</code>。<code>offset</code>在<code>partition</code>内是有序的，不能跨<code>partition</code>使用<code>offset</code>，<code>offset</code>的移动表示<code>partition</code>内消息的消费位置。在Kafka的设计中，<strong>一个<code>partition</code>中消费<code>offset</code>完全是由消费者自己控制的</strong>。假若一个消费者将<code>offset</code>设置成<code>0</code>，则意味着该消费者会从该<code>partition</code>中最开始的消息开始消费。一个消费者的<code>offset</code>操作不会影响到该<code>partition</code>内的其他消费者，因为每个消费者都维护着自己的消费<code>offset</code>。</p>
<p>关于<code>offset</code>还涉及到以下4个概念</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last Commit Offset————Current Posision————High Watermark————Log End Offset</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>Last Commit Offset</code></strong>: consumer group最新一次commit的offset位置，<code>Last Commit Offset</code>表示在此之前的所有消息都以消费完并确认。</li>
<li><strong><code>Current Posision</code></strong>: 当前consumer group消费消息的offset位置。<code>Last Commit Offset</code>与<code>Current Posision</code>之间的消息表示已经被consumer group读取但还在处理中，<strong>没有确认(commit)</strong>。</li>
<li><strong><code>High Watermark</code></strong>: 表示<code>High Watermark</code>之前的数据都已被同步到所有replicas中，<code>High Watermark</code>offset之前的数据是高可用的(消息有多个副本)。</li>
<li><strong><code>Log End Offset</code></strong>: 表示producer发送到该partition中最新消息的offset。<code>High Watermark</code>和<code>Log End Offset</code>之间的数据表示消息已写入leader partition但未同步至replicas中，这之间的数据没高可用，是不安全的，<strong>不允许消费</strong></li>
</ul>
<p>从<code>0.9</code>版本后的Kafka开始，新版的consumer api是将<code>offset</code>存放在Kafka的<strong><code>__consumer_offsets</code></strong> topic中。该topic默认有<strong><code>50</code></strong>个partition和<strong><code>3</code></strong>个replicas。某个consumer group的offset具体存放在哪个partition是通过<strong><code>abs(GroupId.hashCode()) % NumPartitions</code></strong> 计算出来的(<code>NumPartitions</code>默认<code>50</code>)。旧版本的Kafka默认是将offset存在ZooKeeper中。</p>
</li>
<li><p><strong>ack</strong>: ack确认机制是producer发送消息给Kafka，确认消息高可用的机制，依赖于producer的<code>request.required.acks</code>设置</p>
<ul>
<li><strong><code>0</code></strong>: producer只管发送，不管Kafka是否接收成功</li>
<li><strong><code>1</code></strong>: Kafka partition的leader写入后即返回成功，replicas异步同步消息。风险在于leader挂了，消息还没同步的话则会丢失数据。</li>
<li><strong><code>all/-1</code></strong>: 旧版Kafka(<code>0.8</code>)值为<code>-1</code>，新版Kafka值为<code>all</code>。等待所有replicas都同步消息后才返回成功，数据高可用最安全，生产消息性能会受影响。</li>
</ul>
</li>
<li><p><strong>ZeroCopy</strong>: Kafka使用ZeroCopy机制以提高性能，以从磁盘读取数据返回给消费者为例</p>
<ul>
<li>传统方式(涉及4次切换):<ol>
<li>进程通过<code>read()</code>系统调用从用户态切换到内核态[1]，内核向磁盘发起请求，将数据从磁盘读取到内核缓存区</li>
<li>进程将数据从内核空间拷贝到用户空间，从内核态切换到用户态[2]</li>
<li>进程将数据发送到Socket，从用户态切换到内核态[3]，将数据写入到Socket Buffer</li>
<li>内核将Socket Buffer中的数据拷贝到NIC Buffer中，最终发送给消费者。从内核态切换用户态[4]，完成操作</li>
</ol>
</li>
<li>ZeroCopy方式(涉及2次切换):<ol>
<li>进程通过<code>sendfile()</code>从用户态切换到内核态[1]，内核从磁盘读取数据到内核缓存区，然后直接将数据拷贝到Socket Buffer，再将数据从Socket Buffer拷贝到NIC Buffer</li>
<li>完成操作后从内核态切换用户态[2]</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="ZooKeeper原理"><a href="#ZooKeeper原理" class="headerlink" title="ZooKeeper原理"></a><strong>ZooKeeper原理</strong></h2><h3 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a><strong>基础概念</strong></h3><ul>
<li><p><strong>角色</strong>: ZK中分为3中角色。ZK所有节点都可接收并处理<strong>读请求</strong>(<code>exists</code>/<code>getData</code>/<code>getChildren</code>…)，但只有<strong>Leader</strong>角色节点才能处理<strong>写请求</strong>(<code>create</code>/<code>setData</code>/<code>delete</code>)</p>
<ul>
<li><strong>Leader</strong>: 主节点，响应所有其余节点请求(包括写请求)，维护集群状态</li>
<li><strong>Follower</strong>: 从Leader中同步消息和状态，接收并处理读请求，转发写请求到Leader。可参与选举</li>
<li><strong>Observer</strong>: <code>3.3.0</code>版本开始引入，仅处理读请求，提高读请求吞吐量，转发写请求到Leader。数据不持久化到磁盘，不可参与选举</li>
</ul>
</li>
<li><p><strong>ZNODE</strong>: ZK使用类似文件系统方式组织资源，资源中的每个节点称为ZNODE。ZNODE分4中类型</p>
<ul>
<li><strong>持久节点(persistent)</strong>: 只能通过<code>delete</code>指令删除，数据会被持久化</li>
<li><strong>临时节点(ephemeral)</strong>: 创建该ZNODE的客户端断开连接后，临时节点会被<strong>自动删除</strong></li>
<li><strong>有序节点</strong>: 创建节点时会自动在节点名后添加一串单调递增序号，<code>/tasks/task0000000001</code></li>
<li><strong>无序节点</strong>: 默认创建无序节点</li>
</ul>
</li>
<li><p><strong>ZNODE stat结构</strong>: 每个ZNODE都会有一个<code>stat</code>信息，可通过<code>stat &lt;/zookeeper/test/node&gt;</code>或<code>ls2 &lt;/zookeeper/test/node&gt;</code>查看</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost(CONNECTED) <span class="number">0</span>] <span class="built_in">stat</span> /zookeeper</span><br><span class="line">cZxid = <span class="number">0</span>x0</span><br><span class="line">ctime = Thu Jan <span class="number">01</span> <span class="number">05</span>:<span class="number">30</span>:<span class="number">00</span> IST <span class="number">1970</span></span><br><span class="line">mZxid = <span class="number">0</span>x0</span><br><span class="line">mtime = Thu Jan <span class="number">01</span> <span class="number">05</span>:<span class="number">30</span>:<span class="number">00</span> IST <span class="number">1970</span></span><br><span class="line">pZxid = <span class="number">0</span>x0</span><br><span class="line">cversion = -<span class="number">1</span></span><br><span class="line">dataVersion = <span class="number">0</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0</span>x0</span><br><span class="line">dataLength = <span class="number">0</span></span><br><span class="line">numChildren = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>cZxid</strong>: 导致创建znode更改的事务ID</li>
<li><strong>mZxid</strong>: 最后修改znode更改的事务ID</li>
<li><strong>pZxid</strong>: 用于添加或删除子节点的znode更改的事务ID</li>
<li><strong>ctime</strong>: 表示从1970-01-01T00:00:00Z开始以毫秒为单位的znode创建时间</li>
<li><strong>mtime</strong>: 表示从1970-01-01T00:00:00Z开始以毫秒为单位的znode最近修改时间</li>
<li><strong>dataVersion</strong>: 表示对该znode的数据所做的更改次数</li>
<li><strong>cversion</strong>: 这表示对此znode的子节点进行的更改次数</li>
<li><strong>aclVersion</strong>: 表示对此znode的ACL进行更改的次数</li>
<li><strong>ephemeralOwner</strong>: 如果znode是临时节点，则为此znode所有者的 session ID；如果znode不是临时节点，则该字段设置为零</li>
<li><strong>dataLength</strong>: 这是znode数据字段的长度</li>
<li><strong>numChildren</strong>: 这表示znode的子节点的数量</li>
</ul>
</li>
<li><p><strong>监视通知机制</strong>: ZK自身提供监视通知机制，可对某ZNODE设置一个监视<code>watcher</code>，当监视事件发生时会发送通知。可设置2种类似watcher</p>
<ul>
<li><strong>Data Watches</strong>: ZNODE数据变更触发通知(<code>create</code>/<code>setData</code>)</li>
<li><strong>Child Watches</strong>: ZNODE子节点变更触发通知(<code>delete</code>/<code>create</code>[child znode])</li>
</ul>
</li>
<li><p><strong>会话(session)</strong>: client连接到ZK时，便会创建一个会话(session)。会话失效后ZK会清除会话相关信息(临时节点/Watcher)。每个会话session都有4个基本属性</p>
<ul>
<li><strong>SID</strong>: 会话ID，唯一标识每个会话</li>
<li><strong>TimeOut</strong>: 会话超时时间。会话异常断开后，client会尝试重连，若在TimeOut时间内重连上，则收到<code>syncconnected</code>事件重用会话；若超过TimeOut时间重连上，则收到<code>expired</code>事件，结束会话重新发起新连接。</li>
<li><strong>TickTime</strong>: 下次会话超时时间点，13位long型数据，<code>TickTime ~= NowTime + TimeOut</code></li>
<li><strong>isClosing</strong>: 会话超时标记，会话超时失效时，将会话标记为已关闭</li>
</ul>
</li>
<li><p><strong>Leader选举</strong>:</p>
<ul>
<li><strong>ZAB协议</strong>: ZK通过ZAB(Zookeeper Atomic Broadcast)协议进行消息传递，选举消息自然使用ZAB协议进行</li>
<li><strong>选举算法</strong>: <code>3.4.10</code>为止，有4种选举算法，<strong>默认3</strong><ul>
<li><code>0</code>: 基于UDP的LeaderElection</li>
<li><code>1</code>: 基于UDP的FastLeaderElection</li>
<li><code>2</code>: 基于UDP和认证的FastLeaderElection</li>
<li><code>3</code>: 基于TCP的FastLeaderElection</li>
</ul>
</li>
<li><strong>选举消息</strong><ul>
<li><strong>sid</strong>: ZK配置文件中配置<code>server.&lt;X&gt;</code>，ZK集群的唯一ID</li>
<li><strong>zxid</strong>: 事务ID，每个zxid由64位数字表示，zxid全局单调递增</li>
<li><strong>epoch</strong>: zxid高32位为epoch，从<code>1</code>开始单调递增，每选举投票一轮<code>epoch + 1</code>。低32位为epoch内序号，epoch变化则重置</li>
</ul>
</li>
<li><strong>选举优先级原则</strong><ul>
<li><strong>epoch &gt; zxid(低32位) &gt; sid</strong><ul>
<li>只有epoch为最新的follower才能参加选举(收到的epoch比自身大，无条件放弃选举)</li>
<li>zxid大的优先级高</li>
<li>sid大的优先级高</li>
</ul>
</li>
<li><strong>过半原则</strong>: 得票数 &gt; 集群总节点数/2，则产生新Leader</li>
</ul>
</li>
<li><strong>选举大致过程</strong><ul>
<li>产生选举信息。所有ZK节点(Observer除外)产生<code>(sid, zxid)</code>选举信息，并都认为自己是Leader，投自己一票</li>
<li>接收选举信息。ZK节点之间会建立TCP连接，为避免重复建立连接，ZK节点只允许<strong>sid</strong>大于自身的节点与自己建立连接，否则断开连接，并主动和对方建立连接</li>
<li>处理选举信息。<ul>
<li>检查epoch，收到的epoch大于自身epoch，退出选举，更新投票信息，发送投票结果</li>
<li>epoch相同，比较zxid，较大节点胜出</li>
<li>zxid相同，比较sid，较大节点胜出</li>
</ul>
</li>
<li>统计选举信息。每轮投票结束都会统计选举结果，若过半则产生新Leader，否则继续下一轮选举投票</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ZooKeeper集群部署"><a href="#ZooKeeper集群部署" class="headerlink" title="ZooKeeper集群部署"></a><strong>ZooKeeper集群部署</strong></h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><p>JDK安装省略</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.apache.org/dist/zookeeper/zookeeper-<span class="number">3.4</span>.<span class="number">8</span>/zookeeper-<span class="number">3.4</span>.<span class="number">8</span>.tar.gz</span><br><span class="line">tar -zxvf zookeeper-<span class="number">3.4</span>.<span class="number">8</span>.tar.gz</span><br><span class="line">mv zookeeper-<span class="number">3.4</span>.<span class="number">8</span> /usr/<span class="built_in">local</span>/zookeeper</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/zookeeper/data /usr/<span class="built_in">local</span>/zookeeper/<span class="built_in">log</span> /usr/<span class="built_in">local</span>/zookeeper/datalog</span><br></pre></td></tr></table></figure>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a><strong>集群配置</strong></h3><ul>
<li><p>zoo.cfg</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line">initLimit=<span class="number">10</span></span><br><span class="line">syncLimit=<span class="number">5</span></span><br><span class="line">dataDir=/usr/<span class="built_in">local</span>/zookeeper/data</span><br><span class="line">dataLogDir=/usr/<span class="built_in">local</span>/zookeeper/datalog</span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line"></span><br><span class="line">server.<span class="number">1</span>=<span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line">server.<span class="number">2</span>=<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line">server.<span class="number">3</span>=<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line"></span><br><span class="line">maxClientCnxns=<span class="number">500</span></span><br><span class="line">minSessionTimeout=<span class="number">30000</span></span><br><span class="line">maxSessionTimeout=<span class="number">60000</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>tickTime</code>: 基本时间单元，以毫秒为单位。它用来控制心跳和超时，默认情况下最小的会话超时时间为两倍的tickTime</li>
<li><code>initLimit</code>: 允许follower连接并同步到leader的初始化连接时间，以tickTime倍数计算</li>
<li><code>syncLimit</code>:  Leader与Follower间请求和应答时间长度</li>
<li><code>dataDir</code>: 快照文件目录</li>
<li><code>dataLogDir</code>: 事务日志目录(<code>dataDir</code>和<code>dataLogDir</code>目录最好是在两个不同磁盘中，避免IO竞争)</li>
<li><code>2181</code>: ZooKeeper监听端口(客户端连接端口)</li>
<li><code>2888</code>: leader和follower之间数据同步使用的端口号</li>
<li><code>3888</code>: leader选举专用的端口号</li>
<li><code>maxClientCnxns</code>: 客户端并发连接数目</li>
</ul>
</li>
<li><p>ServerID</p>
<p>集群每个节点都需要配置唯一的<strong>ServerID</strong>，ServerID保持和<code>zoo.cfg</code>中<strong><code>server.X</code></strong>中的<strong><code>X</code></strong>一致</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10.201.3.222</span></span><br><span class="line"><span class="built_in">echo</span> <span class="number">1</span> &gt; /usr/<span class="built_in">local</span>/zookeeper/data/myid</span><br><span class="line"><span class="comment"># 10.201.3.223</span></span><br><span class="line"><span class="built_in">echo</span> <span class="number">2</span> &gt; /usr/<span class="built_in">local</span>/zookeeper/data/myid</span><br><span class="line"><span class="comment"># 10.201.3.224</span></span><br><span class="line"><span class="built_in">echo</span> <span class="number">3</span> &gt; /usr/<span class="built_in">local</span>/zookeeper/data/myid</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化配置——<code>zkEnv.sh</code></p>
<p>一些额外的优化配置建议写在<code>zkEnv.sh</code>中，如JVM、Log Level等。修改滚动日志选项(size等)则在<code>conf/log4j.properties</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zkEnv.sh</span></span><br><span class="line">JAVA_HOME=/usr/share/java</span><br><span class="line">ZOO_LOG_DIR=/usr/<span class="built_in">local</span>/zookeeper/<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 设置日志轮转</span></span><br><span class="line">ZOO_LOG4J_PROP=<span class="string">"INFO,ROLLINGFILE"</span></span><br><span class="line">JVMFLAGS=<span class="string">"-Xms1024m -Xmx1024m <span class="variable">$JVMFLAGS</span>"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="启动ZooKeeper集群"><a href="#启动ZooKeeper集群" class="headerlink" title="启动ZooKeeper集群"></a><strong>启动ZooKeeper集群</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **所有节点执行，启动ZooKeeper集群**</span></span><br><span class="line">/usr/<span class="built_in">local</span>/zookeeper/bin/zkServer.sh start</span><br><span class="line"><span class="comment"># **查看集群状态**</span></span><br><span class="line">/usr/<span class="built_in">local</span>/zookeeper/bin/zkServer.sh status</span><br></pre></td></tr></table></figure>
<h3 id="ZooKeeper日志维护"><a href="#ZooKeeper日志维护" class="headerlink" title="ZooKeeper日志维护"></a><strong>ZooKeeper日志维护</strong></h3><p>默认ZooKeeper不会定期清除日志，<code>3.4.0</code>开始支持定期清理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **zoo.cfg**</span></span><br><span class="line"><span class="comment"># **清理频率，单位小时**</span></span><br><span class="line">autopurge.purgeInterval=<span class="number">24</span></span><br><span class="line"><span class="comment"># **保留文件数目，默认3**</span></span><br><span class="line">autopurge.snapRetainCount=<span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>但一般采用计划任务选择在空闲时间段定期删除，避免占用大量IO影响ZooKeeper。<strong>ZooKeeper每次执行事务都会写入事务日志，而且需要过半节点同步</strong>。磁盘IO直接影响事务处理速度！</p>
<p>有鉴于此，尽量让<code>dataDir</code>和<code>dataLogDir</code>分开在不同的磁盘，避免IO竞争。ZooKeeper提供<code>zkCleanup.sh</code>脚本帮助清理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/zookeeper/bin/zkCleanup.sh -n &lt;日志保留数目/默认<span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ZooKeeper常用操作"><a href="#ZooKeeper常用操作" class="headerlink" title="ZooKeeper常用操作"></a><strong>ZooKeeper常用操作</strong></h3><h4 id="命令行连接ZooKeeper"><a href="#命令行连接ZooKeeper" class="headerlink" title="命令行连接ZooKeeper"></a><strong>命令行连接ZooKeeper</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/zookeeper/bin/zkCli.sh -server <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure>
<h4 id="四字命令"><a href="#四字命令" class="headerlink" title="四字命令"></a><strong>四字命令</strong></h4><p>可通过常用的ZooKeeper四字命令监控ZooKeeper，一般用法为：<strong><code>echo &lt;四字命令&gt; | nc localhost 2181</code></strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>conf</td>
<td>3.3.0版本引入的。打印出服务相关配置的详细信息。</td>
</tr>
<tr>
<td>cons</td>
<td>3.3.0版本引入的。列出所有连接到这台服务器的客户端全部连接/会话详细信息。包括”接受/发送”的包数量、会话id、操作延迟、最后的操作执行等等信息。</td>
</tr>
<tr>
<td>crst</td>
<td>3.3.0版本引入的。重置所有连接的连接和会话统计信息。</td>
</tr>
<tr>
<td>dump</td>
<td>列出那些比较重要的会话和临时节点。这个命令只能在leader节点上有用。</td>
</tr>
<tr>
<td>envi</td>
<td>打印出服务环境的详细信息。</td>
</tr>
<tr>
<td>reqs</td>
<td>列出未经处理的请求</td>
</tr>
<tr>
<td>ruok</td>
<td>测试服务是否处于正确状态。如果确实如此，那么服务返回”imok”，否则不做任何相应。</td>
</tr>
<tr>
<td>stat</td>
<td>输出关于性能和连接的客户端的列表。</td>
</tr>
<tr>
<td>srst</td>
<td>重置服务器的统计。</td>
</tr>
<tr>
<td>srvr</td>
<td>3.3.0版本引入的。列出连接服务器的详细信息</td>
</tr>
<tr>
<td>wchs</td>
<td>3.3.0版本引入的。列出服务器watch的详细信息。</td>
</tr>
<tr>
<td>wchc</td>
<td>3.3.0版本引入的。通过session列出服务器watch的详细信息，它的输出是一个与watch相关的会话的列表。</td>
</tr>
<tr>
<td>wchp</td>
<td>3.3.0版本引入的。通过路径列出服务器watch的详细信息。它输出一个与session相关的路径。</td>
</tr>
<tr>
<td>mntr</td>
<td>3.4.0版本引入的。输出可用于检测集群健康状态的变量列表</td>
</tr>
</tbody>
</table>
<h2 id="Kafka集群部署"><a href="#Kafka集群部署" class="headerlink" title="Kafka集群部署"></a><strong>Kafka集群部署</strong></h2><h3 id="Kafka安装"><a href="#Kafka安装" class="headerlink" title="Kafka安装"></a><strong>Kafka安装</strong></h3><p>JDK安装省略</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="string">'http://mirror.bit.edu.cn/apache/kafka/0.10.0.0/kafka_2.11-0.10.0.0.tgz'</span></span><br><span class="line">tar -zxf kafka_2.<span class="number">11</span>-<span class="number">0.10</span>.<span class="number">0.0</span>.tgz &amp;&amp; mv kafka_2.<span class="number">11</span>-<span class="number">0.10</span>.<span class="number">0.0</span> /usr/<span class="built_in">local</span>/kafka</span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/kafka/&#123;logs,data&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kafka集群配置"><a href="#Kafka集群配置" class="headerlink" title="Kafka集群配置"></a><strong>Kafka集群配置</strong></h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><strong>配置文件</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **config/server.properties**</span></span><br><span class="line">broker.id=<span class="number">1</span></span><br><span class="line">port=<span class="number">9092</span></span><br><span class="line">advertised.host.name=<span class="number">10.201</span>.<span class="number">3.222</span></span><br><span class="line">host.name=<span class="number">10.201</span>.<span class="number">3.222</span></span><br><span class="line">num.network.threads=<span class="number">4</span></span><br><span class="line">num.io.threads=<span class="number">8</span></span><br><span class="line">socket.send.buffer.bytes=<span class="number">1048576</span></span><br><span class="line">socket.receive.buffer.bytes=<span class="number">1048576</span></span><br><span class="line">socket.request.max.bytes=<span class="number">104857600</span></span><br><span class="line">log.dirs=/usr/<span class="built_in">local</span>/kafka/data</span><br><span class="line">num.partitions=<span class="number">5</span></span><br><span class="line">num.recovery.threads.per.data.dir=<span class="number">1</span></span><br><span class="line">log.retention.hours=<span class="number">72</span></span><br><span class="line">log.segment.bytes=<span class="number">1073741824</span></span><br><span class="line">log.retention.check.interval.ms=<span class="number">300000</span></span><br><span class="line">zookeeper.connect=<span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span></span><br><span class="line">zookeeper.connection.timeout.ms=<span class="number">6000</span></span><br><span class="line">delete.topic.enable=<span class="literal">true</span></span><br><span class="line">default.replication.factor=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>broker.id</code>: kafka broker唯一标识，集群各节点必须唯一。</li>
<li><code>num.network.threads</code>: 网络IO线程数(优化配置成CPU核心数目一致)</li>
<li><code>num.io.threads</code>: 磁盘IO线程数(优化配置成CPU核心数的2倍)</li>
<li><code>socket.send.buffer.bytes/socket.receive.buffer.bytes</code>: 发送/接收缓冲区大小</li>
<li><code>socket.request.max.bytes</code>: 最大请求接收大小</li>
<li><code>log.dirs</code>: kafka数据存放目录，多目录间用<code>,</code>分隔</li>
<li><code>num.partitions</code>: 默认partition数目</li>
<li><code>num.recovery.threads.per.data.dir</code>: 每个数据目录kafka启动恢复日志、关闭刷盘的线程数</li>
<li><code>log.retention.hours</code>: 消息保留时间</li>
<li><code>log.segment.bytes</code>: 日志段大小。日志文件达到该值则切割</li>
<li><code>log.retention.check.interval.ms</code>: 检查消息/日志是否达到删除要求的间隔时间</li>
<li><code>delete.topic.enable</code>: 允许删除topic而非仅标识为<code>delete</code></li>
<li><code>default.replication.factor</code>: 默认消息备份数目，默认为<code>1</code>不做复制</li>
</ul>
<h4 id="Kafka-JVM设置"><a href="#Kafka-JVM设置" class="headerlink" title="Kafka JVM设置"></a><strong>Kafka JVM设置</strong></h4><p><strong><code>/usr/local/kafka/bin/kafka-server-start.sh</code></strong>，kafka heap大小最好不要超过<code>4G</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">"-Xmx3G -Xms3G"</span></span><br></pre></td></tr></table></figure>
<h4 id="启动Kafka"><a href="#启动Kafka" class="headerlink" title="启动Kafka"></a><strong>启动Kafka</strong></h4><p>尽量使用Supervisor管理启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /usr/<span class="built_in">local</span>/kafka/bin/kafka-server-start.sh /usr/<span class="built_in">local</span>/kafka/config/server.properties &amp;&gt; /usr/<span class="built_in">local</span>/kafka/logs/kafka.log &amp;</span><br></pre></td></tr></table></figure>
<h3 id="Kafka常用操作"><a href="#Kafka常用操作" class="headerlink" title="Kafka常用操作"></a><strong>Kafka常用操作</strong></h3><h4 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a><strong>创建topic</strong></h4><p><code>replication-factor</code>的数目要小于等于<code>broker</code>数目。<code>replication-factor</code>为复制因子，默认值<code>1</code>表示无副本，<code>2</code>表示有一个副本。<code>partitions</code>为partition数目，partition越多并发消费量越大，partition维护成本也越大。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --create --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --replication-factor <span class="number">2</span> --partitions <span class="number">2</span> --topic &lt;topic_name&gt;</span><br></pre></td></tr></table></figure>
<h4 id="查看topic"><a href="#查看topic" class="headerlink" title="查看topic"></a><strong>查看topic</strong></h4><ul>
<li><p>列出所有topic</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --list --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看具体topic</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --describe --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --topic &lt;topic_name&gt;</span><br><span class="line">Topic:<span class="built_in">test</span>	PartitionCount:<span class="number">2</span>	ReplicationFactor:<span class="number">2</span>	Configs:</span><br><span class="line">	Topic: <span class="built_in">test</span>	Partition: <span class="number">0</span>	Leader: <span class="number">3</span>	Replicas: <span class="number">3</span>,<span class="number">1</span>	Isr: <span class="number">3</span>,<span class="number">1</span></span><br><span class="line">	Topic: <span class="built_in">test</span>	Partition: <span class="number">1</span>	Leader: <span class="number">1</span>	Replicas: <span class="number">1</span>,<span class="number">2</span>	Isr: <span class="number">1</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="删除topic"><a href="#删除topic" class="headerlink" title="删除topic"></a><strong>删除topic</strong></h4><p>如果<code>delete.topic.enable=true</code>则topic会被直接删除，否则仅仅只是会被先标记为删除并不会实际删。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --delete --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h4 id="动态修改topic的数据保留时间"><a href="#动态修改topic的数据保留时间" class="headerlink" title="动态修改topic的数据保留时间"></a><strong>动态修改topic的数据保留时间</strong></h4><p>topic数据保留时间由配置文件中<code>log.retention.hours</code>指定，运行时可动态修改具体topic保留时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **旧方法**</span></span><br><span class="line"><span class="comment">#/usr/local/kafka/bin/kafka-topics.sh --zookeeper 10.201.3.222:2181,10.201.3.223:2181,10.201.3.224:2181 --alter --topic &lt;topic_name&gt; --config retention.ms=86400000</span></span><br><span class="line"><span class="comment"># **新方法**</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-configs.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --alter --entity-type topics --entity-name &lt;topic_name&gt; --add-config retention.ms=<span class="number">86400000</span></span><br><span class="line"><span class="comment"># **查看修改**</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-configs.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --describe --entity-type topics --entity-name &lt;topic_name&gt;</span><br></pre></td></tr></table></figure>
<h4 id="生产消费测试"><a href="#生产消费测试" class="headerlink" title="生产消费测试"></a><strong>生产消费测试</strong></h4><ul>
<li><p>生产消息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-console-producer.sh --broker-list <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">9092</span> --topic &lt;topic_name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费消息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-console-consumer.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --topic &lt;topic_name&gt; --from-beginning</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="consumer-group-操作"><a href="#consumer-group-操作" class="headerlink" title="consumer group 操作"></a><strong>consumer group 操作</strong></h4><ul>
<li><p>列出所有消费组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># old consumer api</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-consumer-groups.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --list</span><br><span class="line"><span class="comment"># new consumer api</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">9092</span> --list</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看具体消费组</p>
<p>如果是使用logstash作为consumer的话，默认的grout_name为<code>logstash</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># old consumer api</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-consumer-groups.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --describe --group &lt;group_name&gt;</span><br><span class="line"><span class="comment"># new consumer api</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">9092</span> --describe --group &lt;group_name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除具体消费组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-consumer-groups.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --delete --group &lt;group-name&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="动态增加partition数量"><a href="#动态增加partition数量" class="headerlink" title="动态增加partition数量"></a><strong>动态增加partition数量</strong></h4><p>动态增加partition数目可能会影响消息消费的顺序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --alter --topic &lt;topic_name&gt; --partitions <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h4 id="手动修改Kafka-topic-offset"><a href="#手动修改Kafka-topic-offset" class="headerlink" title="手动修改Kafka topic offset"></a><strong>手动修改Kafka topic offset</strong></h4><p>先手动导出Kafka topic的offset</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-run-class.sh kafka.tools.ExportZkOffsets --zkconnect <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --group &lt;group_id&gt; --output-file kafka_offset.txt</span><br></pre></td></tr></table></figure>
<p>手动调整Kafka topic的offset</p>
<ul>
<li><p>方法一</p>
<p>这种方法只能简单的将<code>offset</code>设置成<code>earliest</code>或<code>latest</code></p>
<ul>
<li><p>配置文件——<code>manual_offset.properties</code></p>
<p><strong><code>group.id</code></strong>为consumer group的名称，针对特定的comsumer group来设置，切勿弄错！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.connect=<span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span></span><br><span class="line">zookeeper.connection.timeout.ms=<span class="number">6000</span></span><br><span class="line"><span class="comment">#consumer group id</span></span><br><span class="line">group.id=logstash</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行</p>
<p>将topic的offset设置成最新，即忽略已经堆积的历史消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/local/kafka/bin/kafka-run-class.sh kafka.tools.UpdateOffsetsInZK [earliest|latest] &lt;config_file&gt; &lt;topic_name&gt;</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-run-class.sh kafka.tools.UpdateOffsetsInZK latest manual_offset.properties <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方法二</p>
<p>这种方法允许指定<code>offset</code>到具体位置，需要通过ZooKeeper修改</p>
<ul>
<li><p>进入ZooKeeper命令行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/zookeeper/bin/zkCli.sh -server <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看具体topic partition的offset</p>
<p>第一行的值就是当前<code>offset</code>值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">get /consumers/logstash/offsets/<span class="built_in">test</span>/<span class="number">0</span></span><br><span class="line">  <span class="number">13652</span></span><br><span class="line">  cZxid = <span class="number">0</span>x300007fe0</span><br><span class="line">  ctime = Tue Nov <span class="number">01</span> <span class="number">16</span>:<span class="number">11</span>:<span class="number">03</span> CST <span class="number">2016</span></span><br><span class="line">  mZxid = <span class="number">0</span>xd000ad433</span><br><span class="line">  mtime = Tue Jun <span class="number">20</span> <span class="number">10</span>:<span class="number">25</span>:<span class="number">37</span> CST <span class="number">2017</span></span><br><span class="line">  pZxid = <span class="number">0</span>x300007fe0</span><br><span class="line">  cversion = <span class="number">0</span></span><br><span class="line">  dataVersion = <span class="number">252</span></span><br><span class="line">  aclVersion = <span class="number">0</span></span><br><span class="line">  ephemeralOwner = <span class="number">0</span>x0</span><br><span class="line">  dataLength = <span class="number">5</span></span><br><span class="line">  numChildren = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置具体topic partition的offset</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> /consumers/logstash/offsets/<span class="built_in">test</span>/<span class="number">0</span> <span class="number">13650</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命令详解</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: [get|<span class="built_in">set</span>] /consumers/[groupId]/offsets/[topic]/[partitionId]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方法三：</p>
<p>方法一、方法二都适用于旧版的consumer api，新版Kafka使用了新的consumer api不再依赖ZooKeeper管理offset，而是直接将offset存放在<code>__consumer_offsets</code>这个内部topic中。最简单的识别方法是，新版api使用<strong><code>--bootstrap-server</code></strong>而非<code>--zookeeper</code>，如果consumer是使用<code>--bootstrap-server</code>则使用的是新api，方法一、二并不适用新版api手动调整offset，需要使用方法三。</p>
<p>方法三也有个限制，只适用与<code>kafka 0.11.0.0</code>之后的版本，而且consumer group的状态须为<strong>inactive</strong>，即没有消费者正在消费消息。<code>0.11.0.0</code>之前的版本，新版consumer api只能通过编写Java程序手动调用<code>KafkaConsumer seek</code>方法。</p>
<ul>
<li><p>新版consumer api查看consumer group情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-consumer-groups.sh --bootstrap-server <span class="number">10.201</span>.<span class="number">5.30</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">5.31</span>:<span class="number">9092</span> --describe --group mirror --new-consumer</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动调整offset</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/usr/local/kafka/bin/kafka-consumer-groups.sh  --bootstrap-server 10.201.5.30:9092,10.201.5.31:9092 --execute --group mirror --reset-offsets --all-topics --to-earliest</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-consumer-groups.sh  --bootstrap-server <span class="number">10.201</span>.<span class="number">5.30</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">5.31</span>:<span class="number">9092</span> --execute --group mirror --reset-offsets --topic jr_tomcat --to-latest</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="Kafka集群扩容"><a href="#Kafka集群扩容" class="headerlink" title="Kafka集群扩容"></a><strong>Kafka集群扩容</strong></h4><p>Kafka集群扩容，新节点机器加入集群后，原本存在topic的partitions是不会自动迁移到新节点，只有新建的topic会分配到新节点上，这样新节点对于旧有的topic是无用的。为了旧有的topic也能用到新节点，在扩容后需要手动将旧有topic的partition迁移到新节点中。</p>
<ul>
<li><p>配置新节点并启动Kafka</p>
<p>复制现有Kafka集群节点配置，修改<code>broker.id</code>后启动Kafka。通过ZooKeeper查看新增<code>broker id</code>，验证Kafka已加入集群</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/zookeeper/bin/zkCli.sh -server <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span></span><br><span class="line">[zk: <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span>(CONNECTED) <span class="number">0</span>] ls /brokers/ids</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">[zk: <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span>/(CONNECTED) <span class="number">1</span>] ls /brokers/ids</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>查看旧有topic partition的Leader、Replicas都是没有<code>broker.id=4</code>的新节点的，只有旧的节点<code>1, 2, 3</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --describe --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --topic jr_tomcat</span><br><span class="line">Topic:jr_tomcat	PartitionCount:<span class="number">5</span>	ReplicationFactor:<span class="number">2</span>	Configs:</span><br><span class="line">	Topic: jr_tomcat	Partition: <span class="number">0</span>	Leader: <span class="number">2</span>	Replicas: <span class="number">2</span>,<span class="number">3</span>	Isr: <span class="number">2</span>,<span class="number">3</span></span><br><span class="line">	Topic: jr_tomcat	Partition: <span class="number">1</span>	Leader: <span class="number">3</span>	Replicas: <span class="number">3</span>,<span class="number">1</span>	Isr: <span class="number">3</span>,<span class="number">1</span></span><br><span class="line">	Topic: jr_tomcat	Partition: <span class="number">2</span>	Leader: <span class="number">1</span>	Replicas: <span class="number">1</span>,<span class="number">2</span>	Isr: <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">	Topic: jr_tomcat	Partition: <span class="number">3</span>	Leader: <span class="number">2</span>	Replicas: <span class="number">2</span>,<span class="number">1</span>	Isr: <span class="number">2</span>,<span class="number">1</span></span><br><span class="line">	Topic: jr_tomcat	Partition: <span class="number">4</span>	Leader: <span class="number">3</span>	Replicas: <span class="number">3</span>,<span class="number">2</span>	Isr: <span class="number">3</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成迁移分配规则文件</p>
<p>假若需要对<code>jr_tomcat</code>这个topic进行重新平衡</p>
<ul>
<li><p>创建需要迁移topic的json文件——<code>topic-to-move.json</code></p>
<p>多个topic写到<code>[]</code>数组里，用<code>,</code>分隔</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># topic-to-move.json</span></span><br><span class="line">&#123;<span class="string">"topics"</span>:</span><br><span class="line">    [&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>&#125;],</span><br><span class="line">    <span class="string">"version"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#&#123;"topics": [&#123;"topic": "topic_1"&#125;,</span></span><br><span class="line"><span class="comment">#            &#123;"topic": "topic_2"&#125;],</span></span><br><span class="line"><span class="comment"># "version":1</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成迁移分配规则文件</p>
<p><code>broker-list</code>为所有集群节点的<code>broker.id</code></p>
<p><code>Proposed partition reassignment configuration</code>下面内容是新节点加入后的partition分配情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-reassign-partitions.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --topics-to-move-json-file topic-to-move.json --broker-list <span class="string">"1,2,3,4"</span> --generate</span><br><span class="line"></span><br><span class="line">Current partition replica assignment</span><br><span class="line">&#123;<span class="string">"version"</span>:<span class="number">1</span>,<span class="string">"partitions"</span>:[&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">0</span>,<span class="string">"replicas"</span>:[<span class="number">2</span>,<span class="number">3</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">4</span>,<span class="string">"replicas"</span>:[<span class="number">3</span>,<span class="number">2</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">1</span>,<span class="string">"replicas"</span>:[<span class="number">3</span>,<span class="number">1</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">3</span>,<span class="string">"replicas"</span>:[<span class="number">2</span>,<span class="number">1</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">2</span>,<span class="string">"replicas"</span>:[<span class="number">1</span>,<span class="number">2</span>]&#125;]&#125;</span><br><span class="line"></span><br><span class="line">Proposed partition reassignment configuration</span><br><span class="line">&#123;<span class="string">"version"</span>:<span class="number">1</span>,<span class="string">"partitions"</span>:[&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">0</span>,<span class="string">"replicas"</span>:[<span class="number">1</span>,<span class="number">2</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">4</span>,<span class="string">"replicas"</span>:[<span class="number">1</span>,<span class="number">3</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">1</span>,<span class="string">"replicas"</span>:[<span class="number">2</span>,<span class="number">3</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">3</span>,<span class="string">"replicas"</span>:[<span class="number">4</span>,<span class="number">1</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">2</span>,<span class="string">"replicas"</span>:[<span class="number">3</span>,<span class="number">4</span>]&#125;]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行迁移分配</p>
<p>将上一步得到的新的partition分配情况保存成<code>expand-reassignment.json</code>文件并执行partition迁移分配</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-reassign-partitions.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --reassignment-json-file expand-reassignment.json --execute</span><br><span class="line"></span><br><span class="line">Current partition replica assignment</span><br><span class="line">&#123;<span class="string">"version"</span>:<span class="number">1</span>,<span class="string">"partitions"</span>:[&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">0</span>,<span class="string">"replicas"</span>:[<span class="number">2</span>,<span class="number">3</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">4</span>,<span class="string">"replicas"</span>:[<span class="number">3</span>,<span class="number">2</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">1</span>,<span class="string">"replicas"</span>:[<span class="number">3</span>,<span class="number">1</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">3</span>,<span class="string">"replicas"</span>:[<span class="number">2</span>,<span class="number">1</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">2</span>,<span class="string">"replicas"</span>:[<span class="number">1</span>,<span class="number">2</span>]&#125;]&#125;</span><br><span class="line">Save this to use as the --reassignment-json-file option during rollback</span><br><span class="line"></span><br><span class="line">Successfully started reassignment of partitions &#123;<span class="string">"version"</span>:<span class="number">1</span>,<span class="string">"partitions"</span>:[&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">4</span>,<span class="string">"replicas"</span>:[<span class="number">1</span>,<span class="number">3</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">3</span>,<span class="string">"replicas"</span>:[<span class="number">4</span>,<span class="number">1</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">1</span>,<span class="string">"replicas"</span>:[<span class="number">2</span>,<span class="number">3</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">2</span>,<span class="string">"replicas"</span>:[<span class="number">3</span>,<span class="number">4</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"jr_tomcat"</span>,<span class="string">"partition"</span>:<span class="number">0</span>,<span class="string">"replicas"</span>:[<span class="number">1</span>,<span class="number">2</span>]&#125;]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测执行状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-reassign-partitions.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --reassignment-json-file expand-reassignment.json --verify</span><br><span class="line">Status of partition reassignment:</span><br><span class="line">Reassignment of partition [jr_tomcat,<span class="number">4</span>] completed successfully</span><br><span class="line">Reassignment of partition [jr_tomcat,<span class="number">3</span>] completed successfully</span><br><span class="line">Reassignment of partition [jr_tomcat,<span class="number">1</span>] completed successfully</span><br><span class="line">Reassignment of partition [jr_tomcat,<span class="number">2</span>] completed successfully</span><br><span class="line">Reassignment of partition [jr_tomcat,<span class="number">0</span>] completed successfully</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="增加topic的replication数量"><a href="#增加topic的replication数量" class="headerlink" title="增加topic的replication数量"></a><strong>增加topic的replication数量</strong></h4><ul>
<li><p>查看topic情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --describe --topic <span class="built_in">test</span></span><br><span class="line">Topic:<span class="built_in">test</span>	PartitionCount:<span class="number">3</span>	ReplicationFactor:<span class="number">2</span>	Configs:</span><br><span class="line">	Topic: <span class="built_in">test</span>	Partition: <span class="number">0</span>	Leader: <span class="number">3</span>	Replicas: <span class="number">3</span>,<span class="number">2</span>	Isr: <span class="number">3</span>,<span class="number">2</span></span><br><span class="line">	Topic: <span class="built_in">test</span>	Partition: <span class="number">1</span>	Leader: <span class="number">1</span>	Replicas: <span class="number">1</span>,<span class="number">2</span>	Isr: <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">	Topic: <span class="built_in">test</span>	Partition: <span class="number">2</span>	Leader: <span class="number">2</span>	Replicas: <span class="number">2</span>,<span class="number">3</span>	Isr: <span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对单独partition增加replication</p>
<p>先对<code>partition 0</code>增加replication</p>
<ul>
<li><p>准备文件——<code>increase-replication-factor.json</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"version"</span>:<span class="number">1</span>,<span class="string">"partitions"</span>:[&#123;<span class="string">"topic"</span>:<span class="string">"test"</span>,<span class="string">"partition"</span>:<span class="number">0</span>,<span class="string">"replicas"</span>:[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]&#125;]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行增加replication操作。执行后会显示旧有配置，提示保存以便回滚。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-reassign-partitions.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --reassignment-json-file increase-replication-factor.json --execute</span><br><span class="line"></span><br><span class="line">Current partition replica assignment</span><br><span class="line">&#123;<span class="string">"version"</span>:<span class="number">1</span>,<span class="string">"partitions"</span>:[&#123;<span class="string">"topic"</span>:<span class="string">"test"</span>,<span class="string">"partition"</span>:<span class="number">1</span>,<span class="string">"replicas"</span>:[<span class="number">1</span>,<span class="number">2</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"test"</span>,<span class="string">"partition"</span>:<span class="number">2</span>,<span class="string">"replicas"</span>:[<span class="number">2</span>,<span class="number">3</span>]&#125;,&#123;<span class="string">"topic"</span>:<span class="string">"test"</span>,<span class="string">"partition"</span>:<span class="number">0</span>,<span class="string">"replicas"</span>:[<span class="number">3</span>,<span class="number">2</span>]&#125;]&#125;</span><br><span class="line">Save this to use as the --reassignment-json-file option during rollback</span><br><span class="line">Successfully started reassignment of partitions &#123;<span class="string">"version"</span>:<span class="number">1</span>,<span class="string">"partitions"</span>:[&#123;<span class="string">"topic"</span>:<span class="string">"test"</span>,<span class="string">"partition"</span>:<span class="number">0</span>,<span class="string">"replicas"</span>:[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]&#125;]&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>确认执行情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-reassign-partitions.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --reassignment-json-file increase-replication-factor.json --verify</span><br><span class="line"></span><br><span class="line">Status of partition reassignment:</span><br><span class="line">Reassignment of partition [<span class="built_in">test</span>,<span class="number">0</span>] completed successfully</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看partition分区情况</p>
<p><code>partition 0</code>的replicas已从<code>3,1</code>增加为<code>3,2,1</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --describe --topic <span class="built_in">test</span></span><br><span class="line">Topic:<span class="built_in">test</span>	PartitionCount:<span class="number">3</span>	ReplicationFactor:<span class="number">2</span>	Configs:</span><br><span class="line">	Topic: <span class="built_in">test</span>	Partition: <span class="number">0</span>	Leader: <span class="number">3</span>	Replicas: <span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>	Isr: <span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">	Topic: <span class="built_in">test</span>	Partition: <span class="number">1</span>	Leader: <span class="number">1</span>	Replicas: <span class="number">1</span>,<span class="number">2</span>	Isr: <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">	Topic: <span class="built_in">test</span>	Partition: <span class="number">2</span>	Leader: <span class="number">2</span>	Replicas: <span class="number">2</span>,<span class="number">3</span>	Isr: <span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>批量增加剩余partition的replication</p>
<p>修改<code>increase-replication-factor.json</code>文件，执行增加命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-reassign-partitions.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --reassignment-json-file increase-replication-factor.json --execute</span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-reassign-partitions.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --reassignment-json-file increase-replication-factor.json --verify</span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> --describe --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Kafka集群间数据同步——MirrorMaker"><a href="#Kafka集群间数据同步——MirrorMaker" class="headerlink" title="Kafka集群间数据同步——MirrorMaker"></a><strong>Kafka集群间数据同步——MirrorMaker</strong></h4><p>KafkaMirrorMaker提供不同Kafka集群之间数据同步，基本就是从Source Kafka Cluster消费消息然后生产到Target Kafka Cluster中。若Target Kafka Cluster中不存在topic，KafkaMirrorMaker会自动在Target Kafka Cluster上创建和Source Kafka Cluster完全相同的topic(topic_name、partition、replication)。从Kafka0.9版本开始引入新的consumer api，默认是使用旧版api，使用<code>--new.consumer</code>参数可指定使用新版api。</p>
<ul>
<li><p>mirror_maker_consumer.config</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新版consumer</span></span><br><span class="line">bootstrap.servers=<span class="number">10.201</span>.<span class="number">5.30</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">5.31</span>:<span class="number">9092</span></span><br><span class="line"><span class="comment">#旧版comsumer</span></span><br><span class="line"><span class="comment">#zookeeper.connect=10.201.5.30:2181,10.201.5.31:2181</span></span><br><span class="line"><span class="comment">#default request timeout 40000</span></span><br><span class="line">request.timeout.ms=<span class="number">50000</span></span><br><span class="line"><span class="comment">#default heartbeat interval 3000</span></span><br><span class="line">heartbeat.interval.ms=<span class="number">15000</span></span><br><span class="line"><span class="comment">#default session timeout 30000</span></span><br><span class="line">session.timeout.ms=<span class="number">40000</span></span><br><span class="line"><span class="comment">#consumer group id</span></span><br><span class="line">group.id=mirrormaker</span><br><span class="line">partition.assignment.strategy=org.apache.kafka.clients.consumer.RoundRobinAssignor</span><br><span class="line"><span class="comment">#default max poll records 2147483647</span></span><br><span class="line">max.poll.records=<span class="number">20000</span></span><br><span class="line"><span class="comment">#default receive buffer 64kB, now 512kb</span></span><br><span class="line">receive.buffer.bytes=<span class="number">524288</span></span><br><span class="line"><span class="comment">#default max amount of data per partition to override 1048576</span></span><br><span class="line">max.partition.fetch.bytes=<span class="number">5248576</span></span><br><span class="line"><span class="comment">#consumer timeout</span></span><br><span class="line"><span class="comment">#consumer.timeout.ms=5000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mirror_maker_producer.config</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.servers=<span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">9092</span></span><br><span class="line"><span class="comment">#buffer.memory=134217728</span></span><br><span class="line">batch.size=<span class="number">32768</span></span><br><span class="line">receive.buffer.bytes=<span class="number">327680</span></span><br><span class="line">send.buffer.bytes=<span class="number">262144</span></span><br><span class="line">max.request.size=<span class="number">10485760</span></span><br><span class="line">linger.ms=<span class="number">3000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动KafkaMirrorMaker</p>
<p><code>--whitelist</code>支持正则匹配符<code>|</code>，也支持<code>,</code>，比如<code>--whitelist &#39;nginx_log|tomcat_log&#39;</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-mirror-maker.sh --new.consumer --consumer.config mirror_maker_consumer.config --num.streams <span class="number">3</span> --producer.config mirror_maker_producer.config --whitelist=<span class="string">"nginx_log"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看生产消费情况</p>
<p>在mirror consumer端查看消费情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-consumer-groups.sh --bootstrap-server <span class="number">10.201</span>.<span class="number">5.30</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">5.31</span>:<span class="number">9092</span> --describe --group mirrormaker --new-consumer</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="KafkaOffsetMonitor监控部署"><a href="#KafkaOffsetMonitor监控部署" class="headerlink" title="KafkaOffsetMonitor监控部署"></a><strong>KafkaOffsetMonitor监控部署</strong></h4><p>KafkaOffsetMonitor监控Kafka消费队列堆积情况</p>
<p>下载<a href="https://github.com/quantifind/KafkaOffsetMonitor/releases/download/v0.2.1/KafkaOffsetMonitor-assembly-0.2.1.jar" target="_blank" rel="external">KafkaOffsetMonitor-assembly-0.2.1.jar</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -cp KafkaOffsetMonitor-assembly-<span class="number">0.2</span>.<span class="number">1</span>.jar \</span><br><span class="line">    com.quantifind.kafka.offsetapp.OffsetGetterWeb \</span><br><span class="line">    --zk <span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2181</span> \</span><br><span class="line">    --port <span class="number">8088</span> \</span><br><span class="line">    --refresh <span class="number">30</span>.seconds \</span><br><span class="line">    --retain <span class="number">7</span>.days</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Kafka原理"><a href="#Kafka原理" class="headerlink" title="Kafka原理"></a><strong>Kafka原理</strong></h2><h3 id="基础概念"><a href="#基础概念" class=]]>
    </summary>
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
      <category term="Bigdata" scheme="http://yoursite.com/categories/Bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RabbitMQ]]></title>
    <link href="http://yoursite.com/2017/08/23/RabbitMQ/"/>
    <id>http://yoursite.com/2017/08/23/RabbitMQ/</id>
    <published>2017-08-23T04:17:30.000Z</published>
    <updated>2019-03-31T04:24:48.696Z</updated>
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a><strong>基础概念</strong></h2><ul>
<li><p><strong>Exchange</strong></p>
<p>  producer生产消息发送给RabbitMQ后并非直接到Queue，而是经由Exchange做筛选后再分发给Queue。Exchange又分4中类型(Exchange Type)</p>
<ol>
<li><strong>direct</strong>: 将消息转发到指定routing key的Queue中。有个特殊Exchange，若Exchange名为空则为default Exchange</li>
<li><strong>topic</strong>: 将消息按照规则转发。对routing key进行通配符匹配，将消息转发到匹配的Queue中。<strong><code>*</code></strong>匹配一个词、<strong><code>#</code></strong>匹配一个或多个词，使用<strong><code>.</code></strong>分隔。</li>
<li><strong>fanout</strong>: 将消息转发到所有绑定的Queue，适用于广播。</li>
<li><strong>header</strong>: 使用消息头代替routing key作为判断规则。</li>
</ol>
</li>
<li><p><strong>Queue</strong></p>
<p>  用于存储消息。相同属性的Queue可重复定义。Queue分2种类型：</p>
<ul>
<li><strong>Durable</strong>: 持久化，broker重启后Queue还存在</li>
<li><p><strong>Transient</strong>: 临时队列(自删除)，broker重启后自动删除</p>
<p><strong>如果消息持久化，则持久化的消息需要在持久化的Queue和Exchange中，即必须保证: exchange(指定 durable=1)、queue(指定 durable=1)和消息(delivery_mode=2)</strong></p>
<p>Queue属性</p>
</li>
<li>持久性：如果启用，队列将会在server重启前都有效</li>
<li>自动删除：如果启用，那么队列将会在所有的消费者停止使用之后自动删除掉自身</li>
<li>惰性：如果没有声明队列，那么在执行到使用的时候会导致异常，并不会主动声明</li>
<li>排他性：如果启用，队列只能被声明它的消费者使用</li>
</ul>
</li>
<li><p><strong>Binding</strong></p>
<p>  将Exchange和Queue绑定在一起(会指定binding key)，生产者将消息发送到Exchange时会指定routing key。routing key会和Exchange Type及binding key联合使用。</p>
<ul>
<li>fanout型无视Binding-key，直接将消息发送到和该Exchange绑定的Queue中。</li>
<li>direct型则要求binding key和routing key完全匹配，将消息发送到完全匹配的Queue中。</li>
<li>topic型则要求binding key和routing key正则匹配</li>
<li>header型则不依赖binding key和routing key，而是根据消息中的header路由消息。</li>
</ul>
</li>
<li><p><strong>Virtual Host</strong></p>
<p>  Virtual Host拥有一组Exchange、Queue、Binding，根据Virtual Host进行用户权限设置<br>  不同Virtual Host之间完全隔离，一般不能共享Exchange、Queue等</p>
</li>
<li><p><strong>Channel</strong><br>  消息通道，一个TCP连接中可建立多个channel，每个channel代表一个会话任务</p>
</li>
<li><p><strong>Acknowledgment</strong><br>  RabbitMQ为了保障消息的可靠性，在消费端和生产端都有相应的机制来确保</p>
<ul>
<li><strong>消费端</strong><br>  消费者在消费完Queue中的消息后会发送一个ack给RabbitMQ，RabbitMQ收到ack后确认消息被消费后从Queue中将消息移除。若RabbitMQ没有收到ack而消费者断开连接，RabbitMQ会将消息发送给其他消费者。RabbitMQ不会为没ack的消息做超时处理，会一直等待ack，除非消费者断开连接。</li>
<li><strong>生产端</strong><br>  生产端消息的可靠性主要有两种方式<ul>
<li><strong>AMQP事务机制</strong><ol>
<li>生产者调用<code>txSelect()</code>方法将channel设置成transaction模式</li>
<li>生产者调用<code>txCommit()</code>方法发送消息，<code>txCommit()</code>成功则消息确认到达MQ；失败则调用<code>txRollback()</code>回滚事务。</li>
</ol>
</li>
<li><strong>channel confirm模式</strong><br>  AMQP事务机制对生产端的性能会有影响，所以RabbitMQ提供了另外一种方式以确保可靠性，就是将channel设置成confirm模式。一旦channel进入confirm模式，每条消息会分配一个唯一ID(<code>1</code>开始)，一旦消息到达MQ，MQ会发送携带ID的ack给生产者。为了提高性能RabbitMQ还提供了3中confirm模式：<ol>
<li><strong>common</strong>: 发送一条消息确认一条</li>
<li><strong>batch</strong>: 批量发送一批消息，批量确认</li>
<li><strong>async</strong>: 提供回调方法，消息被确认后生产者调用该回调方法</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="RabbitMQ部署"><a href="#RabbitMQ部署" class="headerlink" title="RabbitMQ部署"></a><strong>RabbitMQ部署</strong></h2><h3 id="安装依赖-amp-hostname设置"><a href="#安装依赖-amp-hostname设置" class="headerlink" title="安装依赖&amp;hostname设置"></a><strong>安装依赖&amp;hostname设置</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install unixODBC unixODBC-devel libxslt xmlto ncurses-devel</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'10.201.3.100 sd-3-centos100'</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>
<h3 id="安装simplejson"><a href="#安装simplejson" class="headerlink" title="安装simplejson"></a><strong>安装simplejson</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="string">'https://pypi.python.org/packages/source/s/simplejson/simplejson-3.8.1.tar.gz'</span></span><br><span class="line">tar -zxf simplejson-<span class="number">3.8</span>.<span class="number">1</span>.tar.gz &amp;&amp; <span class="built_in">cd</span> simplejson-<span class="number">3.8</span>.<span class="number">1</span></span><br><span class="line">python setup.py build &amp;&amp; python setup.py install</span><br></pre></td></tr></table></figure>
<h3 id="安装erlang"><a href="#安装erlang" class="headerlink" title="安装erlang"></a><strong>安装erlang</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="string">'http://www.erlang.org/download/otp_src_18.1.tar.gz'</span></span><br><span class="line">tar -zxf otp_src_18.<span class="number">1</span>.tar.gz &amp;&amp; otp_src_18.<span class="number">1</span></span><br><span class="line">./configure --without-javac --prefix=/usr/<span class="built_in">local</span>/erlang</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'PATH=/usr/local/rabbitmq/sbin:/usr/local/erlang/bin:$PATH'</span> &gt;&gt; /etc/profile</span><br><span class="line">. /etc/profile</span><br><span class="line">ln <span class="operator">-s</span> /usr/<span class="built_in">local</span>/erlang/bin/escript /usr/sbin/escript</span><br></pre></td></tr></table></figure>
<h3 id="安装rabbitmq"><a href="#安装rabbitmq" class="headerlink" title="安装rabbitmq"></a><strong>安装rabbitmq</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="string">'http://www.rabbitmq.com/releases/rabbitmq-server/v3.5.6/rabbitmq-server-3.5.6.tar.gz'</span></span><br><span class="line">tar -zxf rabbitmq-server-<span class="number">3.5</span>.<span class="number">6</span>.tar.gz &amp;&amp; <span class="built_in">cd</span> rabbitmq-server-<span class="number">3.5</span>.<span class="number">6</span></span><br><span class="line">make TARGET_DIR=/usr/<span class="built_in">local</span>/rabbitmq SBIN_DIR=/usr/<span class="built_in">local</span>/rabbitmq/sbin MAN_DIR=/usr/<span class="built_in">local</span>/rabbitmq/man DOC_INSTALL_DIR=/usr/<span class="built_in">local</span>/rabbitmq/doc install</span><br></pre></td></tr></table></figure>
<h3 id="配置rabbitmq"><a href="#配置rabbitmq" class="headerlink" title="配置rabbitmq"></a><strong>配置rabbitmq</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/rabbitmq /usr/<span class="built_in">local</span>/rabbitmq/data /usr/<span class="built_in">local</span>/rabbitmq/<span class="built_in">log</span> /usr/<span class="built_in">local</span>/rabbitmq/plugins</span><br><span class="line">cp /usr/<span class="built_in">local</span>/rabbitmq/doc/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/rabbitmq/rabbitmq-env.conf</span></span><br><span class="line">RABBITMQ_MNESIA_BASE=/usr/<span class="built_in">local</span>/rabbitmq/data</span><br><span class="line">RABBITMQ_LOG_BASE=/usr/<span class="built_in">local</span>/rabbitmq/<span class="built_in">log</span></span><br><span class="line">RABBITMQ_PLUGINS_DIR=/usr/<span class="built_in">local</span>/rabbitmq/plugins</span><br><span class="line"><span class="comment">#RABBITMQ_NODE_PORT=5673</span></span><br><span class="line"><span class="comment">#RABBITMQ_NODENAME=rabbitmq-master</span></span><br></pre></td></tr></table></figure>
<h3 id="启动rabbitmq"><a href="#启动rabbitmq" class="headerlink" title="启动rabbitmq"></a><strong>启动rabbitmq</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">. /etc/profile</span><br><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmq-server -detached</span><br><span class="line"><span class="comment">#/usr/local/rabbitmq/sbin/rabbitmq-server &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#停止rabbitqm</span></span><br><span class="line"><span class="comment">#/usr/local/rabbitmq/sbin/rabbitmqctl stop</span></span><br></pre></td></tr></table></figure>
<h3 id="启用插件"><a href="#启用插件" class="headerlink" title="启用插件"></a><strong>启用插件</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_mqtt</span><br></pre></td></tr></table></figure>
<h4 id="插件相关操作"><a href="#插件相关操作" class="headerlink" title="插件相关操作"></a><strong>插件相关操作</strong></h4><ul>
<li><p>查询插件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有插件</span></span><br><span class="line">rabbitmq-plugins list -v</span><br><span class="line"><span class="comment"># 显示已使用插件</span></span><br><span class="line">rabbitmq-plugins list -E</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用插件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>
</li>
<li><p>停用插件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">disable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="用户设置"><a href="#用户设置" class="headerlink" title="用户设置"></a><strong>用户设置</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmqctl add_user &lt;user_name&gt; &lt;user_passwd&gt;</span><br><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmqctl <span class="built_in">set</span>_user_tags &lt;user_name&gt; administrator</span><br><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmqctl delete_user guest</span><br></pre></td></tr></table></figure>
<h3 id="日志rotate"><a href="#日志rotate" class="headerlink" title="日志rotate"></a><strong>日志rotate</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># crontab</span></span><br><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmqctl rotate_logs .<span class="string">"`date '+%Y-%m-%d'`"</span></span><br></pre></td></tr></table></figure>
<h2 id="RabbitMQ镜像集群"><a href="#RabbitMQ镜像集群" class="headerlink" title="RabbitMQ镜像集群"></a><strong>RabbitMQ镜像集群</strong></h2><p>由于Erlang原因RaggitMQ集群不支持跨网段，若需要跨网段则使用shovel/federation等插件</p>
<p>安装RabbitMQ后，先停止RabbitMQ。<code>/usr/local/rabbitmq/sbin/rabbitmqctl stop</code></p>
<h3 id="集群hostname设置"><a href="#集群hostname设置" class="headerlink" title="集群hostname设置"></a><strong>集群hostname设置</strong></h3><p>集群所有节点拥有所有主机IP+hostname</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/hosts</span></span><br><span class="line"><span class="number">10.201</span>.<span class="number">3.100</span> sd-<span class="number">3</span>-centos100</span><br><span class="line"><span class="number">10.201</span>.<span class="number">3.49</span> sd-<span class="number">3</span>-centos49</span><br></pre></td></tr></table></figure>
<h3 id="同步Erlang-Cookie"><a href="#同步Erlang-Cookie" class="headerlink" title="同步Erlang Cookie"></a><strong>同步Erlang Cookie</strong></h3><p>将其中一个机器(10.201.3.49)的<code>$HOME/.erlang.cookie</code>同步至所有机器。<code>$HOME/.erlang.cookie</code>权限必须<strong><code>400</code></strong>且<code>ower</code>、<code>group</code>必须为启动用户(此处以<code>root</code>用户启动)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有节点执行</span></span><br><span class="line">scp <span class="variable">$HOME</span>/.erlang.cookie <span class="number">10.201</span>.<span class="number">3.100</span>:<span class="variable">$HOME</span></span><br><span class="line">chmod <span class="number">400</span> <span class="variable">$HOME</span>/.erlang.cookie</span><br><span class="line">chown root:root <span class="variable">$HOME</span>/.erlang.cookie</span><br></pre></td></tr></table></figure>
<h3 id="组成集群"><a href="#组成集群" class="headerlink" title="组成集群"></a><strong>组成集群</strong></h3><p>在其余所有节点执行加入集群命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10.201.3.100 执行</span></span><br><span class="line"><span class="comment"># 启动rabbitmq</span></span><br><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmq-server -detached</span><br><span class="line"><span class="comment"># 加入集群</span></span><br><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmqctl stop_app</span><br><span class="line"><span class="comment">#/usr/local/rabbitmq/sbin/rabbitmqctl reset</span></span><br><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmqctl join_cluster rabbit@sd-<span class="number">3</span>-centos49</span><br><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmqctl start_app</span><br></pre></td></tr></table></figure>
<p>默认使用disk模式加入集群，可使用ram模式加入集群，但集群中必须有一个节点是disk模式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmqctl join_cluster --ram rabbit@sd-<span class="number">3</span>-centos49</span><br></pre></td></tr></table></figure>
<h3 id="设置镜像队列策略"><a href="#设置镜像队列策略" class="headerlink" title="设置镜像队列策略"></a><strong>设置镜像队列策略</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有队列设置为镜像队列，即队列会被复制到各个节点，各个节点状态保持一直</span></span><br><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmqctl <span class="built_in">set</span>_policy ha-all <span class="string">"^"</span> <span class="string">'&#123;"ha-mode":"all"&#125;'</span></span><br><span class="line"><span class="comment"># 查看集群状态</span></span><br><span class="line">/usr/<span class="built_in">local</span>/rabbitmq/sbin/rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure>
<h4 id="镜像队列策略"><a href="#镜像队列策略" class="headerlink" title="镜像队列策略"></a><strong>镜像队列策略</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>_policy [-p &lt;vhostpath&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt;  &lt;definition&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>rabbitmqctl set_policy ha-all &quot;^&quot; &#39;{&quot;ha-mode&quot;:&quot;all&quot;}&#39;</code></strong><ul>
<li><code>ha-all</code>: 策略名(<name>)</name></li>
<li><code>&quot;^&quot;</code>: 匹配Queue队列名表达式，<code>&quot;^&quot;</code>表示所有Queue</li>
<li><code>{&quot;ha-mode&quot;:&quot;all&quot;}</code>: 定义HA类型<ul>
<li><code>all</code>: 镜像队列将应用在整个集群。当一个新的节点加入后，该节点会获得所有数据的一份完全副本</li>
<li><code>exactly</code>: 镜像队列在集群中复制<code>count</code>份副本。当集群节点数目少于<code>count</code>时，队列会复制到所有节点。 <strong><code>&#39;{&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}&#39;</code></strong></li>
<li><code>nodes</code>: 镜像队列会在<code>node name</code>中存在副本。<strong><code>&#39;{&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;&lt;node_name&gt;&quot;, &quot;&lt;node_name&gt;&quot;]}&#39;</code></strong></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>-p &lt;vhostpath&gt;</code></strong>，默认<code>/</code></li>
<li><strong><code>--priority &lt;priority&gt;</code></strong>，设置优先级，越高越优先</li>
<li><strong><code>--apply-to &lt;apply-to&gt;</code></strong>，作用对象，queue、exchange、all</li>
</ul>
<h2 id="RabbitMQ-常用操作"><a href="#RabbitMQ-常用操作" class="headerlink" title="RabbitMQ 常用操作"></a><strong>RabbitMQ 常用操作</strong></h2><h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a><strong>用户操作</strong></h3><ul>
<li><p>查看用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user &lt;user_name&gt; &lt;user_password&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl change_password &lt;user_name&gt; &lt;new_password&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>授权管理员权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl <span class="built_in">set</span>_user_tags &lt;user_name&gt; administrator</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl delete_user &lt;user_name&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="修改集群节点类型"><a href="#修改集群节点类型" class="headerlink" title="修改集群节点类型"></a><strong>修改集群节点类型</strong></h3><p>将集群节点由<strong>disk</strong>类型改成<strong>ram</strong>类型，在该节点中执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl change_cluster_node_<span class="built_in">type</span> ram</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集群状态，确定节点类型</span></span><br><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure>
<h3 id="rabbitmqadmin-操作"><a href="#rabbitmqadmin-操作" class="headerlink" title="rabbitmqadmin 操作"></a><strong>rabbitmqadmin 操作</strong></h3><p><code>rabbitmqadmin</code>为额外命令，开启<code>rabbitmq_management</code>插件后可用</p>
<ul>
<li><p>列出所有 Queue</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin list queues name</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除 Queue</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin delete queue name=&lt;queue_name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin list [users|vhosts|connections|exchanges|bindings|permissions|channels|consumers|queues|policies|nodes]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="强制删除-Queue"><a href="#强制删除-Queue" class="headerlink" title="强制删除 Queue"></a><strong>强制删除 Queue</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl <span class="built_in">eval</span> <span class="string">'Q = &#123;resource, &lt;&lt;"VHOST NAME"&gt;&gt;, queue, &lt;&lt;"QUEUE NAME"&gt;&gt;&#125;, rabbit_amqqueue:internal_delete(Q).'</span></span><br><span class="line"></span><br><span class="line">rabbitmqctl <span class="built_in">eval</span> <span class="string">'rabbit_amqqueue:internal_delete(&#123;resource,&lt;&lt;"VHOST NAME"&gt;&gt;,queue,&lt;&lt;"QUEUE NAME"&gt;&gt;&#125;).'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除crash queue</span></span><br><span class="line">rabbitmqctl <span class="built_in">eval</span> <span class="string">'&#123;ok, Q&#125; = rabbit_amqqueue:lookup(rabbit_misc:r(&lt;&lt;"VHOST"&gt;&gt;, queue, &lt;&lt;"QUEUE"&gt;&gt;)), rabbit_amqqueue:delete_crashed(Q).'</span></span><br></pre></td></tr></table></figure>
<h3 id="Federation-插件"><a href="#Federation-插件" class="headerlink" title="Federation 插件"></a><strong>Federation 插件</strong></h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation</span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation_management</span><br></pre></td></tr></table></figure>
<h4 id="创建Upstream"><a href="#创建Upstream" class="headerlink" title="创建Upstream"></a><strong>创建Upstream</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmqctl set_parameter federation-upstream &lt;upstream_name&gt; '&#123;"uri":"amqp://server-name","expires":3600000&#125;'</span></span><br><span class="line"><span class="comment"># 两两互连需要设置max-hops=1</span></span><br><span class="line">rabbitmqctl <span class="built_in">set</span>_parameter federation-upstream &lt;upstream_name&gt; <span class="string">'&#123;"uri":"amqp://server-name","expires":3600000,"max-hops":1&#125;'</span></span><br><span class="line"><span class="comment"># rabbitmqctl set_parameter federation-upstream pytest '&#123;"uri":"amqp://admin:feideeb907888@sz-7-centos225","expires":3600000,"max-hops":1&#125;'</span></span><br></pre></td></tr></table></figure>
<h4 id="创建Policy"><a href="#创建Policy" class="headerlink" title="创建Policy"></a><strong>创建Policy</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmqctl set_policy --apply-to exchanges &lt;policy_name&gt; "&lt;exchange_name&gt;" '&#123;"federation-upstream-set":"all"&#125;'</span></span><br><span class="line">rabbitmqctl <span class="built_in">set</span>_policy --apply-to exchanges &lt;policy_name&gt; <span class="string">"^amq\."</span> <span class="string">'&#123;"federation-upstream-set":"all"&#125;'</span></span><br><span class="line"><span class="comment"># rabbitmqctl set_policy --apply-to exchanges pytest_policy "^pytest.direct" '&#123;"federation-upstream-set":"all"&#125;'</span></span><br></pre></td></tr></table></figure>
<h4 id="检测-Federation-状态"><a href="#检测-Federation-状态" class="headerlink" title="检测 Federation 状态"></a><strong>检测 Federation 状态</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl <span class="built_in">eval</span> <span class="string">'rabbit_federation_status:status().'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_exchanges name policy</span><br></pre></td></tr></table></figure>
<h2 id="RabbitMQ-Python-API"><a href="#RabbitMQ-Python-API" class="headerlink" title="RabbitMQ Python API"></a><strong>RabbitMQ Python API</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RabbitMQAPI</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""RabbitMQAPI"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span><br><span class="line">                 rabbitmq_host,</span><br><span class="line">                 rabbitmq_queue,</span><br><span class="line">                 rabbitmq_user,</span><br><span class="line">                 rabbitmq_password,</span><br><span class="line">                 rabbitmq_msg,</span><br><span class="line">                 rabbitmq_port=<span class="number">5672</span>,</span><br><span class="line">                 rabbitmq_virtual_host=<span class="string">'/'</span>)</span>:</span></span><br><span class="line">        self.rabbitmq_host = rabbitmq_host</span><br><span class="line">        self.rabbitmq_port = rabbitmq_port</span><br><span class="line">        self.rabbitmq_queue = rabbitmq_queue</span><br><span class="line">        self.rabbitmq_virtual_host = rabbitmq_virtual_host</span><br><span class="line">        self.rabbitmq_user = rabbitmq_user</span><br><span class="line">        self.rabbitmq_password = rabbitmq_password</span><br><span class="line">        self.rabbitmq_msg = rabbitmq_msg</span><br><span class="line">        self.rabbitmq_credentials = pika.PlainCredentials(</span><br><span class="line">            self.rabbitmq_user, self.rabbitmq_password)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Connect RabbitMQ"""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rabbitmq_connection = pika.BlockingConnection(</span><br><span class="line">                pika.ConnectionParameters(</span><br><span class="line">                    host=self.rabbitmq_host,</span><br><span class="line">                    port=self.rabbitmq_port,</span><br><span class="line">                    virtual_host=self.rabbitmq_virtual_host,</span><br><span class="line">                    credentials=self.rabbitmq_credentials))</span><br><span class="line">        <span class="keyword">except</span> (Exception) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> e</span><br><span class="line">        <span class="keyword">return</span> rabbitmq_connection</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_channel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""create rabbitmq channel"""</span></span><br><span class="line">        self.rabbitmq_connection = self.connect()</span><br><span class="line">        self.rabbitmq_channel = self.rabbitmq_connection.channel()</span><br><span class="line">        self.rabbitmq_channel.queue_declare(</span><br><span class="line">            queue=self.rabbitmq_queue, durable=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        producer message to rabbitmq</span><br><span class="line">        delivery_mode 2  make message persistent</span><br><span class="line">        """</span></span><br><span class="line">        self.create_channel()</span><br><span class="line">        self.rabbitmq_channel.basic_publish(</span><br><span class="line">            exchange=<span class="string">''</span>,</span><br><span class="line">            routing_key=self.rabbitmq_queue,</span><br><span class="line">            body=self.rabbitmq_msg,</span><br><span class="line">            properties=pika.BasicProperties(delivery_mode=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""close rabbitmq connect"""</span></span><br><span class="line">        self.rabbitmq_connection.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(self, ch, method, properties, body)</span>:</span></span><br><span class="line">        <span class="string">"""consumer callback function"""</span></span><br><span class="line">        print(<span class="string">"receive: %r"</span> % body)</span><br><span class="line">        ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""rabbitmq consumer"""</span></span><br><span class="line">        self.create_channel()</span><br><span class="line">        self.rabbitmq_channel.basic_consume(</span><br><span class="line">            self.callback, queue=self.rabbitmq_queue, no_ack=<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.rabbitmq_channel.start_consuming()</span><br><span class="line">        <span class="keyword">except</span> (KeyboardInterrupt):</span><br><span class="line">            print(<span class="string">"stop consuming and exit"</span>)</span><br><span class="line">            self.rabbitmq_channel.stop_consuming()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.close_connect()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    rabbitmq_host = <span class="string">'10.201.3.49'</span></span><br><span class="line">    rabbitmq_port = <span class="number">5672</span></span><br><span class="line">    rabbitmq_virtual_host = <span class="string">'/'</span></span><br><span class="line">    rabbitmq_queue = <span class="string">'pytest'</span></span><br><span class="line">    rabbitmq_user = <span class="string">'admin'</span></span><br><span class="line">    rabbitmq_password = <span class="string">''</span></span><br><span class="line">    rabbitmq_msg = <span class="string">"Hello!"</span></span><br><span class="line"></span><br><span class="line">    rabbitmq = RabbitMQAPI(rabbitmq_host, rabbitmq_queue,</span><br><span class="line">                           rabbitmq_user, rabbitmq_password,</span><br><span class="line">                           rabbitmq_msg)</span><br><span class="line">    rabbitmq.producer()</span><br><span class="line">    rabbitmq.close_connect()</span><br><span class="line">    rabbitmq.consumer()</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a><strong>基础概念</strong></h2><ul>
<li><p><strong>Exchange</strong></p>
<p>  p]]>
    </summary>
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
      <category term="OPS" scheme="http://yoursite.com/categories/OPS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kubernetes实践篇]]></title>
    <link href="http://yoursite.com/2017/05/24/kubernetes-practice/"/>
    <id>http://yoursite.com/2017/05/24/kubernetes-practice/</id>
    <published>2017-05-24T10:56:57.000Z</published>
    <updated>2019-03-31T04:24:48.684Z</updated>
    <content type="html"><![CDATA[<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a><strong>基础环境</strong></h2><ul>
<li>CentOS 7.3 64bit</li>
<li>Docker 1.13.0</li>
<li>Kubernetes 1.5.4</li>
<li>etcd 3.1.0</li>
</ul>
<h2 id="系统基础配置"><a href="#系统基础配置" class="headerlink" title="系统基础配置"></a><strong>系统基础配置</strong></h2><ul>
<li>10.201.3.222 Master</li>
<li>10.201.3.223 Node、etcd(leader)</li>
<li>10.201.3.224 Node、etcd(follower)</li>
</ul>
<h4 id="设置hostname"><a href="#设置hostname" class="headerlink" title="设置hostname"></a><strong>设置hostname</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl --static <span class="built_in">set</span>-hostname &lt;hostname&gt;</span><br></pre></td></tr></table></figure>
<h4 id="关闭防火墙-amp-selinux"><a href="#关闭防火墙-amp-selinux" class="headerlink" title="关闭防火墙 &amp; selinux"></a><strong>关闭防火墙 &amp; selinux</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">sed -i <span class="string">'/SELINUX/s/\(enforcing\|permissive\)/disabled/'</span> /etc/selinux/config</span><br><span class="line">setenforce <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="YUM源设置"><a href="#YUM源设置" class="headerlink" title="YUM源设置"></a><strong>YUM源设置</strong></h4><ul>
<li><p>epel</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-<span class="number">7</span>.noarch.rpm</span><br><span class="line">rpm -ivh epel-release-latest-<span class="number">7</span>.noarch.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>docker.repo：<code>/etc/yum.repos.d/docker.repo</code></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/docker/yum/repo/centos7</span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=https://mirrors.tuna.tsinghua.edu.cn/docker/yum/gpg</span><br></pre></td></tr></table></figure>
</li>
<li><p>kubernetes.repo：<code>/etc/yum.repos.d/kubernetes.repo</code></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://yum.kubernetes.io/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">repo_gpgcheck=<span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="安装Docker-amp-kubernetes组件"><a href="#安装Docker-amp-kubernetes组件" class="headerlink" title="安装Docker &amp; kubernetes组件"></a><strong>安装Docker &amp; kubernetes组件</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ebtables socat docker-engine-<span class="number">1.13</span>.<span class="number">0</span> docker-engine-selinux-<span class="number">1.13</span>.<span class="number">0</span> kubelet kubeadm kubectl kubernetes-cni</span><br></pre></td></tr></table></figure>
<h2 id="部署etcd集群"><a href="#部署etcd集群" class="headerlink" title="部署etcd集群"></a><strong>部署etcd集群</strong></h2><p>&emsp;&emsp;Kubernetes使用etcd做存储，默认会部署单点的etcd，为了高可用单独部署etcd集群。</p>
<ul>
<li>10.201.3.223：leader</li>
<li>10.201.3.224：follower</li>
<li><code>2379</code>端口：etcd提供给外部客户端端口(etcd2.0前为<code>4001</code>)</li>
<li><code>2380</code>端口：etcd集群节点通信端口(etcd2.0前为<code>7001</code>)</li>
</ul>
<h4 id="安装etcd"><a href="#安装etcd" class="headerlink" title="安装etcd"></a><strong>安装etcd</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y etcd</span><br></pre></td></tr></table></figure>
<h4 id="配置etcd"><a href="#配置etcd" class="headerlink" title="配置etcd"></a><strong>配置etcd</strong></h4><p>&emsp;&emsp;<strong><code>/etc/etcd/etcd.conf</code></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#节点名称</span></span><br><span class="line">ETCD_NAME=etcd0</span><br><span class="line"><span class="comment">#数据目录</span></span><br><span class="line">ETCD_DATA_DIR=<span class="string">"/var/lib/etcd/etcd0"</span></span><br><span class="line"><span class="comment">#etcd监听地址</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">"http://0.0.0.0:2380"</span></span><br><span class="line"><span class="comment">#客户端监听地址</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">"http://0.0.0.0:2379,http://0.0.0.0:4001"</span></span><br><span class="line"><span class="comment">#集群节点通信地址</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">"http://10.201.3.223:2380"</span></span><br><span class="line"><span class="comment">#初始化集群节点</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">"etcd0=http://10.201.3.223:2380,etcd1=http://10.201.3.224:2380"</span></span><br><span class="line"><span class="comment">#初始化集群状态，new为新建</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">"new"</span></span><br><span class="line"><span class="comment">#集群token</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">"test-etcd-cluster"</span></span><br><span class="line"><span class="comment">#通知客户端地址</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">"http://10.201.3.223:2379,http://10.201.3.223:4001"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="启动etcd集群"><a href="#启动etcd集群" class="headerlink" title="启动etcd集群"></a><strong>启动etcd集群</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> etcd</span><br><span class="line">systemctl start etcd</span><br><span class="line">systemctl status etcd</span><br></pre></td></tr></table></figure>
<h4 id="查看etcd集群状态"><a href="#查看etcd集群状态" class="headerlink" title="查看etcd集群状态"></a><strong>查看etcd集群状态</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看集群监控状态</span></span><br><span class="line">etcdctl cluster-health</span><br><span class="line"><span class="comment">#member 2076196e6a1f8bed is healthy: got healthy result from http://10.201.3.223:2379</span></span><br><span class="line"><span class="comment">#member 703f1d56a3b37f45 is healthy: got healthy result from http://10.201.3.224:2379</span></span><br><span class="line"><span class="comment">#cluster is healthy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集群成员列表</span></span><br><span class="line">etcdctl member list</span><br><span class="line"><span class="comment">#2076196e6a1f8bed: name=etcd0 peerURLs=http://10.201.3.223:2380 clientURLs=http://10.201.3.223:2379,http://10.201.3.223:4001 isLeader=true</span></span><br><span class="line"><span class="comment">#703f1d56a3b37f45: name=etcd1 peerURLs=http://10.201.3.224:2380 clientURLs=http://10.201.3.224:2379,http://10.201.3.224:4001 isLeader=false</span></span><br></pre></td></tr></table></figure>
<h4 id="etcd集群增加新节点"><a href="#etcd集群增加新节点" class="headerlink" title="etcd集群增加新节点"></a><strong>etcd集群增加新节点</strong></h4><ul>
<li><p><strong>添加新节点</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">etcdctl member add etcd2 http://<span class="number">10.201</span>.<span class="number">3.222</span>:<span class="number">2380</span></span><br><span class="line"><span class="comment">#Added member named etcd2 with ID 9975afe1f36cc116 to cluster</span></span><br><span class="line"><span class="comment">#ETCD_NAME="etcd2"</span></span><br><span class="line"><span class="comment">#ETCD_INITIAL_CLUSTER="etcd0=http://10.201.3.223:2380,etcd1=http://10.201.3.224:2380,etcd2=http://10.201.3.222:2380"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置新节点</strong><br>  将<code>ETCD_NAME</code>、<code>ETCD_INITIAL_CLUSTE</code>、<code>ETCD_INITIAL_CLUSTER_STATE</code>用于etcd2的配置文件中</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ETCD_NAME=etcd2</span><br><span class="line">ETCD_DATA_DIR=<span class="string">"/var/lib/etcd/etcd2"</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">"http://0.0.0.0:2380"</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">"http://0.0.0.0:2379,http://0.0.0.0:4001"</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">"http://10.201.3.222:2380"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">"etcd0=http://10.201.3.223:2380,etcd1=http://10.201.3.224:2380,etcd2=http://10.201.3.222:2380"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">"existing"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">"ssj-etcd-cluster"</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">"http://10.201.3.222:2379,http://10.201.3.222:4001"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动新节点</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start etcd</span><br><span class="line">etcdctl member list</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>移除etcd2节点</strong><br>  演示移除节点操作</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">etcdctl member list</span><br><span class="line"><span class="comment">#2076196e6a1f8bed: name=etcd0 peerURLs=http://10.201.3.223:2380 clientURLs=http://10.201.3.223:2379,http://10.201.3.223:4001 isLeader=true</span></span><br><span class="line"><span class="comment">#703f1d56a3b37f45: name=etcd1 peerURLs=http://10.201.3.224:2380 clientURLs=http://10.201.3.224:2379,http://10.201.3.224:4001 isLeader=false</span></span><br><span class="line"><span class="comment">#9975afe1f36cc116: name=etcd2 peerURLs=http://10.201.3.222:2380 clientURLs=http://10.201.3.222:2379,http://10.201.3.222:4001 isLeader=false</span></span><br><span class="line">etcdctl member remove <span class="number">9975</span>afe1f36cc116</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="启动Docker-amp-Kubelet"><a href="#启动Docker-amp-Kubelet" class="headerlink" title="启动Docker &amp; Kubelet"></a><strong>启动Docker &amp; Kubelet</strong></h2><p>&emsp;&emsp;在所有节点启动Docker、Kubelet，Kubelet因为没有配置可能无法启动，但没关系。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker &amp;&amp; systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure></p>
<h2 id="导出导入镜像"><a href="#导出导入镜像" class="headerlink" title="导出导入镜像"></a><strong>导出导入镜像</strong></h2><p>&emsp;&emsp;由于Kubernetes组件都容器化了，需要到<code>gcr.io</code>上pull镜像，但由于GFW的原因无法pull。要么在国外机器pull镜像后导入然后在导入到本地集群，要么使用代理，这里使用前者方法。再或者绑定hosts也可，pull镜像比较慢<code>61.91.161.217 gcr.io www.gcr.io</code><br>&emsp;&emsp;Kubernetes1.5.4所需要的镜像</p>
<ul>
<li>gcr.io/google_containers/dnsmasq-metrics-amd64:1.0</li>
<li>gcr.io/google_containers/exechealthz-amd64:1.2</li>
<li>gcr.io/google_containers/kube-apiserver-amd64:v1.5.4</li>
<li>gcr.io/google_containers/kube-controller-manager-amd64:v1.5.4</li>
<li>gcr.io/google_containers/kube-discovery-amd64:1.0</li>
<li>gcr.io/google_containers/kubedns-amd64:1.9</li>
<li>gcr.io/google_containers/kube-dnsmasq-amd64:1.4</li>
<li>gcr.io/google_containers/kube-proxy-amd64:v1.5.4</li>
<li>gcr.io/google_containers/kube-scheduler-amd64:v1.5.4</li>
<li>gcr.io/google_containers/pause-amd64:3.0</li>
<li>gcr.io/google_containers/kubernetes-dashboard-amd64:v1.6.0</li>
<li>gcr.io/google_containers/etcd-amd64:3.0.14-kubeadm</li>
</ul>
<h4 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a><strong>导出镜像</strong></h4><p>&emsp;&emsp;所有节点都需要导入镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save `docker images | grep -v TAG | awk <span class="string">'&#123;print $1":"$2&#125;'</span>` &gt; kube.tar</span><br></pre></td></tr></table></figure></p>
<h4 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a><strong>导入镜像</strong></h4><p>&emsp;&emsp;将导出的镜像下载到本地集群然后导入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; kube.tar</span><br></pre></td></tr></table></figure></p>
<h2 id="部署k8s集群"><a href="#部署k8s集群" class="headerlink" title="部署k8s集群"></a><strong>部署k8s集群</strong></h2><h3 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a><strong>初始化集群</strong></h3><p>&emsp;&emsp;在master节点使用<strong><code>kubeadm</code></strong>初始化集群，初始化过程中若发现本地没有镜像会去<code>gcr.io</code>pull镜像。<br>&emsp;&emsp;使用<strong><code>kubeadm init</code></strong>初始化集群时若是使用<strong>Flannel</strong>网络的话需要添加<strong><code>--pod-network-cidr=10.244.0.0/16</code></strong>，性能上Flannel会比Weave好，生产环境的话可以考虑Open vSwitch。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定日志级别</span></span><br><span class="line"><span class="built_in">export</span> KUBE_COMPONENT_LOGLEVEL=<span class="string">'--v=1'</span></span><br><span class="line"><span class="comment">#weave网络init</span></span><br><span class="line">kubeadm init --use-kubernetes-version v1.<span class="number">5.4</span> --api-advertise-addresses=<span class="number">10.201</span>.<span class="number">3.222</span> --external-etcd-endpoints http://<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2379</span>,http://<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2379</span></span><br><span class="line"><span class="comment">#flannel网络init</span></span><br><span class="line">kubeadm init --use-kubernetes-version v1.<span class="number">5.4</span> --api-advertise-addresses=<span class="number">10.201</span>.<span class="number">3.222</span> --pod-network-cidr=<span class="number">10.244</span>.<span class="number">0.0</span>/<span class="number">16</span> --external-etcd-endpoints http://<span class="number">10.201</span>.<span class="number">3.223</span>:<span class="number">2379</span>,http://<span class="number">10.201</span>.<span class="number">3.224</span>:<span class="number">2379</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;执行完<strong>kubeadm init</strong>初始化集群后会生成一个<strong>token</strong>，需要记录便于以后添加Node进集群使用。<br>&emsp;&emsp;假若丢失了<strong>token</strong>可使用命令查看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system get secret clusterinfo -o yaml | grep token-map | awk <span class="string">'&#123;print $2&#125;'</span> | base64 --decode | sed <span class="string">"s|&#123;||g;s|&#125;||g;s|:|.|g;s/\"//g;"</span> | xargs <span class="built_in">echo</span></span><br></pre></td></tr></table></figure></p>
<h4 id="记录Node加入集群命令"><a href="#记录Node加入集群命令" class="headerlink" title="记录Node加入集群命令"></a><strong>记录Node加入集群命令</strong></h4><p>&emsp;&emsp;<code>kubeadm init</code>初始化完后会给出其余Node节点加入集群的命令，记录下来方便其余Node加入集群<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --token=<span class="number">06</span>ac4c.a0f93b8da729ac48 <span class="number">10.201</span>.<span class="number">3.222</span></span><br></pre></td></tr></table></figure></p>
<h4 id="查看k8s节点集群状态"><a href="#查看k8s节点集群状态" class="headerlink" title="查看k8s节点集群状态"></a><strong>查看k8s节点集群状态</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"><span class="comment">#NAME             STATUS         AGE</span></span><br><span class="line"><span class="comment">#sd-3-centos222   Ready,master   12m</span></span><br></pre></td></tr></table></figure>
<h4 id="设置master运行Pod"><a href="#设置master运行Pod" class="headerlink" title="设置master运行Pod"></a><strong>设置master运行Pod</strong></h4><p>&emsp;&emsp;默认master节点不会运行Pod，可通过命令设置运行在master节点运行Pod<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all dedicated-</span><br></pre></td></tr></table></figure></p>
<h3 id="添加Node节点"><a href="#添加Node节点" class="headerlink" title="添加Node节点"></a><strong>添加Node节点</strong></h3><p>&emsp;&emsp;Kubernetes的master节点部署成功后，可将其余Node节点加入集群<br>&emsp;&emsp;之前步骤已将Docker、Kubelet启动并且将所需的镜像都导入，所以直接将节点添加入集群即可。在Node节点上执行(<code>10.201.3.222</code>为master节点)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --token=<span class="number">06</span>ac4c.a0f93b8da729ac48 <span class="number">10.201</span>.<span class="number">3.222</span></span><br></pre></td></tr></table></figure></p>
<h3 id="部署Pod网络"><a href="#部署Pod网络" class="headerlink" title="部署Pod网络"></a><strong>部署Pod网络</strong></h3><p>&emsp;&emsp;为了使不同Node之间的Pod能相互通信，需要专门部署Pod网络。一般默认可使用Weave，性能上有要求可使用Flannel，生产环境可考虑Open vSwitch。<br>&emsp;&emsp;若是部署Flannel网络，<code>kube-flannel.yml</code>文件中的<code>net-conf.json</code>/<code>Network</code>网段要和<code>--pod-network-cidr=10.244.0.0/16</code>设置<strong>保持一致</strong>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#部署Weave网络</span></span><br><span class="line">kubectl apply <span class="operator">-f</span> https://git.io/weave-kube</span><br><span class="line"><span class="comment">#部署Flannel网络</span></span><br><span class="line">kubectl create <span class="operator">-f</span> https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure></p>
<h3 id="DNS注意事项"><a href="#DNS注意事项" class="headerlink" title="DNS注意事项"></a><strong>DNS注意事项</strong></h3><p>&emsp;&emsp;Kubernetes的DNS功能是有<strong><code>kube-dns</code></strong>提供的，kube-dns依赖Pod网络，所以在Pod网络弄好前kube-dns都会是<strong><code>ContainerCreating</code></strong>状态。通过以下命令查看所有Pod服务，若都正常则状态都是<strong><code>Running</code></strong>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure></p>
<h4 id="扩展kube-dns数量"><a href="#扩展kube-dns数量" class="headerlink" title="扩展kube-dns数量"></a><strong>扩展kube-dns数量</strong></h4><p>&emsp;&emsp;DNS服务为重要服务，使用<code>kubeadm</code>创建的<code>kube-dns</code>是单点的，一旦该Pod出现问题整个集群的DNS服务就瘫痪了，所有要扩展<code>kube-dns</code>数量以防单点故障。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扩展kube-dns数量</span></span><br><span class="line">kubectl --namespace=kube-system scale deployment kube-dns --replicas=&lt;NUMBER&gt;</span><br><span class="line"><span class="comment"># 查看kube-dns数量</span></span><br><span class="line">kubectl get pods --namespace=kube-system | grep <span class="string">'kube-dns'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="部署Dashboard"><a href="#部署Dashboard" class="headerlink" title="部署Dashboard"></a><strong>部署Dashboard</strong></h3><p>&emsp;&emsp;Kubernetes提供Web的Dashboard图形界面管理集群<br>&emsp;&emsp;镜像同样需要pull后导出再导入到本地，这里<code>kubernetes-dashboard.yaml</code>中的镜像为<code>gcr.io/google_containers/kubernetes-dashboard-amd64:v1.6.0</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml</span><br><span class="line">kubectl create <span class="operator">-f</span> ./kubernetes-dashboard.yaml</span><br><span class="line"><span class="comment">#查看监听端口NodePort</span></span><br><span class="line">kubectl describe svc kubernetes-dashboard --namespace=kube-system</span><br><span class="line"><span class="comment">#Web访问kubernetes-dashboard</span></span><br><span class="line">http://<span class="number">10.201</span>.<span class="number">3.222</span>:NodePort</span><br></pre></td></tr></table></figure></p>
<h2 id="Kubernetes应用实例"><a href="#Kubernetes应用实例" class="headerlink" title="Kubernetes应用实例"></a><strong>Kubernetes应用实例</strong></h2><h3 id="Kubernetes部署Nginx"><a href="#Kubernetes部署Nginx" class="headerlink" title="Kubernetes部署Nginx"></a><strong>Kubernetes部署Nginx</strong></h3><p>&emsp;&emsp;Kubernetes部署服务一般有两种模式，这里用第2种模式：</p>
<ol>
<li>先定义RC创建Pod，再定义与之关联的Service</li>
<li>先定义Service，再定义RC来创建Pod</li>
</ol>
<h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a><strong>下载镜像</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>
<h4 id="定义RC文件"><a href="#定义RC文件" class="headerlink" title="定义RC文件"></a><strong>定义RC文件</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">2</span></span><br><span class="line">  selector:</span><br><span class="line">    name: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: nginx</span><br><span class="line">          image: nginx</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: <span class="number">80</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>kind</code>表明类型</li>
<li><code>spec.selector</code>为RC的Pod选择器，监控和管理拥有此label的Pod实例，确保集群中始终有且仅有replicas个Pod实例运行</li>
<li><code>spec.template</code>定义生产Pod实例的模板，此处的labels必须和spec.selector一致</li>
<li><code>spec.template.spec.containers</code>指明容器的一些属性</li>
</ul>
<p>现在Kubernetes推荐使用<strong><code>Deployment</code></strong>代替<strong><code>RC</code></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nginx-deployment.yaml</span></span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">2</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<h4 id="创建Pod-amp-查看Pod"><a href="#创建Pod-amp-查看Pod" class="headerlink" title="创建Pod &amp; 查看Pod"></a><strong>创建Pod &amp; 查看Pod</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl create <span class="operator">-f</span> nginx.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"><span class="comment">#NAME          READY     STATUS    RESTARTS   AGE       IP          NODE</span></span><br><span class="line"><span class="comment">#nginx-dftws   1/1       Running   0          2d        10.32.0.4   sd-3-centos224</span></span><br><span class="line"><span class="comment">#nginx-vj60j   1/1       Running   0          2d        10.40.0.4   sd-3-centos223</span></span><br></pre></td></tr></table></figure>
<h4 id="定义Service文件"><a href="#定义Service文件" class="headerlink" title="定义Service文件"></a><strong>定义Service文件</strong></h4><p>&emsp;&emsp;<code>nginx-service.yaml</code>创建的Service是无法被外部访问的，要想外部能访问需要创建带有NodePort的Service<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nginx-service.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">  labels:</span><br><span class="line">    name: nginx-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: <span class="number">80</span></span><br><span class="line">      targetPort: <span class="number">80</span></span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    name: nginx</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>metadata.name</code>为Service的名称(ServerName)</li>
<li><code>spec.selector</code>表明哪些Pod对应此Service(此处指明拥有nginx labels的Pod属于nginx-service这个Service)</li>
<li><code>spec.ports.targetPort</code>具体进程在容器内的端口，spec.ports.port是该Service的端口</li>
</ul>
<p><code>nginx-service-nodeport.yaml</code>创建的Service使用Node节点系统上的Port，可直接通过<code>Node:Port</code>访问<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nginx-service-nodeport.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service-nodeport</span><br><span class="line">  labels:</span><br><span class="line">    name: nginx-service-nodeport</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: <span class="number">80</span></span><br><span class="line">      nodePort: <span class="number">32222</span></span><br><span class="line">      targetPort: <span class="number">80</span></span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    name: nginx</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>NodePort</strong>表示使用Node节点上的物理机端口提供外网访问功能</li>
<li><code>spec.ports.nodePort</code>端口范围定义必须在<code>30000</code>~<code>32767</code>内，故一般可不指定<code>spec.ports.nodePort</code>而随机分配。然后用<code>kubectl describe svc &lt;service-name&gt;</code>查看分配的NodePord</li>
</ul>
<h4 id="查看Service情况"><a href="#查看Service情况" class="headerlink" title="查看Service情况"></a><strong>查看Service情况</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc -o wide</span><br><span class="line"><span class="comment">#NAME                     CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE       SELECTOR</span></span><br><span class="line"><span class="comment">#kubernetes               10.96.0.1        &lt;none&gt;        443/TCP        4d        &lt;none&gt;</span></span><br><span class="line"><span class="comment">#nginx-service            10.107.214.134   &lt;none&gt;        80/TCP         29m       name=nginx</span></span><br><span class="line"><span class="comment">#nginx-service-nodeport   10.100.84.60     &lt;nodes&gt;       80:32222/TCP   3m        name=nginx</span></span><br><span class="line"></span><br><span class="line">kubectl describe svc nginx-service-nodeport</span><br><span class="line"><span class="comment">#Name:			nginx-service-nodeport</span></span><br><span class="line"><span class="comment">#Namespace:		default</span></span><br><span class="line"><span class="comment">#Labels:			name=nginx-service-nodeport</span></span><br><span class="line"><span class="comment">#Selector:		name=nginx</span></span><br><span class="line"><span class="comment">#Type:			NodePort</span></span><br><span class="line"><span class="comment">#IP:			10.100.84.60</span></span><br><span class="line"><span class="comment">#Port:			&lt;unset&gt;	80/TCP</span></span><br><span class="line"><span class="comment">#NodePort:		&lt;unset&gt;	32222/TCP</span></span><br><span class="line"><span class="comment">#Endpoints:		10.32.0.4:80,10.40.0.4:80</span></span><br><span class="line"><span class="comment">#Session Affinity:	None</span></span><br><span class="line"><span class="comment">#No events.</span></span><br></pre></td></tr></table></figure>
<h4 id="手动扩容RC"><a href="#手动扩容RC" class="headerlink" title="手动扩容RC"></a><strong>手动扩容RC</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale rc nginx --replicas=&lt;NUMBER&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用Kubernetes-Ingress访问kubernetes-Dashboard"><a href="#使用Kubernetes-Ingress访问kubernetes-Dashboard" class="headerlink" title="使用Kubernetes Ingress访问kubernetes Dashboard"></a><strong>使用Kubernetes Ingress访问kubernetes Dashboard</strong></h3><p>&emsp;&emsp;Ingress是Kubernetes1.2后引入，用于暴露服务用的。在1.2版本前只有LoadBalancer、NodePort两种方式。Ingress利用Nginx/HAProxy等反向代理软件实现所有Service的对外暴露服务，根据域名/URL规则动态将请求转到相应的Service。<br>&emsp;&emsp;这里演示使用Nginx Ingress来反向代理Kubernetes Dashboard。</p>
<h4 id="部署默认后端"><a href="#部署默认后端" class="headerlink" title="部署默认后端"></a><strong>部署默认后端</strong></h4><p>&emsp;&emsp;一般可部署一个默认后端，用于当域名、URL全都不匹配时候用。<strong><code>default-backend</code></strong>什么也不做，只返回<code>404</code>页面。官方提供的<a href="https://github.com/kubernetes/ingress/blob/master/examples/deployment/nginx/default-backend.yaml" target="_blank" rel="external">default-backend.yaml</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create <span class="operator">-f</span> default-backend.yaml</span><br></pre></td></tr></table></figure></p>
<h4 id="部署Ingress-Controller"><a href="#部署Ingress-Controller" class="headerlink" title="部署Ingress Controller"></a><strong>部署Ingress Controller</strong></h4><p>&emsp;&emsp;Ingress Controller部署方式可选<strong>Deployment</strong>或<strong>DaemonSet</strong>，这里选择使用<strong>DaemonSet</strong>方式部署。官方有个<a href="https://github.com/kubernetes/ingress/blob/master/examples/daemonset/nginx/nginx-ingress-daemonset.yaml" target="_blank" rel="external">nginx-ingress-daemonset</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ingress-lb</span><br><span class="line">  labels:</span><br><span class="line">    name: nginx-ingress-lb</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: nginx-ingress-lb</span><br><span class="line">      annotations:</span><br><span class="line">        prometheus.io/port: <span class="string">'10254'</span></span><br><span class="line">        prometheus.io/scrape: <span class="string">'true'</span></span><br><span class="line">    spec:</span><br><span class="line">      terminationGracePeriodSeconds: <span class="number">60</span></span><br><span class="line">      hostNetwork: <span class="literal">true</span></span><br><span class="line">      containers:</span><br><span class="line">      - image: gcr.io/google_containers/nginx-ingress-controller:<span class="number">0.9</span>.<span class="number">0</span>-beta.<span class="number">5</span></span><br><span class="line">        name: nginx-ingress-lb</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthz</span><br><span class="line">            port: <span class="number">10254</span></span><br><span class="line">            scheme: HTTP</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthz</span><br><span class="line">            port: <span class="number">10254</span></span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: <span class="number">10</span></span><br><span class="line">          timeoutSeconds: <span class="number">1</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">          hostPort: <span class="number">80</span></span><br><span class="line">        - containerPort: <span class="number">443</span></span><br><span class="line">          hostPort: <span class="number">443</span></span><br><span class="line">        env:</span><br><span class="line">          - name: POD_NAME</span><br><span class="line">            valueFrom:</span><br><span class="line">              fieldRef:</span><br><span class="line">                fieldPath: metadata.name</span><br><span class="line">          - name: POD_NAMESPACE</span><br><span class="line">            valueFrom:</span><br><span class="line">              fieldRef:</span><br><span class="line">                fieldPath: metadata.namespace</span><br><span class="line">        args:</span><br><span class="line">        - /nginx-ingress-controller</span><br><span class="line">        - --default-backend-service=$(POD_NAMESPACE)/default-http-backend</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;创建Nginx Ingress  Controller<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create <span class="operator">-f</span> nginx-ingress-controller.yaml</span><br></pre></td></tr></table></figure></p>
<h4 id="部署Ingress"><a href="#部署Ingress" class="headerlink" title="部署Ingress"></a><strong>部署Ingress</strong></h4><p>&emsp;&emsp;<code>kind: Ingress</code>用于创建Ingress资源，设置Nginx Ingress规则(域名/URL)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#kubernetes-dashboard-ingress.yaml</span></span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes-dashboard-ingress</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: your.domain.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          serviceName: kubernetes-dashboard</span><br><span class="line">          servicePort: <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl create <span class="operator">-f</span> kubernetes-dashboard-ingress.yaml</span><br><span class="line"></span><br><span class="line">kubectl get ingress -n kube-system</span><br><span class="line"><span class="comment">#NAME                           HOSTS             ADDRESS            PORTS     AGE</span></span><br><span class="line"><span class="comment">#kubernetes-dashboard-ingress   your.domain.com   10.201.3.222,...   80        1m</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;部署成功后直接使用域名<code>http://your.domain.com</code>访问就能直接跳转到kubernetes-dashboard。</p>
<h3 id="Kubernetes常用命令简录"><a href="#Kubernetes常用命令简录" class="headerlink" title="Kubernetes常用命令简录"></a><strong>Kubernetes常用命令简录</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看Kubernetes集群状态(master节点上执行)</span></span><br><span class="line">kubectl cluster-info</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看节点信息</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看ReplicationController情况</span></span><br><span class="line">kubectl get rc</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Pods情况</span></span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl get pods -o wide</span><br><span class="line">kubectl get pods -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Pods详细情况</span></span><br><span class="line">kubectl describe pods &lt;pod-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Service情况</span></span><br><span class="line">kubectl get services</span><br><span class="line">kubectl get svc</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Service详细情况</span></span><br><span class="line">kubectl describe services &lt;service-name&gt;</span><br><span class="line">kubectl describe svc &lt;service-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Pods环境变量</span></span><br><span class="line">kubectl <span class="built_in">exec</span> &lt;pod-name&gt; env</span><br><span class="line"></span><br><span class="line"><span class="comment">#在Pod上新建bash终端</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -ti &lt;pod-name&gt; -- bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据yaml文件创建资源</span></span><br><span class="line">kubectl create <span class="operator">-f</span> &lt;xxx.yaml&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除资源</span></span><br><span class="line">kubectl delete pods,services <span class="operator">-l</span> name=&lt;labels-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除所有Pods</span></span><br><span class="line">kubectl delete pods --all</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止资源</span></span><br><span class="line">kubectl stop replicationcontroller foo</span><br><span class="line">kubectl stop pods,services <span class="operator">-l</span> name=myLabel</span><br><span class="line">kubectl stop <span class="operator">-f</span> service.json</span><br><span class="line"></span><br><span class="line"><span class="comment">#动态扩展pod</span></span><br><span class="line">kubectl --namespace=kube-system scale deployment kube-dns --replicas=&lt;NUMBER&gt;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a><strong>基础环境</strong></h2><ul>
<li>CentOS 7.3 64bit</li>
<li>Docker 1.13.0]]>
    </summary>
    
      <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kubernetes理论篇]]></title>
    <link href="http://yoursite.com/2017/05/23/kubernetes/"/>
    <id>http://yoursite.com/2017/05/23/kubernetes/</id>
    <published>2017-05-23T04:17:30.000Z</published>
    <updated>2019-03-31T04:24:48.680Z</updated>
    <content type="html"><![CDATA[<p>&emsp;&emsp;《Kubernetes权威指南》的阅读笔记，由于Kubernetes项目还在快速发展中，书里有些内容已有更新的变化，不过核心内容变化不大，书还是值得认真看的。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><ul>
<li><p><strong>Master</strong><br>  &emsp;Master是整个Kubernetes系统的调度中心，其主要由以下3个重要组件组成(原本为4个组件，但etcd存在单点此处就使用了自建的外部etcd集群):</p>
<ul>
<li><strong>kube-apiserver</strong><br>  &emsp;以RESTful方式提供API给外部调用，将核心对象存储在etcd中并提供增删改查功能。</li>
<li><strong>kube-scheduler</strong><br>  &emsp;负责集群资源调度。监听etcd集群pod目录变化，将新增的pod按照分配算法分配到node节点中，调用kube-apiserver接口将node和pod进行关联。</li>
<li><strong>kube-controller-manager</strong><br>  &emsp;Master的主要功能集中在kube-controller-manager组件上。主要负责执行不同的控制器，主要的控制器有以下几种：<ol>
<li><strong>Endpoint Controller</strong>：维护Service和Pod的关联关系。</li>
<li><strong>Replication Controller</strong>：维护Pod实例的运行个数，确保Pod的运行个数和设置的一致，Pod副本数过多则销毁，过少则增加。</li>
<li><strong>Namespace Controller</strong>：通过调用kube-apiserver提供的接口获取Namespace信息，删除被标记为<code>Terminating</code>的Namespace并删除该Namespace下ServiceAccount、RC、Pod、Secret、ResourceQuota等资源。</li>
<li><strong>ServiceAccount Controller &amp; Token Controller</strong>：主要负责新的Namespace中默认帐号、密钥、证书和Token的管理。</li>
<li><strong>Node Controller</strong>：负责发现、管理和监控Node节点。Node Controller通过定期调用kube-apiserver提供的接口获取Node节点信息(<code>kubelet启动时调用kube-apiserver接口注册Node信息并定时更新Node信息</code>)</li>
<li><strong>ResourceQuota Controller</strong>：负责资源配额控制，确保指定对象使用的系统资源在规定范围内。</li>
<li><strong>Service Controller</strong>：负责监控Service变化，确保外部 LoadBalancer 被更新。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>Node</strong><br>  &emsp;Node是Kubernetes相对于Master的节点，Node上主要运行着众多Pod(默认Master不运行Pods等)。Node上由2个组件组成：</p>
<ul>
<li><strong>kubelet</strong><br>  &emsp;kubelet主要负责监控和管理Pod(启动/停止)、Volume等，定期调用kube-apiserver接口从etcd获取分配到该Node的Pod信息并启动/停止容器，定期通过kub-apiserver汇报Pod状态。</li>
<li><strong>kube-proxy</strong><br>  &emsp;kube-proxy主要用于Kubernetes的Service。kube-proxy从etcd中获取Service和Endpoints(Pod’s IP+Port)信息，Kubernetes为每个Service分配一个ClusterIP，kube-proxy根据从etcd获取到的信息为每个Service随机监听一个端口，所有到该Service的请求(<code>ClusterIP:Port</code>)会被转发到该kube-proxy的随机端口上(通过iptables的nat实现转发)，再由kube-proxy根据从etcd中获取到的信息转发给Pod(Pod在别的Node就转发到kube-proxy)。</li>
</ul>
</li>
<li><p><strong>Pod</strong><br>  &emsp;Pod是Kubernetes中最小的操作单元，一个Pod中可以有一个或多个容器(Container)(一个Pod中的多个容器应该是紧耦合的)。Pod的生命周期是通过Replication Controller来管理的，Pod被分配到具体的Node上并被创建、启动和销毁(默认Master不运行Pod )。<br>  &emsp;Kubernetes之所以要在容器(Container)之上再封装一层Pod，是因为Docker容器之间通信麻烦和效率不高，所以通过Pod将多个紧耦合的容器(Container)组合起来，每个Pod内都会启动一个<code>google_containers/pause</code>的容器(Container)，然后再启动所需的业务容器，业务容器通过<code>google_containers/pause</code>容器共享网络。<br>  &emsp;同一个Pod内的容器共享以下资源：</p>
<ul>
<li><strong>PID Namespace</strong>：同一个Pod内的应用程序能看到其他应用程序的PID(原本不同容器的PID是相互隔离的)</li>
<li><strong>Network Namespace</strong>：Pod内多个容器能访问同一个IP和端口(原本不同容器网络访问需要通过容器IP+Port方式，共享后同一个Pod内的所有容器都可直接通过localhost相互访问)</li>
<li><strong>IPC Namespace</strong>：Pod内多个容器可使用SystemV IPC或POSIX消息队列通信</li>
<li><strong>UTS Namespace</strong>：Pod内的多个容器共享一个主机名</li>
<li><strong>Volume(共享存储卷)</strong>：Pod内的多个容器可访问Pod级别的Volumes，即多个容器可共享存储空间。</li>
</ul>
</li>
<li><p><strong>Label</strong><br>  &emsp;Label以<code>key/value</code>的形式附加到Pod、Service、RC(ReplicationController)、Node等对象上，定义对象的<strong>可识别属性</strong>，然后通过Label Selector(选择器)对对象进行选择和管理。Replication Controller就是通过Label Selector来选择需要管理的Pod的。<br>  &emsp;Label Selector的定义由多个逗号分隔，如下例子所示：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"label"</span>: &#123;</span><br><span class="line"><span class="string">"key1"</span>: <span class="string">"value1"</span>,</span><br><span class="line"><span class="string">"key2"</span>: <span class="string">"value2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  &emsp;Label Selector有基于等式(Equality-based)和基于集合(Set-based)两种形式。</p>
<ul>
<li>基于等式：name = nginx，选择所有Label中<code>key=name</code>且<code>value=nginx</code>的对象。</li>
<li>基于集合：name in (nginx, tengine)，选择所有Label中<code>key=name</code>且<code>value=nginx</code>或<code>value=tengine</code>的对象。</li>
</ul>
</li>
<li><p><strong>RC(Replication Controller)</strong><br>  &emsp;Replication Controller用于定义Pod副本的数量。Kubernetes通过Replication Controller实现动态伸缩以达到应用集群高可用的目的。<br>  &emsp;Kubernetes可通过<code>kubectl scale</code>实现动态伸缩Pod</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale rc &lt;ReplicationControllerName&gt; --replicas=<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>  &emsp;<strong>删除RC，通过RC创建的Pods并不会随之跟着删除。</strong></p>
</li>
<li><p><strong>Service</strong><br>  &emsp;Service是一组相同服务Pod集群的对外访问入口，Kubernetes会为Service分配一个<strong>ClusterIP</strong>作为该Service的入口。引入Service是为了外部对后端Pod的变化无感知。<br>  &emsp;Kubernetes会根据Service定义中的Label Selector，将Service和Endpoint对象(Pod的IP:Port)关联起来。查看Endpoint对象：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get endpoints</span><br></pre></td></tr></table></figure>
<p>  &emsp;Kubernetes分配给Service的ClusterIP只能在内部访问，若想Service被外部访问则需要分配一个”公网IP”。暴露Service的方式有三种：</p>
<ul>
<li><strong>NodePort</strong>：这种是最常用的方式，直接在Node机器上监听端口。在定义Service时指定<code>spec.type=NodePort</code>并指定<code>spec.ports.nodePort</code>的值。Kubernetes会在Node上监听<code>spec.ports.nodePort</code>端口提供外部访问。并非一定要要指定<code>spec.ports.nodePort</code>的值，<code>spec.ports.nodePort</code>端口的范围必须在<code>30000</code>~<code>32767</code>内，不指定<code>spec.ports.nodePort</code>则会随机在范围内分配一个IP。</li>
<li><strong>LoadBalancer</strong>：这种是在云服务(GCE/AWS)提供LoadBalancer时可使用，在定义Service时指定<code>spec.type=LoadBalancer</code>并指定Service的<code>nodePort</code>和<code>ClusterIP</code></li>
<li><strong>Ingress</strong>：Ingress是Kubernetes1.2版本后引入的，通过Ingress来利用Nginx/HAProxy等常见开源反向代理软件实现对外暴露服务功能。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Volume</strong><br>  &emsp;Volume是Pod中能被多个容器访问的共享目录。Kubernetes的Volume和Docker的Volume差不多，但Kubernetes的Volume是随Pod销毁而销毁的，Pod中的容器停止或重启不影响Kubernetes的Volume。<br>  &emsp;Kubernetes提供多种类型的Volume，如下所示：</p>
<ul>
<li><strong>EmptyDir</strong>：EmptyDir Volume在Pod被分配到Node时创建，Pod内的所有容器都可以读写EmptyDir中的文件。Pod被删除时EmptyDir也会被删除。</li>
<li><p><strong>hostPath</strong>：hostPath Volume是在Pod中挂载宿主机上的文件或目录。常用于需要持久保留的文件。由于Pod可能分配到多个Node上，挂载多个Node的hostPath Volume可能会导致数据的不一致。可在创建RC的时候指定Pod挂载宿主机的目录，比如将宿主机中<code>/data</code>目录挂载到Pod容器内的<code>/data</code>上：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">2</span></span><br><span class="line">  selector:</span><br><span class="line">    name: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: nginx</span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">        - name: <span class="string">"nginx-log"</span></span><br><span class="line">          hostPath:</span><br><span class="line">            path: <span class="string">"/data"</span></span><br><span class="line">      containers:</span><br><span class="line">        - name: nginx</span><br><span class="line">          image: nginx</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: <span class="number">80</span></span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: <span class="string">"nginx-log"</span></span><br><span class="line">              mountPath: <span class="string">"/data"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>gcePersistentDisk</strong>：使用GCE的永久磁盘(Persistent Disk)，当Pod被删除时，这类磁盘只被卸载不会被删除。</p>
</li>
<li><strong>awsElasticBlockStore</strong>：使用AWS的EBS。</li>
<li><strong>nfs</strong>：使用NFS提供的目录挂载到Pod中。</li>
<li><strong>glusterfs</strong>：使用GlusterFS提供的目录挂载到Pod中。</li>
<li><strong>rdb</strong>：使用Linux块设备共享存储挂载到Pod中。</li>
<li><strong>gitRepo</strong>：通过挂载一个空目录，并从GIT库clone一个git repository以供pod使用。</li>
<li><strong>secret</strong>：为Pod提供加密存储，Secret Volume是通过tmpfs实现的，不能持久化。</li>
<li><strong>persistentVolumeClaim</strong>：从PV（persistentVolume）中申请所需的空间，PV通常是种网络存储，如GCEPersistentDisk、AWSElasticBlockStore、NFS、iSCSI等。</li>
</ul>
</li>
<li><p><strong>Namespace</strong><br>  &emsp;Kubernetes的Namespace和Linux系统中的Namespace并非同一个东西，但功能相似都是用于隔离。Kubernetes通过将对象分配到不同的Namespace中以达到分组管理的目的。<br>  &emsp;Kubernetes启动后会创建一个<strong><code>default</code></strong>的Namespace，使用<code>kubeadm</code>部署集群的话会创建<code>kube-system</code>的Namespace。若不知道资源对象的Namespace，则Pod、RC、Service等都会被创建到<code>default</code>的默认Namespace中。可通过以下命令查看Namespace：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespace</span><br></pre></td></tr></table></figure>
<p>  &emsp;可通过yaml文件创建Namespace：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#namespace-test.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create <span class="operator">-f</span> namespace-test.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Annotation</strong><br>  &emsp;Annotation也是使用<code>key/value</code>形式进行定义，个人理解为相当于备注的作用。</p>
</li>
</ul>
<h4 id="Kubernetes创建Pod流程"><a href="#Kubernetes创建Pod流程" class="headerlink" title="Kubernetes创建Pod流程"></a><strong>Kubernetes创建Pod流程</strong></h4><ol>
<li>通过<code>kubectl</code>提交一个创建RC请求给<code>kube-apiserver</code>，<code>kube-apiserver</code>将请求存到<code>etcd</code></li>
<li><code>kube-controller-manager</code>通过调用<code>kube-apiserver</code>接口得知创建RC事件，分析后发现集群中没有该RC对应的Pod，根据RC定义中的Pod模板生成Pod对象并调用<code>kube-apiserver</code>接口存入<code>etcd</code>。</li>
<li><code>kube-scheduler</code>监听etcd发现有创建Pod事件，<code>kube-scheduler</code>根据算法得出Pod被分配到哪个Node，调用<code>kube-apiserver</code>将结果存入<code>etcd</code>。</li>
<li>目标Node上的<code>kubectl</code>通过调用<code>kube-apiserver</code>得知需要创建Pod并按照相关定义创建Pod及容器。该Node的<code>kubectl</code>对Pod进行监控和管理并定期调用<code>kube-apiserver</code>接口上报Pod的状态。</li>
</ol>
<h4 id="Kubernetes创建Service流程"><a href="#Kubernetes创建Service流程" class="headerlink" title="Kubernetes创建Service流程"></a><strong>Kubernetes创建Service流程</strong></h4><ol>
<li>通过<code>kubectl</code>提交创建Service请求给<code>kube-apiserver</code>，<code>kube-apiserver</code>将请求存到<code>etcd</code></li>
<li><code>kube-controller-manager</code>调用<code>kube-apiserver</code>接口得知创建Service事件，通过<code>Label</code>查询到与Service相关的Pod，生成Service的Endpoint信息并调用<code>kube-apiserver</code>接口存入<code>etcd</code>。</li>
<li>Node上的<code>kube-proxy</code>调用<code>kube-apiserver</code>接口查询到Service和对应Endpoint信息，在Node上监听随机端口，配置iptables将所有到Service的ClusterIP:Port的请求都转发到<code>kube-proxy</code>监听的随机端口上，<code>kube-proxy</code>将请求转发到Pod上。</li>
</ol>
<h2 id="Kubernetes核心原理"><a href="#Kubernetes核心原理" class="headerlink" title="Kubernetes核心原理"></a><strong>Kubernetes核心原理</strong></h2><h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a><strong>kube-apiserver</strong></h3><p>&emsp;&emsp;kube-apiserver默认会监听两个端口，一个是非安全用于接受HTTP请求的<code>8080</code>端口，另一个是安全的HTTPS端口<code>6443</code>用于认证等安全机制请求，kube-apiserver主要功能：</p>
<ul>
<li>提供集群管理API接口</li>
<li>集群各功能模块间数据交互和通信的中枢</li>
<li>提供安全机制</li>
</ul>
<p>&emsp;&emsp;Kubernetes提供<code>kubectl</code>命令行工具将API功能封装成简单的命令集。更多具体功能使用<code>kubectl -h</code>获取。<br>&emsp;&emsp;kube-apiserver提供API接口访问Pod、Node和Service等，详细的API接口没去研究。<br>&emsp;&emsp;Kubernetes中基本上都是通过调用kube-apiserver提供的接口完成集群中模块间信息的交换的。比如Node上的<code>kubectl</code>会定期调用API报告节点状态并存入etcd中，Node Controller通过调用API获取到节点相关信息并作出相应操作。为了缓解kube-apiserver的压力各功能模块会定时调用API获取信息并保持到本地缓存，使得某些情况下模块不需要直接调用API而通过访问缓存数据间接调用API。</p>
<h3 id="kube-controller-manager原理"><a href="#kube-controller-manager原理" class="headerlink" title="kube-controller-manager原理"></a><strong>kube-controller-manager原理</strong></h3><p>&emsp;&emsp;<code>kube-controller-manager</code>作为Kubernetes集群的管理控制中心，对集群内的Node、Pod副本、Endpoint、Namespace、ServiceAccount和ResourceQuota等资源进行管理及执行自动修复流程。如上所说，<code>kube-controller-manager</code>是由多个Controller组成，对各个Controller进行较深入了解。</p>
<h4 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a><strong>Replication Controller</strong></h4><p>&emsp;&emsp;Replication Controller的主要功能是确保Pod的副本数目和RC定义中的一致。正常来说，都是通过RC来创建Pod的，所以Replication Controller的管理对象是Pod。Pod的状态值如下：</p>
<ul>
<li><strong>pending</strong>：API Server已创建Pod，但Pod内有一个或多个容器没创建</li>
<li><strong>running</strong>：Pod内所有容器已创建，且至少有一个容器正常运行</li>
<li><strong>successded</strong>：Pod内所有容器均停止成功且不会再重启</li>
<li><strong>failed</strong>：Pod内所有容器已退出，且至少一个发生错误退出</li>
</ul>
<p>&emsp;&emsp;Pod的重启策略有三种<code>Always</code>、<code>OnFailure</code>和<code>Never</code>，只有是<code>Always</code>时，Replication  Controller才会管理该Pod。当Pod副本状态为<code>failed</code>或被删除且<code>RestartPolicy=Always</code>时，Replication Controller会重新创建该Pod的副本。</p>
<p>&emsp;&emsp;通过具体的RC实例来说明Replication Controller是如何创建Pod的。创建一个Nginx的RC实例，启动2个Pod：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">2</span></span><br><span class="line">  selector:</span><br><span class="line">    name: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: nginx</span><br><span class="line">          image: nginx</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>kind: ReplicationController</code>：指明这是个ReplicationController</li>
<li><code>spec.replicas</code>：指明该RC的Pod副本数目</li>
<li><code>spec.selector</code>：指明该RC关联的Pod</li>
<li><code>spec.template</code>：RC创建的Pod实例都是根据RC定义中的创建。</li>
<li><code>spec.template.spec.containers</code>：指明Pod中容器的属性(该使用什么镜像、端口等)</li>
</ul>
<p>&emsp;&emsp;需要注意到是，删除RC并不会影响其所已经创建的Pod。Pod可以通过修改其Label实现脱离RC的管控(RC是通过<code>spec.selector</code>中的<code>name</code>来关联Pod的)。<br>&emsp;&emsp;Replication Controller主要就是根据RC定义中的<code>spec.replicas</code>值来调整Pod的副本数目，以确保集群中有且仅有<code>spec.replicas</code>个Pod实例。<br>&emsp;&emsp;Replication Controller的常用模式如下：</p>
<ul>
<li><strong>Rescheduling</strong>：重新调度，即在Pod副本实例发生异常时重新创建Pod副本实例。</li>
<li><p><strong>Scaling</strong>：手动或自动扩容/缩容。可通过<code>kubectl scale</code>命令实现</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale rc &lt;ReplicationControllerName&gt; --replicas=&lt;NUM&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Rolling Updates</strong>：滚动更新，ReplicationController通过逐个对Pod进行更新来实现滚动升级。一般是重新创建一个RC，然后新RC中的Pod数目不断增加，旧RC中Pod数目不断减少直至<code>0</code>。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rolling-update &lt;OLD_RC_NAME&gt; --update-period=<span class="number">10</span>s <span class="operator">-f</span> &lt;NEW_RC&gt;.yaml</span><br></pre></td></tr></table></figure>
<p>  &emsp;Kubernetes1.2版本后推荐使用<strong>Deployment</strong>来进行Rolling Updates。新的Deployment会创建<strong>ReplicaSet</strong>，关于这个内容改天专门来写。</p>
</li>
</ul>
<h4 id="Node-Controller"><a href="#Node-Controller" class="headerlink" title="Node Controller"></a><strong>Node Controller</strong></h4><p>&emsp;&emsp;Node Controller主要负责发现、管理和监控Node。<code>kubectl</code>启动时调用API注册Node并定时调用API上报Node信息，<code>kube-apiserver</code>将Node信息存入etcd。Node信息包括：Node健康状态、节点资源、节点名称、节点地址信息、OS版本、Docker版本和kubelet版本。<br>&emsp;&emsp;Node健康状态分为：<code>True</code>(就绪)、<code>False</code>(未就绪)和<code>Unknown</code>(未知)<br>&emsp;&emsp;Node Controller会定期调用API接口获取Node信息。如果<code>kube-controller-manager</code>启动时没有指定<code>CIDR</code>则为每个Node生产<code>CIDR</code>并设置Node的<code>spec.PodCIDR</code>属性；逐个读取Node信息并和Node Controller中<code>nodeStatusMap</code>中保存的信息做对比，若无变化则更新探测时间，有变化则更新<code>nodeStatusMap</code>中的信息。若规定时间内没收到Node信息则将状态设置为<code>Unknown</code>并调用API存入etcd。再逐个读取Node信息，将非<code>True</code>状态Node加入待删队列，若发现该Node故障则删除etcd中Node信息及相关资源信息。</p>
<h4 id="ResourceQuota-Controller"><a href="#ResourceQuota-Controller" class="headerlink" title="ResourceQuota Controller"></a><strong>ResourceQuota Controller</strong></h4><p>&emsp;&emsp;ResourceQuota Controller是对Kubernetes集群进行资源配额管理的，支持三个层次的资源配额管理：</p>
<ul>
<li>容器级别：对容器CPU和Memory进行限制</li>
<li>Pod级别：对Pod内所有容器进行资源限制</li>
<li>Namespace级别：Namespace级别的限制包括以下方面：<ul>
<li>Pod数量</li>
<li>RC数量</li>
<li>Service数量</li>
<li>ResourceQuota数量</li>
<li>Secret数量</li>
<li>PV(persistentVolume)数量</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;Kubernetes中配额管理是通过<strong>准入机制(admission control)</strong>实现的，配额的准入控制器有<strong>LimitRanger</strong>和<strong>ResourceQuota</strong>，LimitRanger作用于Pod和Container，ResourceQuota作用于Namespace。<br>&emsp;&emsp;ResourceQuota Controller以Namespace作为分组统计单元，调用API定时从etcd中获取每个Namespace中的ResourceQuota信息，计算Pod、RC、Service等资源对象和Container实例使用的资源(CPU/Memory)并调用API存入etcd。用户请求创建资源时，kube-apiserver调用admission controller的ResourceQuota插件从etcd中配额信息，若某项资源超过配额则该请求被拒绝。</p>
<h4 id="Namespace-Controller"><a href="#Namespace-Controller" class="headerlink" title="Namespace Controller"></a><strong>Namespace Controller</strong></h4><p>&emsp;&emsp;Namespace Controller主要就是用来管理Namespace的。当Namespace被标记为<strong>优雅删除</strong>(即设置了<code>DeletionTimestamp</code>删除期限)，则该Namespace状态被设置为<code>Terminating</code>。Namespace Controller会删除该Namespace下的所有资源，然后执行<code>finalize</code>操作(删除<code>spec.finalizers</code>信息)。当Namespace Controller发现一个Namespace设置了<code>DeletionTimestamp</code>且<code>spec.finalizers</code>值为空则调用API删除Namespace。</p>
<h4 id="Service-Controller-amp-Endpoint-Controller"><a href="#Service-Controller-amp-Endpoint-Controller" class="headerlink" title="Service Controller &amp; Endpoint Controller"></a><strong>Service Controller &amp; Endpoint Controller</strong></h4><p>&emsp;&emsp;当调用API创建Service时，Kubernetes会为该Service指派一个集群内网IP<code>ClusterIP</code>，Service中的<code>spec.selector</code>指明该Service和<code>name: nginx</code>的Pod关联，每个Pod的<code>80</code>端口都被映射到本地节点的<code>80</code>端口(<code>targetPort</code>)。创建Service时指定了<code>spec.selector</code>的话，Kubernetes会创建一个和Service<strong>同名的</strong>Endpoint对象。该Endpoint对象其实就是和Service关联的Pod的IP+Port。<br>&emsp;&emsp;也可创建没<code>spec.selector</code>的Service，Kubernetes便不会自动创建与之相关的Endpoint，可手动创建和Service同名的Endpoint指定后端Pod。<br>&emsp;创建Nginx的Service实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">  labels:</span><br><span class="line">    name: nginx-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: <span class="number">80</span></span><br><span class="line">      targetPort: <span class="number">80</span></span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    name: nginx</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;Service是Kubernetes中的对象，请求从Service到Pod的工作是由<code>kube-proxy</code>来完成的。<code>kube-proxy</code>为每个Service在本机上随机监听一个端口，通过添加iptables规则将访问Service的请求转发到<code>kube-proxy</code>的随机端口，然后<code>kube-proxy</code>根据<code>Round Robin</code>算法及Session保持(<code>SessionAffinity</code>)决定将请求转发到后端的哪个Pod。<br>&emsp;&emsp;Kubernetes支持两种模式找到Service：</p>
<ul>
<li>Container的Service环境变量<br>  在创建Pod时，在所有Pod中的Container中加入一系列的Service环境变量，如<code>{SVCNAME}_SERVICE_HOST</code>/<code>{SVCNAME}_SERVICE_PORT</code>等，<code>{SVCNAME}</code>是大写的Service Name，若有<code>-</code>则自动转换为<code>_</code>。</li>
<li>DNS<br>  DNS服务器通过调用API监控Service相关活动，新增Service时创建一系列DNS记录。<br>  更为常用的是DNS SVC被命名端口的记录，若<code>service_name.namespace_name</code>的Service有名为”http”的端口，则可用<code>_http._tcp.service_name.namespace_name</code>通过DNS服务器找到对于的Pod暴露端口。</li>
</ul>
<p>&emsp;&emsp;对于Service的暴露，如前面所说常用三种方式：<strong>LoadBalancer</strong>、<strong>NodePort</strong>和<strong>Ingress</strong>。详细参照前面。<br>&emsp;&emsp;Service Controller和Endpoint Controller分别监控Service和Endpoint对象，调用API更新变更再存入etcd中。</p>
<h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a><strong>kube-scheduler</strong></h4><p>&emsp;&emsp;<code>kube-scheduler</code>主要负责Pod的调度，将待调度的Pod按照特定的调度算法和调度策略绑定到合适的Node上并将信息存入etcd。Node上的<code>kubelet</code>监听到<code>kube-scheduler</code>产生的Pod绑定事件后，获取对应的Pod清单、下载image镜像并启动Container容器。<br>&emsp;&emsp;<code>kube-scheduler</code>默认调度流程分两步，Kubernetes提供一系列的预选策略和优选策略，此处不一一具体分析：</p>
<ul>
<li>预选策略：遍历所有Node，筛选符合条件的Node。</li>
<li>优选策略：基于预选策略，采用优选策略计算积分，最终选出最佳Node。</li>
</ul>
<h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a><strong>kubelet</strong></h4><p>&emsp;&emsp;Kubernetes会在每个Node节点中运行<code>kubelet</code>，<code>kubelet</code>主要负责以下功能：</p>
<ul>
<li>Node管理<br>  <code>kubelet</code>在启动时会调用API以注册Node信息(可手动设置不进行自动注册)，并定期调用API将信息存入etcd。</li>
<li>Pod管理<br>  <code>kubelet</code>通常通过以下3种获取Node上的Pod清单：<ul>
<li>文件：在启动<code>kubelet</code>时指定，<code>--pod-manifest-path=/etc/kubernetes/manifests</code>。</li>
<li>HTTP URL：指定<code>--manifest-url</code>。</li>
<li>API Server：调用API监听etcd目录同步Pod清单。<br>前两种非API Server方式创建的Pod称之为<strong>Static Pod</strong>，<code>kubelet</code>会将Static Pod汇报给API Server，API Server会为Static Pod创建Mirror Pod与其匹配。<br><code>kubelet</code>通过API Server方式创建或修改Pod大致流程如下：</li>
</ul>
<ol>
<li>创建Pod的数据目录</li>
<li>调用API获取Pod清单</li>
<li>挂载外部卷(Extenal Volume)到Pod</li>
<li>下载Pod所需的Secret</li>
<li>检查Node运行中的Pod，若Pod中无容器或<code>Pause</code>容器没启动，则先停止Pod内所有容器，若有要删除的容器则删除</li>
<li>为每个Pod创建<code>Pause</code>容器，Pod中的其他容器通过<code>Pause</code>容器共享网络</li>
<li>为Pod中的每个容器做如下处理：为容器计算hash值，用容器名去Docker查询对应容器的hash值，若hash值不同则停止容器。若设置了<code>restartPolicy</code>则按照策略处理，无则调用Docker client下载镜像并运行容器。</li>
</ol>
</li>
<li><p>健康检查<br>  Pod通过两种探针检查容器健康状态：</p>
<ul>
<li><p><strong>LivenessProbe</strong>：用于判断容器是否健康。若不健康，<code>kubelet</code>则删除容器并按照<code>restartPolicy</code>策略处理。LivenessProbe检查可分成三种实现方式，<code>LivenessProbe</code>的定义在Pod的<strong><code>spec.containers</code></strong>中：</p>
<ol>
<li><p><strong>ExecAction</strong>：容器内执行一条命令，退出码为<code>0</code>则健康</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: nginx</span><br><span class="line">      image: nginx</span><br><span class="line">      imagePullPolicy: IfNotPresent</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">      livenessProbe:</span><br><span class="line">        <span class="built_in">exec</span>:</span><br><span class="line">          <span class="built_in">command</span>:</span><br><span class="line">          - cat</span><br><span class="line">          - /tmp/healthy</span><br><span class="line">        initialDelaySeconds: <span class="number">5</span></span><br><span class="line">        periodSeconds: <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>TCPSocketAction</strong>：对容器内端口做TCP检测，端口能被访问则健康</p>
</li>
<li><strong>HTTPGetAction</strong>：对容器特点的端口+路径调用<code>GET</code>方法，HTTP响应状态码在<code>200</code>~<code>400</code>之间为健康 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: nginx</span><br><span class="line">      image: nginx</span><br><span class="line">      imagePullPolicy: IfNotPresent</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">      livenessProbe:</span><br><span class="line">        httpGet:</span><br><span class="line">          path: /heath_pah</span><br><span class="line">          port: <span class="number">80</span></span><br><span class="line">          httpHeaders:</span><br><span class="line">            - name: X-Custom-Header</span><br><span class="line">              value: Awesome</span><br><span class="line">        initialDelaySeconds: <span class="number">5</span></span><br><span class="line">        periodSeconds: <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>ReadinessProbe</strong>：用于判断容器是否启动完成且准备接受请求。若ReadinessProbe检查失败，Endpoint Controller会删除Service中该Pod的Endpoint信息。</p>
</li>
</ul>
</li>
</ul>
<h4 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a><strong>网络原理</strong></h4><ul>
<li><p><strong>Kubernetes网络模型</strong><br>  &emsp;&emsp;Kubernetes使用的网络模型称为<strong>IP-per-Pod</strong>模型，每个Pod拥有单独的IP地址，IP是以Pod为单位分配的。一个Pod内的所有容器共享网络(使用同一个Network Namespace通过Pause容器实现)，IP和端口在Pod内部和外部都是一致的(不需要NAT)。<br>  &emsp;&emsp;Kubernetes设计之初是运行在谷歌的GCE环境上的，GCE默认就支持Kubernetes的网络。但要在非GCE环境运行Kubernetes则需要先搭建出符合Kubernetes网络要求的环境，目前开源的方案有很多诸如Flannel、Weave等用于实现Kubernetes中容器与容器之间网络的环境。<br>  &emsp;&emsp;Kubernetes主要针对一下几种网络场景制定不同的解决方案：</p>
<ul>
<li>容器间通信<br>  这里的容器间通信特指在同一个Pod内的容器间通信，正如前面所说，同一个Pod内的容器是通过Pause容器共享同一个Network Namespace的，同一个Pod内的容器甚至可以通过<code>localhost</code>直接访问彼此的端口，这就使得同一个Pod内容器间的通信变得简单高效。</li>
<li><p>Pod间通信</p>
<ul>
<li>同一Node中Pod间通信<br>  由于同一个Node中的不同Pod都是通过<code>veth</code>连接到同一个<code>docker0</code>网桥上，Pod的IP地址和<code>docker0</code>的IP地址在同一个网段内，所有同一个Node上的不同Pod都由<code>docker0</code>网桥进行中转，可直接通信。</li>
<li><p>不同Node中Pod间通信<br>  由于Pod的IP是隐藏在<code>docker0</code>网桥后的，出了<code>docker0</code>后不同Node之间的Pod是无法感知到对方，所以需要有完善的网络方案使得Pod之间能使用私有IP进行通信、集群内Pod的IP分配不会冲突、Pod的IP和Node的IP关联(Pod通信时需要先找到Node)。为此有了多个不同的开源网络组件：</p>
<ul>
<li><p>Flannel<br>  Flannel会创建<code>flannel0</code>网桥，一端连接<code>docker0</code>，另一端连接<code>flanneld</code>服务进程。<code>flanneld</code>服务进程利用<code>etcd</code>来管理分配IP并监听<code>etcd</code>中每个Pod的IP，创建Pod节点路由表。<code>flanneld</code>服务进程根据Pod节点路由表将从<code>docker0</code>发来的数据包进行封装通过物理网络传输到目的<code>flanneld</code>上，以此完成不同Node上的Pod通信。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">containerA--&gt;docker0--&gt;flannel0--&gt;flanneld--&gt;NodeA--&gt;[Network]--&gt;NodeB--&gt;flanneld--&gt;flannel0--&gt;docker0--&gt;containerB</span><br></pre></td></tr></table></figure>
</li>
<li><p>Open vSwitch<br>  Open vSwitch是一个开源虚拟交换机软件，该项目较成熟但比较复杂，一般最求高性能网络的话网上都比较推荐此方案，由于比较复杂我也没怎么研究。</p>
</li>
<li>直接路由<br>  简单来说，直接路由就是让集群能够通过<code>docker0</code>直接通信，让每个Node的路由表有到所有<code>docker0</code>的路由，将<code>docker0</code>和Node的<code>eth0</code>关联起来。简单的可手动在所有Node上添加到集群内所有<code>docker0</code>地址的路由，但更实际的方案是结合动态路由协议来做。</li>
</ul>
</li>
</ul>
</li>
<li>Pod和Service间通信<br>  正如前面所说，Pod和Service间的通信是通过<code>kube-proxy</code>实现的，<code>kube-proxy</code>为Service随机监听一个端口并添加iptables规则将到Service的请求转发到<code>kube-proxy</code>，再由<code>kube-proxy</code>根据Endpoint信息转发到后端的Pod。<br>  值得一提的是如果Service定义中指定了Session保持，则<code>kube-proxy</code>会查看是否存在改IP的<code>affinityState</code>对象，存在则转到改对象对应的Pod。</li>
<li>外部到内部访问<br>  同样如前面所说，外部访问内部目前主要有3种方式：NodePort、LoadBalancer和Ingress。接下来重点讲一下<strong>Ingress</strong>。<br>  Ingress是利用Nginx/HAProxy等反向代理软件来暴露服务，从而实现外部到内部的访问，Ingress可根据URL(<code>/serviceA</code>)、域名来进行暴露Service。<br>  Ingress在Kubernetes中也是一个对象资源，Kubernetes使用<strong>Ingress Controller</strong>来对控制管理Ingress资源，Ingress Controller主要与Kubernetes API交互，负责感知规则变化，然后生成配置文件，最后reload Pod中的Nginx。Ingress Controller不像其他Controller一样包含在<code>kube-controller-manager</code>里，需要选择适合的Ingress Controller并运行。</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;&emsp;《Kubernetes权威指南》的阅读笔记，由于Kubernetes项目还在快速发展中，书里有些内容已有更新的变化，不过核心内容变化不大，书还是值得认真看的。</p>
<h2 id="基本概念"><a href="#基本概念" class="head]]>
    </summary>
    
      <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ELK+Kafka+Search-Guard+Sentinl全攻略]]></title>
    <link href="http://yoursite.com/2017/02/28/ELK-full/"/>
    <id>http://yoursite.com/2017/02/28/ELK-full/</id>
    <published>2017-02-28T08:29:11.000Z</published>
    <updated>2019-03-31T04:24:48.672Z</updated>
    <content type="html"><![CDATA[<p>&emsp;&emsp;ELK(Elasticsearch/Logstash/Kibana)是目前对日志采集分析比较适合的解决方案；Kafka是一个分布式高可用高吞吐的消息队列软件，在日志量大及对数据可靠性要求高的场景使用；Search-Guard是一款开源的、对Elasticsearch提供安全及权限控制功能的插件；Sentinl是一款类似Watch的Kibana插件，提供监控、报警和报告功能。<br>&emsp;&emsp;这整个系统为日志的采集、存储、查询、图表分析和监控报警提供一套完整的解决方案。</p>
<h2 id="软件版本列表"><a href="#软件版本列表" class="headerlink" title="软件版本列表"></a><strong>软件版本列表</strong></h2><ul>
<li>CentOS 6.8 64bit</li>
<li>JDK1.8.0_51</li>
<li><a href="https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/tar/elasticsearch/2.4.4/elasticsearch-2.4.4.tar.gz" target="_blank" rel="external">Elasticsearch-2.4.4</a></li>
<li><a href="https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-5.2.0-x86_64.rpm" target="_blank" rel="external">Filebeat-5.2.0</a></li>
<li><a href="https://download.elastic.co/logstash/logstash/logstash-2.4.1.tar.gz" target="_blank" rel="external">Logstash-2.4.1</a></li>
<li><a href="https://download.elastic.co/kibana/kibana/kibana-4.6.4-linux-x86_64.tar.gz" target="_blank" rel="external">Kibana-4.6.4</a></li>
<li><a href="http://apache.communilink.net/kafka/0.10.0.0/kafka_2.11-0.10.0.0.tgz" target="_blank" rel="external">Kafka_2.11-0.10.0.0</a></li>
<li>Search-Guard-SSL/2.4.4.19</li>
<li>Search-Guard-2/2.4.4.10</li>
<li>Sentinl</li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a><strong>Kafka</strong></h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf kafka_2<span class="number">.11</span>-<span class="number">0.10</span><span class="number">.0</span><span class="number">.0</span>.tgz</span><br><span class="line">mv kafka_2<span class="number">.11</span>-<span class="number">0.10</span><span class="number">.0</span><span class="number">.0</span> /usr/local/kafka</span><br><span class="line">mkdir /data/zookeeper</span><br><span class="line">chown -R osadmin:osadmin /data/zookeeper</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h3><h4 id="zookeeper配置"><a href="#zookeeper配置" class="headerlink" title="zookeeper配置"></a><strong>zookeeper配置</strong></h4><ul>
<li><p><strong>/usr/local/kafka/config/zookeeper.properties</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line">initLimit=<span class="number">10</span></span><br><span class="line">syncLimit=<span class="number">5</span></span><br><span class="line">dataDir=/data/zookeeper</span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line">server.<span class="number">0</span>=<span class="number">10.201</span>.<span class="number">3.33</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line">server.<span class="number">1</span>=<span class="number">10.201</span>.<span class="number">3.30</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置集群节点myid<br>  &emsp;根据配置文件中<strong><code>server.X</code></strong>设置集群节点的<code>myid</code></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> X &gt; /data/zookeeper/myid</span><br></pre></td></tr></table></figure>
</li>
<li><p>zookeeper调整JVM内存大小<br>  &emsp;zookeeper默认的JVM堆内存大小为<code>512M</code>，可视具体情况调整<br>  &emsp;<strong>/usr/local/kafka/bin/zookeeper-server-start.sh</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">"-Xmx512M -Xms512M"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动zookeeper<br>  &emsp;手动启动zookeeper(更好的方式是使用<strong>Supervisord</strong>来管理)</p>
  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup <span class="regexp">/usr/</span>local<span class="regexp">/kafka/</span>bin<span class="regexp">/zookeeper-server-start.sh /u</span>sr<span class="regexp">/local/</span>kafka<span class="regexp">/config/</span>zookeeper.properties &amp;&gt; <span class="regexp">/usr/</span>local<span class="regexp">/kafka/</span>logs<span class="regexp">/zookeeper.log &amp;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Kafka配置"><a href="#Kafka配置" class="headerlink" title="Kafka配置"></a><strong>Kafka配置</strong></h4><ul>
<li><p><strong>/usr/local/kafka/config/server.properties</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#id唯一</span></span><br><span class="line">broker.id=<span class="number">0</span></span><br><span class="line">port=<span class="number">9092</span></span><br><span class="line">advertised.host.name=<span class="number">10.201</span>.<span class="number">3.33</span></span><br><span class="line"><span class="comment">#host.name唯一</span></span><br><span class="line">host.name=<span class="number">10.201</span>.<span class="number">3.33</span></span><br><span class="line">num.network.threads=<span class="number">3</span></span><br><span class="line">num.io.threads=<span class="number">8</span></span><br><span class="line">socket.send.buffer.bytes=<span class="number">102400</span></span><br><span class="line">socket.receive.buffer.bytes=<span class="number">102400</span></span><br><span class="line">socket.request.max.bytes=<span class="number">104857600</span></span><br><span class="line">log.dirs=/usr/<span class="built_in">local</span>/kafka/logs</span><br><span class="line">num.partitions=<span class="number">5</span></span><br><span class="line">num.recovery.threads.per.data.dir=<span class="number">1</span></span><br><span class="line">log.retention.hours=<span class="number">72</span></span><br><span class="line">log.segment.bytes=<span class="number">1073741824</span></span><br><span class="line">log.retention.check.interval.ms=<span class="number">300000</span></span><br><span class="line">zookeeper.connect=<span class="number">10.201</span>.<span class="number">3.33</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.30</span>:<span class="number">2181</span></span><br><span class="line">zookeeper.connection.timeout.ms=<span class="number">6000</span></span><br><span class="line">delete.topic.enable=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Kafka配置集群注意事项</strong></p>
<ol>
<li>echo X &gt; /data/zookeeper/myid</li>
<li>/usr/local/kafka/config/server.properties<ul>
<li>broker.id</li>
<li>host.name</li>
</ul>
</li>
</ol>
</li>
<li><p>Kafka调优项</p>
<ul>
<li><p>调整JVM内存大小<br>  &emsp;Kafka默认的JVM堆内存大小为<code>1G</code>，如果需要承载较大日志量可视具体情况调整JVM堆内存大小，建议JVM堆的内存大小最好不要超过<strong>4G</strong>。<br>  &emsp;<strong>/usr/local/kafka/bin/kafka-server-start.sh</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">"-Xmx3G -Xms3G"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>线程数调整<br>  &emsp;在需要处理大量日志的场景时可调整<code>num.network.threads</code>和<code>num.io.threads</code></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num.network.threads=nproc</span><br><span class="line">num.io.threads=<span class="number">2</span>*nproc</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>启动Kafka<br>  &emsp;手动启动kafka(更好的方式是使用<strong>Supervisord</strong>来管理)</p>
  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup <span class="regexp">/usr/</span>local<span class="regexp">/kafka/</span>bin<span class="regexp">/kafka-server-start.sh /u</span>sr<span class="regexp">/local/</span>kafka<span class="regexp">/config/</span>server.properties &amp;&gt; <span class="regexp">/usr/</span>local<span class="regexp">/kafka/</span>logs<span class="regexp">/kafka.log &amp;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="kafka常用操作"><a href="#kafka常用操作" class="headerlink" title="kafka常用操作"></a><strong>kafka常用操作</strong></h4><ul>
<li><p>创建topic</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --create --zookeeper <span class="number">10.201</span>.<span class="number">3.30</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.33</span>:<span class="number">2181</span> --replication-factor <span class="number">2</span> --partitions <span class="number">2</span> --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看topic</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出所有topic</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --list --zookeeper <span class="number">10.201</span>.<span class="number">3.30</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.33</span>:<span class="number">2181</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看具体topic</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --describe --zookeeper <span class="number">10.201</span>.<span class="number">3.30</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.33</span>:<span class="number">2181</span> --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除topic</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --delete --zookeeper <span class="number">10.201</span>.<span class="number">3.30</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.33</span>:<span class="number">2181</span> --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看logstash消费Kafka队列情况</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出所有consumer group</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-consumer-groups.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.30</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.33</span>:<span class="number">2181</span> --list</span><br><span class="line"><span class="comment">#默认所有logstash消费者在logstash的group中</span></span><br><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-consumer-groups.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.30</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.33</span>:<span class="number">2181</span> --describe --group logstash</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态增加Kafka partition<br>  &emsp;将<code>test</code>topic的partition<strong>增加到</strong><code>12</code>个</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --zookeeper <span class="number">10.201</span>.<span class="number">3.30</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.33</span>:<span class="number">2181</span> --alter --topic <span class="built_in">test</span> --partitions <span class="number">12</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="测试Kafka"><a href="#测试Kafka" class="headerlink" title="测试Kafka"></a><strong>测试Kafka</strong></h4><ul>
<li><p>生产消息</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-console-producer.sh --broker-list <span class="number">10.201</span>.<span class="number">3.33</span>:<span class="number">9092</span>,<span class="number">10.201</span>.<span class="number">3.30</span>:<span class="number">9092</span> --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消费消息</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-console-consumer.sh --zookeeper  <span class="number">10.201</span>.<span class="number">3.30</span>:<span class="number">2181</span>,<span class="number">10.201</span>.<span class="number">3.33</span>:<span class="number">2181</span> --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a><strong>Elasticsearch</strong></h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf elasticsearch-<span class="number">2.4</span><span class="number">.4</span>.tar.gz</span><br><span class="line">mv elasticsearch-<span class="number">2.4</span><span class="number">.4</span> <span class="regexp">/usr/</span>local/elasticsearch</span><br><span class="line">mkdir <span class="regexp">/usr/</span>local<span class="regexp">/elasticsearch/</span>&#123;logs,plugins&#125; /data</span><br><span class="line">chown -R <span class="string">osadmin:</span>osadmin <span class="regexp">/usr/</span>local<span class="regexp">/elasticsearch/</span></span><br></pre></td></tr></table></figure>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a><strong>配置</strong></h3><h4 id="文件打开数配置"><a href="#文件打开数配置" class="headerlink" title="文件打开数配置"></a><strong>文件打开数配置</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n <span class="number">655350</span></span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>/etc/security/limits.conf</strong><br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>soft nofile 655350</span><br><span class="line"><span class="bullet">* </span>hard nofile 655350</span><br><span class="line">osadmin soft memlock unlimited</span><br><span class="line">osadmin hard memlock unlimited</span><br></pre></td></tr></table></figure></p>
<h4 id="ES集群配置"><a href="#ES集群配置" class="headerlink" title="ES集群配置"></a><strong>ES集群配置</strong></h4><p>&emsp;<strong>/usr/local/elasticsearch/config/elasticsearch.yml</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">path.data: /data</span><br><span class="line">path.logs: /usr/<span class="built_in">local</span>/elasticsearch/logs</span><br><span class="line">path.plugins: /usr/<span class="built_in">local</span>/elasticsearch/plugins</span><br><span class="line">network.host: <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">http.port: <span class="number">9200</span></span><br><span class="line">bootstrap.mlockall: <span class="literal">true</span></span><br><span class="line">indices.fielddata.cache.size: <span class="number">75</span>%</span><br><span class="line">indices.breaker.fielddata.limit: <span class="number">85</span>%</span><br><span class="line">threadpool.search.queue_size: <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Cluster</span></span><br><span class="line">cluster.name: elk-cluster</span><br><span class="line">node.name: <span class="string">"10.201.3.49"</span></span><br><span class="line">node.master: <span class="literal">true</span></span><br><span class="line">node.data: <span class="literal">true</span></span><br><span class="line">discovery.zen.ping.multicast.enabled: <span class="literal">true</span></span><br><span class="line">discovery.zen.ping.unicast.hosts: [<span class="string">"10.201.3.49"</span>, <span class="string">"10.201.3.33"</span>, <span class="string">"10.201.3.30"</span>]</span><br><span class="line"><span class="comment">#cluster.routing.allocation.disk.threshold_enabled: false</span></span><br><span class="line"><span class="comment">#cluster.routing.allocation.disk.watermark.low: 90%</span></span><br><span class="line"><span class="comment">#cluster.routing.allocation.disk.watermark.high: 95%</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>path.data</code>：索引数据的存储路径</li>
<li><code>path.logs</code>：日志文件的存储路径</li>
<li><code>path.plugins</code>：插件安装路径</li>
<li><code>network.host</code>：监听IP</li>
<li><code>http.port</code>：监听端口</li>
<li><code>bootstrap.mlockall</code>：锁内存，使ES不使用swap</li>
<li><code>indices.fielddata.cache.size</code>：节点用于 fielddata 的最大内存(达到阀值旧数据将被交换出内存)</li>
<li><code>indices.breaker.fielddata.limit</code>：JVM 堆内存大小(确保 indices.breaker.fielddata.limit 的值大于 indices.fielddata.cache.size 的值)</li>
<li><p><code>threadpool.search.queue_size</code>：ES搜索队列大小(kibana查询量大时需要增大此值)</p>
</li>
<li><p><code>cluster.name</code>：集群名称(<code>cluster.name</code>相同的节点将自动组成一个集群)</p>
</li>
<li><code>node.name</code>：集群节点名称</li>
<li><code>node.master</code>：允许节点成为主节点</li>
<li><code>node.data</code>：允许节点存储数据</li>
<li><code>discovery.zen.ping.multicast.enabled</code>：允许组播发现节点</li>
<li><code>discovery.zen.ping.unicast.hosts</code>：集群初始节点列表(加速发现节点)</li>
</ul>
<h4 id="ES内存设置"><a href="#ES内存设置" class="headerlink" title="ES内存设置"></a><strong>ES内存设置</strong></h4><p><strong>/usr/local/elasticsearch/bin/elasticsearch.in.sh</strong><br>&emsp;内存充足情况尽量分配多内存给Elasticsearch，一般认为64bit机器最大分配内存不超过<strong>32G</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ES_MIN_MEM=<span class="number">10</span>g</span><br><span class="line">ES_MAX_MEM=<span class="number">10</span>g</span><br></pre></td></tr></table></figure></p>
<h3 id="Elasticsearch插件安装"><a href="#Elasticsearch插件安装" class="headerlink" title="Elasticsearch插件安装"></a><strong>Elasticsearch插件安装</strong></h3><ul>
<li><p><strong>head</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/elasticsearch</span><br><span class="line">/usr/local/elasticsearch/bin/plugin <span class="operator"><span class="keyword">install</span> mobz/elasticsearch-<span class="keyword">head</span></span><br><span class="line"></span><br><span class="line">#访问<span class="keyword">head</span>插件</span><br><span class="line"><span class="keyword">http</span>://<span class="number">10.201</span><span class="number">.3</span><span class="number">.49</span>:<span class="number">9200</span>/_plugin/<span class="keyword">head</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>kopf</strong></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /usr/<span class="keyword">local</span>/elasticsearch</span><br><span class="line">/usr/<span class="keyword">local</span>/elasticsearch/bin/<span class="keyword">plugin</span> install lmenezes/elasticsearch-kopf/2.1.1</span><br><span class="line"></span><br><span class="line">#访问kopf插件</span><br><span class="line">http:<span class="comment">//10.201.3.49:9200/_plugin/kopf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>curator</strong><br>  &emsp;&emsp;<strong>curator</strong>用于管理Elasticsearch索引</p>
<ul>
<li><p>安装</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install elasticsearch-curator==<span class="number">3.5</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看前缀sd-3-centos33-nginx且旧于30天的索引</span></span><br><span class="line">curator --timeout <span class="number">36000</span> --host localhost show indices --older-than <span class="number">30</span> --time-unit days --timestring <span class="string">'%Y.%m.%d'</span> --prefix sd-<span class="number">3</span>-centos33-nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭索引</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关闭前缀sd-3-centos33-nginx且旧于30天的索引</span></span><br><span class="line">curator --timeout <span class="number">36000</span> --host localhost close indices --older-than <span class="number">30</span> --time-unit days --timestring <span class="string">'%Y.%m.%d'</span> --prefix sd-<span class="number">3</span>-centos33-nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除前缀sd-3-centos33-nginx-的所有索引</span></span><br><span class="line">curator --timeout <span class="number">36000</span> --host localhost delete indices --time-unit days --timestring %Y.%m.%d --prefix sd-<span class="number">3</span>-centos33-nginx-</span><br></pre></td></tr></table></figure>
</li>
<li><p>配合search-guard执行方式<br>  &emsp;使用search-guard后所有对Elasticsearch的连接都强制使用HTTPS方式</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curator --http_auth &lt;user&gt;:&lt;password&gt; --use_ssl --timeout <span class="number">36000</span> --ssl-no-validate --host localhost show indices --time-unit days --timestring <span class="string">'%Y.%m.%d'</span> --prefix <span class="built_in">test</span>-nginx</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="Search-Guard"><a href="#Search-Guard" class="headerlink" title="Search-Guard"></a><strong>Search-Guard</strong></h2><p>&emsp;&emsp;Elasticsearch自身并没有认证和权限控制功能，导致安全性问题十分严重。Elasticsearch2.x的shield插件、Elasticsearch5.x的x-pack插件弥补了这个安全问题，但这两个插件都是需要付费才能长期使用的，<strong>search-guard</strong>是开源免费并能提供权限控制的插件。使用search-guard最好JDK的版本在<strong><code>1.8</code></strong>以上。</p>
<ul>
<li><a href="https://github.com/floragunncom/search-guard" target="_blank" rel="external">search-guard项目地址</a></li>
<li><a href="https://github.com/floragunncom/search-guard-docs" target="_blank" rel="external">search-guard官方文档</a></li>
</ul>
<h3 id="search-guard-ssl"><a href="#search-guard-ssl" class="headerlink" title="search-guard-ssl"></a><strong>search-guard-ssl</strong></h3><p>&emsp;&emsp;search-guard2.x版本需要依赖search-guard-ssl，search-guard-ssl需要使用<strong><code>openssl 1.0.1k</code></strong>以上版本。</p>
<h4 id="更新openssl"><a href="#更新openssl" class="headerlink" title="更新openssl"></a><strong>更新openssl</strong></h4><p>&emsp;&emsp;只需要要在使用search-guard-ssl生成证书的机器上更新openssl即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.openssl.org/<span class="built_in">source</span>/openssl-<span class="number">1.0</span>.<span class="number">1</span>k.tar.gz</span><br><span class="line">tar -zxf openssl-<span class="number">1.0</span>.<span class="number">1</span>k.tar.gz &amp;&amp; <span class="built_in">cd</span> openssl-<span class="number">1.0</span>.<span class="number">1</span>k</span><br><span class="line">./config shared zlib</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">mv /usr/bin/openssl /usr/bin/openssl.old &amp;&amp; mv /usr/include/openssl /usr/include/openssl.old</span><br><span class="line">ln <span class="operator">-s</span> /usr/<span class="built_in">local</span>/ssl/bin/openssl /usr/bin/openssl</span><br><span class="line">ln <span class="operator">-s</span> /usr/<span class="built_in">local</span>/ssl/include/openssl /usr/include/openssl</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/usr/local/ssl/lib"</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig -v</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看openssl版本</span></span><br><span class="line">openssl version</span><br></pre></td></tr></table></figure></p>
<h4 id="安装search-guard-ssl"><a href="#安装search-guard-ssl" class="headerlink" title="安装search-guard-ssl"></a><strong>安装search-guard-ssl</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/elasticsearch</span><br><span class="line">bin/plugin install -b com.floragunn/search-guard-ssl/<span class="number">2.4</span>.<span class="number">4.19</span></span><br></pre></td></tr></table></figure>
<h4 id="制作HTTPS证书"><a href="#制作HTTPS证书" class="headerlink" title="制作HTTPS证书"></a><strong>制作HTTPS证书</strong></h4><p>&emsp;&emsp;search-guard强制只能使用HTTPS方式访问Elasticsearch，所以需要使用search-guard-ssl制作HTTPS的相关证书。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/floragunncom/search-guard-ssl.git</span><br><span class="line"><span class="built_in">cd</span> search-guard-ssl/example-pki-scripts/</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>制作HTTPS证书脚本<br>  &emsp;&emsp;search-guard-ssl提供制作证书相关的脚本</p>
<ul>
<li>gen_client_node_cert.sh<br>  制作客户端证书</li>
<li>gen_node_cert.sh<br>  创建节点证书</li>
<li>gen_root_ca.sh<br>  创建根证书</li>
</ul>
</li>
<li><p>修改证书信息<br>  &emsp;&emsp;根据自身情况修改<code>gen_client_node_cert.sh</code>、<code>gen_node_cert.sh</code>证书相关的<strong>dname</strong>信息(不修改<code>dname</code>相关信息也无碍)</p>
<ul>
<li><strong><code>CN</code></strong>: 公用名称</li>
<li><strong><code>OU</code></strong>: 组织单位名称</li>
<li><strong><code>O</code></strong>: 组织名称</li>
<li><strong><code>L</code></strong>: 城市名称</li>
<li><strong><code>S</code></strong>: 省份名称</li>
<li><p><strong><code>C</code></strong>: 国家名称</p>
</li>
<li><p>gen_client_node_cert.sh</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-dname <span class="string">"CN=<span class="variable">$CLIENT_NAME</span>, OU=client, O=client, L=SZ, C=CN"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>gen_node_cert.sh</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-dname <span class="string">"CN=<span class="variable">$NODE_NAME</span>, OU=test, O=test, L=SZ, C=CN"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>修改example.sh脚本相关密码<br>  &emsp;&emsp;<code>example.sh</code>是search-guard-ssl提供的样例脚本，把<strong><code>CA</code></strong>、<strong><code>TrustStore</code></strong>和<strong><code>KeyStore</code></strong>改成自己设置的密码</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> <span class="operator">-e</span></span><br><span class="line">./clean.sh</span><br><span class="line">./gen_root_ca.sh &lt;your_CA_password&gt; &lt;your_TrustStore_password&gt;</span><br><span class="line">./gen_node_cert.sh &lt;your_node_name&gt; &lt;your_KeyStore_password&gt; &lt;your_CA_password&gt;</span><br><span class="line">./gen_client_node_cert.sh admin &lt;your_KeyStore_password&gt; &lt;your_CA_password&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝证书<br>  &emsp;&emsp;将生成的证书拷贝到<strong>所有</strong>节点相应的目录下。search-guard官方推荐每个ES节点的节点证书不同，这里所有节点都是使用的同一个节点证书。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp truststore.jks node-&lt;your_node_name&gt;-keystore.jks /usr/<span class="built_in">local</span>/elasticsearch/config/</span><br><span class="line">cp truststore.jks admin-keystore.jks /usr/<span class="built_in">local</span>/elasticsearch/plugins/search-guard-<span class="number">2</span>/sgconfig/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="安装search-guard"><a href="#安装search-guard" class="headerlink" title="安装search-guard"></a><strong>安装search-guard</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/elasticsearch</span><br><span class="line">bin/plugin install -b com.floragunn/search-guard-<span class="number">2</span>/<span class="number">2.4</span>.<span class="number">4.10</span></span><br></pre></td></tr></table></figure>
<h3 id="配置search-guard"><a href="#配置search-guard" class="headerlink" title="配置search-guard"></a><strong>配置search-guard</strong></h3><p>&emsp;&emsp;search-guard需要在Elasticsearch配置文件<strong>/usr/local/elasticsearch/config/elasticsearch.yml</strong>中新增配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#search-guard</span></span><br><span class="line">searchguard.authcz.admin_dn:</span><br><span class="line">  - CN=admin,OU=client, O=client, L=SZ, C=CN</span><br><span class="line"></span><br><span class="line"><span class="comment">#search-guard ssl</span></span><br><span class="line">searchguard.ssl.transport.keystore_filepath: node-&lt;your_node_name&gt;-keystore.jks</span><br><span class="line">searchguard.ssl.transport.keystore_password: your_KeyStore_password</span><br><span class="line">searchguard.ssl.transport.truststore_filepath: truststore.jks</span><br><span class="line">searchguard.ssl.transport.truststore_password: your_TrustStore_password</span><br><span class="line">searchguard.ssl.transport.enforce_hostname_verification: <span class="literal">false</span></span><br><span class="line"><span class="comment">#search-guard https</span></span><br><span class="line">searchguard.ssl.http.enabled: <span class="literal">true</span></span><br><span class="line">searchguard.ssl.http.keystore_filepath: node-&lt;your_node_name&gt;-keystore.jks</span><br><span class="line">searchguard.ssl.http.keystore_password: your_KeyStore_password</span><br><span class="line">searchguard.ssl.http.truststore_filepath: truststore.jks</span><br><span class="line">searchguard.ssl.http.truststore_password: your_TrustStore_password</span><br></pre></td></tr></table></figure></p>
<h3 id="search-guard权限设置"><a href="#search-guard权限设置" class="headerlink" title="search-guard权限设置"></a><strong>search-guard权限设置</strong></h3><p>&emsp;&emsp;search-guard的权限配置文件都在<strong><code>/usr/local/elasticsearch/plugins/search-guard-2/sgconfig</code></strong>目录下</p>
<ul>
<li><strong>sg_config.yml</strong><br>  主配置文件，定义认证类型等。一般不需要改动</li>
<li><strong>sg_internal_users.yml</strong><br>  本地用户文件，定义用户密码以及对应的权限(密码生成脚本：plugins/search-guard-2/tools/hash.sh)</li>
<li><strong>sg_roles_mapping.yml</strong><br>  定义角色(<code>sg_roles.yml</code>)和用户(<code>sg_internal_users.yml</code>)的映射关系</li>
<li><strong>sg_roles.yml</strong><br>  角色权限配置文件</li>
<li><strong>sg_action_groups.yml</strong><br>  定义权限别名，把多个单独的权限整合并配置别名，简化配置</li>
</ul>
<h4 id="创建用户及设置密码——sg-internal-users-yml"><a href="#创建用户及设置密码——sg-internal-users-yml" class="headerlink" title="创建用户及设置密码——sg_internal_users.yml"></a><strong>创建用户及设置密码——sg_internal_users.yml</strong></h4><p>&emsp;&emsp;创建具体的用户和密码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#管理员权限帐号</span></span><br><span class="line">admin:</span><br><span class="line">  <span class="built_in">hash</span>: <span class="variable">$2a</span><span class="variable">$12</span><span class="variable">$rVW6Elg3PUBTJIAXRZ881</span>.kWfG4OL/vTwX0ksJ8uUUGEC763J08SK</span><br><span class="line"></span><br><span class="line"><span class="comment">#kibana server帐号</span></span><br><span class="line"><span class="comment">#用于在kibana.yml中配置，该帐号用于创建和管理.kibana索引</span></span><br><span class="line">kibana_server:</span><br><span class="line">  <span class="built_in">hash</span>: <span class="variable">$2a</span><span class="variable">$12</span><span class="variable">$QrVeCyf7JFwq</span>/<span class="number">2.2</span>BjLP0O0g8C1hlHunoyxWFe57nlbJGHI/A/Wda</span><br><span class="line"></span><br><span class="line"><span class="comment">#kibana 登录帐号</span></span><br><span class="line">kibana_admin:</span><br><span class="line">  <span class="built_in">hash</span>: <span class="variable">$2a</span><span class="variable">$12</span>$.vAGeZm8FdFMIeDz8DlWqeWCO/Uiy12v6xJEbpGnhahSfSuPwbYOy</span><br><span class="line"></span><br><span class="line"><span class="comment">#logstash帐号</span></span><br><span class="line"><span class="comment">#用于在logstash中配置，允许logstash往Elasticsearch中写入数据</span></span><br><span class="line">logstash:</span><br><span class="line">  <span class="built_in">hash</span>: <span class="variable">$2a</span><span class="variable">$12</span><span class="variable">$zbVAUMH5thQvnCDKNfMLv</span>.QDsdFYdoiK3V70.tkC8tMVF8EvP0nf2</span><br></pre></td></tr></table></figure></p>
<h4 id="定义角色与用户映射关系——sg-roles-mapping-yml"><a href="#定义角色与用户映射关系——sg-roles-mapping-yml" class="headerlink" title="定义角色与用户映射关系——sg_roles_mapping.yml"></a><strong>定义角色与用户映射关系——sg_roles_mapping.yml</strong></h4><p>&emsp;&emsp;search-guard中的角色其实相当于用户组的概念，对角色(用户组)进行权限控制，用户加入角色(用户组)中，以此来管理权限。<br>&emsp;&emsp;用<code>sg_admin</code>角色(用户组)为例，<code>sg_admin</code>为管理员角色(用户组)，该角色(用户组)下有名为<code>admin</code>的用户。所以<code>admin</code>用户就拥有了管理员角色(组)的权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#管理员角色</span></span><br><span class="line">sg_admin:</span><br><span class="line">  users:</span><br><span class="line">    - admin</span><br><span class="line"></span><br><span class="line"><span class="comment">#kibana server帐号</span></span><br><span class="line">sg_kibana_server:</span><br><span class="line">  users:</span><br><span class="line">    - kibana_server</span><br><span class="line"></span><br><span class="line"><span class="comment">#kibana 登录帐号</span></span><br><span class="line">sg_kibana_admin:</span><br><span class="line">  users:</span><br><span class="line">    - kibana_admin</span><br><span class="line"></span><br><span class="line"><span class="comment">#logstash帐号</span></span><br><span class="line">sg_logstash:</span><br><span class="line">  users:</span><br><span class="line">    - logstash</span><br></pre></td></tr></table></figure></p>
<h4 id="定义角色-用户组-权限——sg-roles-yml"><a href="#定义角色-用户组-权限——sg-roles-yml" class="headerlink" title="定义角色(用户组)权限——sg_roles.yml"></a><strong>定义角色(用户组)权限——sg_roles.yml</strong></h4><p>&emsp;&emsp;定义不同角色(用户组)的角色有不同的权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#管理员角色</span></span><br><span class="line"><span class="comment">#拥有所有权限</span></span><br><span class="line">sg_admin:</span><br><span class="line">  cluster:</span><br><span class="line">    - <span class="string">'*'</span></span><br><span class="line">  indices:</span><br><span class="line">    <span class="string">'*'</span>:</span><br><span class="line">      <span class="string">'*'</span>:</span><br><span class="line">        - <span class="string">'*'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#kibana server角色</span></span><br><span class="line"><span class="comment">#对.kibana索引有所有权限，并且对集群有获取节点信息和健康状态的权限</span></span><br><span class="line">sg_kibana_server:</span><br><span class="line">  cluster:</span><br><span class="line">    - cluster:monitor/nodes/info</span><br><span class="line">    - cluster:monitor/health</span><br><span class="line">  indices:</span><br><span class="line">    <span class="string">'?kibana'</span>:</span><br><span class="line">      <span class="string">'*'</span>:</span><br><span class="line">        - ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">#kibana登录角色</span></span><br><span class="line">sg_kibana_admin:</span><br><span class="line">  indices:</span><br><span class="line">    <span class="string">'_all'</span>:</span><br><span class="line">      <span class="string">'*'</span>:</span><br><span class="line">        - indices:data/<span class="built_in">read</span>/mget*</span><br><span class="line">        - indices:data/<span class="built_in">read</span>/get*</span><br><span class="line">        - indices:data/<span class="built_in">read</span>/search*</span><br><span class="line">        - indices:data/<span class="built_in">read</span>/msearch*</span><br><span class="line">    <span class="string">'logstash-*'</span>:</span><br><span class="line">      <span class="string">'*'</span>:</span><br><span class="line">        - ALL</span><br><span class="line">    <span class="string">'?kibana'</span>:</span><br><span class="line">      <span class="string">'*'</span>:</span><br><span class="line">        - ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">#logstash角色</span></span><br><span class="line"><span class="comment">#对Elasticsearch有创建索引和写入的权限</span></span><br><span class="line">sg_logstash:</span><br><span class="line">  cluster:</span><br><span class="line">    - indices:admin/template/get</span><br><span class="line">    - indices:admin/template/put</span><br><span class="line">  indices:</span><br><span class="line">    <span class="string">'*'</span>:</span><br><span class="line">      <span class="string">'*'</span>:</span><br><span class="line">        - WRITE</span><br><span class="line">        - CREATE_INDEX</span><br><span class="line">        - indices:data/<span class="built_in">read</span>/search</span><br><span class="line">        - indices:data/<span class="built_in">read</span>/scroll</span><br></pre></td></tr></table></figure></p>
<h4 id="定制权限别名——sg-action-groups-yml"><a href="#定制权限别名——sg-action-groups-yml" class="headerlink" title="定制权限别名——sg_action_groups.yml"></a><strong>定制权限别名——sg_action_groups.yml</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ALL:</span><br><span class="line">  - <span class="string">"indices:*"</span></span><br><span class="line">CREATE_INDEX:</span><br><span class="line">  - <span class="string">"indices:admin/create"</span></span><br><span class="line">WRITE:</span><br><span class="line">  - <span class="string">"indices:data/write*"</span></span><br><span class="line">READ:</span><br><span class="line">  - <span class="string">"indices:data/read*"</span></span><br><span class="line">DELETE:</span><br><span class="line">  - <span class="string">"indices:data/write/delete*"</span></span><br><span class="line">CRUD:</span><br><span class="line">  - READ</span><br><span class="line">  - WRITE</span><br></pre></td></tr></table></figure>
<h3 id="启动Elasticsearch集群"><a href="#启动Elasticsearch集群" class="headerlink" title="启动Elasticsearch集群"></a><strong>启动Elasticsearch集群</strong></h3><p>&emsp;&emsp;将证书都拷贝到集群所有节点，ES配置文件都新增相关配置后就可启动集群<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/elasticsearch/bin/elasticsearch <span class="operator">-d</span></span><br></pre></td></tr></table></figure></p>
<h3 id="search-guard初始化"><a href="#search-guard初始化" class="headerlink" title="search-guard初始化"></a><strong>search-guard初始化</strong></h3><p>&emsp;&emsp;Elasticsearch所有节点启动完成后需要对search-guard进行初始化，生成<code>searchguard</code>索引。search-guard根据权限配置文件将数据写入到<code>searchguard</code>索引中，当权限设置变更时，只需要重新初始化<code>searchguard</code>索引即可，不需要重启集群。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/elasticsearch/</span><br><span class="line">plugins/search-guard-<span class="number">2</span>/tools/sgadmin.sh -cd plugins/search-guard-<span class="number">2</span>/sgconfig/ -ks plugins/search-guard-<span class="number">2</span>/sgconfig/admin-keystore.jks -ts plugins/search-guard-<span class="number">2</span>/sgconfig/truststore.jks -tspass &lt;your_TrustStore_password&gt; -kspass &lt;your_KeyStore_password&gt; -icl -nhnv</span><br></pre></td></tr></table></figure></p>
<h4 id="设置searchguard索引自动分片"><a href="#设置searchguard索引自动分片" class="headerlink" title="设置searchguard索引自动分片"></a><strong>设置searchguard索引自动分片</strong></h4><p>&emsp;&emsp;初始化后生成的<code>searchguard</code>索引是不会随着集群节点增加而自动增加分片的，需要设置<code>searchguard</code>索引成自动分片。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/elasticsearch/</span><br><span class="line">plugins/search-guard-<span class="number">2</span>/tools/sgadmin.sh -cd plugins/search-guard-<span class="number">2</span>/sgconfig/ -ks plugins/search-guard-<span class="number">2</span>/sgconfig/admin-keystore.jks -ts plugins/search-guard-<span class="number">2</span>/sgconfig/truststore.jks -tspass &lt;your_TrustStore_password&gt; -kspass &lt;your_KeyStore_password&gt; -icl -era</span><br></pre></td></tr></table></figure></p>
<h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a><strong>Kibana</strong></h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf kibana-<span class="number">4.6</span><span class="number">.4</span>-linux-x86_64.tar.gz</span><br><span class="line">mv kibana-<span class="number">4.6</span><span class="number">.4</span>-linux-x86_64 /usr/local/kibana</span><br><span class="line">useradd kibana</span><br><span class="line">chown -R kibana:kibana /usr/local/kibana/</span><br></pre></td></tr></table></figure>
<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a><strong>配置</strong></h3><p><strong>/usr/local/kibana/config/kibana.yml</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server<span class="class">.port</span>: <span class="number">5601</span></span><br><span class="line">server<span class="class">.host</span>: <span class="string">"0.0.0.0"</span></span><br><span class="line">elasticsearch<span class="class">.url</span>: <span class="string">"https://localhost:9200"</span></span><br><span class="line">kibana<span class="class">.index</span>: <span class="string">".kibana"</span></span><br><span class="line">elasticsearch<span class="class">.username</span>: <span class="string">"kibana_server"</span></span><br><span class="line">elasticsearch<span class="class">.password</span>: <span class="string">"kibana"</span></span><br><span class="line">elasticsearch<span class="class">.ssl</span><span class="class">.ca</span>: /usr/local/kibana/root-ca<span class="class">.pem</span></span><br><span class="line">elasticsearch<span class="class">.ssl</span><span class="class">.verify</span>: false</span><br></pre></td></tr></table></figure></p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a><strong>访问</strong></h3><p><a href="http://kibana_server_ip:5601" target="_blank" rel="external">http://kibana_server_ip:5601</a><br>输入不同用户及密码会根据用户做权限的控制</p>
<h2 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a><strong>Logstash</strong></h2><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf logstash-<span class="number">2.4</span><span class="number">.1</span>.tar.gz</span><br><span class="line">mv logstash-<span class="number">2.4</span><span class="number">.1</span> <span class="regexp">/usr/</span>local/logstash</span><br><span class="line">chown -R <span class="string">osadmin:</span>osadmin <span class="regexp">/usr/</span>local<span class="regexp">/logstash/</span></span><br><span class="line">mkdir <span class="regexp">/usr/</span>local<span class="regexp">/logstash/</span>config</span><br></pre></td></tr></table></figure>
<h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a><strong>配置</strong></h3><p>Logstash使用<strong>grok正则表达式</strong>对日志进行匹配并json化后存入Elasticsearch<br><a href="https://grokdebug.herokuapp.com/" target="_blank" rel="external">grok正则在线测试</a></p>
<h4 id="Logstash采集Nginx"><a href="#Logstash采集Nginx" class="headerlink" title="Logstash采集Nginx"></a><strong>Logstash采集Nginx</strong></h4><ul>
<li><p>客户端配置<br>  &emsp;采集的客户端用的是<strong>filebeat</strong>，直接通过rpm安装。<br>  &emsp;/etc/filebeat/filebeat.yml</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line">- input_<span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /usr/<span class="built_in">local</span>/nginx/logs/access.log</span><br><span class="line">  <span class="comment">#multiline:</span></span><br><span class="line">  <span class="comment">#  pattern: '^(20[0-9]&#123;2&#125;(-[0-9]&#123;2&#125;)&#123;2&#125; [0-9]&#123;2&#125;(:[0-9]&#123;2&#125;)&#123;2&#125;)'</span></span><br><span class="line">  <span class="comment">#  negate: true</span></span><br><span class="line">  <span class="comment">#  match: after</span></span><br><span class="line"></span><br><span class="line">output.kafka:</span><br><span class="line">  hosts: [<span class="string">"10.201.5.30:9092"</span>, <span class="string">"10.201.5.31:9092"</span>]</span><br><span class="line">  topic: <span class="string">'nginx'</span></span><br><span class="line">  partition.round_robin:</span><br><span class="line">    reachable_only: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  required_acks: <span class="number">1</span></span><br><span class="line">  compression: gzip</span><br><span class="line">  max_message_bytes: <span class="number">1000000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端配置<br>  /usr/local/logstash/config/logstash.conf<br>  <code>root-ca.pem</code>是使用search-guard-ssl生成的证书原路径——<code>search-guard-ssl/example-pki-scripts/ca/root-ca.pem</code></p>
  <figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">input</span> &#123;</span><br><span class="line">	kafka &#123;</span><br><span class="line">		zk_connect =&gt; <span class="string">"10.201.3.33:2181,10.201.3.30:2181"</span></span><br><span class="line">		topic_id =&gt; <span class="string">"nginx"</span></span><br><span class="line">		codec =&gt; json</span><br><span class="line">		reset_beginning =&gt; <span class="keyword">false</span></span><br><span class="line">		consumer_threads =&gt; <span class="number">5</span></span><br><span class="line">		decorate_events =&gt; <span class="keyword">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="name">filter</span> &#123;</span><br><span class="line">	grok &#123;</span><br><span class="line">		patterns_dir =&gt; [<span class="string">"/usr/local/logstash/patterns"</span>]</span><br><span class="line">		match =&gt; [<span class="string">"message"</span>, <span class="string">"%&#123;NGINXACCESS&#125;"</span>]</span><br><span class="line">		overwrite =&gt; [<span class="string">"message"</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="name">geoip</span> &#123;</span><br><span class="line">		source =&gt; <span class="string">"xforward"</span></span><br><span class="line">		target =&gt; <span class="string">"geoip"</span></span><br><span class="line">		database =&gt; <span class="string">"/usr/local/logstash/maps/GeoLiteCity.dat"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="name">output</span> &#123;</span><br><span class="line">      elasticsearch &#123;</span><br><span class="line">         user =&gt; logstash</span><br><span class="line">         password =&gt; logstash</span><br><span class="line">         ssl =&gt; <span class="keyword">true</span></span><br><span class="line">         ssl_certificate_verification =&gt; <span class="keyword">false</span></span><br><span class="line">         cacert =&gt; <span class="string">"/usr/local/logstash/config/root-ca.pem"</span></span><br><span class="line">         hosts =&gt; [<span class="string">"10.201.3.49:9200"</span>,<span class="string">"10.201.3.33:9200"</span>,<span class="string">"10.201.3.30:9200"</span>]</span><br><span class="line">         index =&gt; <span class="string">"nginx-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>grok正则<br>  /usr/local/logstash/patterns/nginx</p>
  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NGINXACCESS %&#123;<span class="string">IP:</span>ip&#125; \- \- \[%&#123;<span class="string">HTTPDATE:</span>timestamp&#125;\] <span class="string">"%&#123;WORD:method&#125; %&#123;URIPATHPARAM:uri&#125; HTTP/%&#123;NUMBER:httpversion&#125;"</span> %&#123;<span class="string">NUMBER:</span>status&#125; %&#123;<span class="string">NUMBER:</span>bytes&#125; %&#123;<span class="string">QS:</span>referer&#125; %&#123;<span class="string">QS:</span>agent&#125; \<span class="string">"(?:-|%&#123;IP:xforward&#125;[%&#123;IP&#125;\, ]*)\" "</span>%&#123;<span class="string">NUMBER:</span><span class="string">request_time:</span><span class="typename">float</span>&#125; %&#123;<span class="string">NUMBER:</span>request_length&#125; %&#123;<span class="string">NUMBER:</span>connection_requests&#125;<span class="string">" %&#123;QS:other&#125;</span></span><br></pre></td></tr></table></figure>
<p>  Nginx日志格式</p>
  <figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  '<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] <span class="string">"<span class="variable">$request</span>"</span> '</span><br><span class="line">                     '<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> <span class="string">"<span class="variable">$http_referer</span>"</span> '</span><br><span class="line">                     '<span class="string">"<span class="variable">$http_user_agent</span>"</span> <span class="string">"<span class="variable">$http_x_forwarded_for</span>"</span> <span class="string">"<span class="variable">$request_time</span> <span class="variable">$request_length</span> <span class="variable">$connection_requests</span>"</span> <span class="string">"<span class="variable">$http_syncsession</span>| <span class="variable">$http_sessionkey</span>| <span class="variable">$http_cookie</span>| <span class="variable">$http_accept</span>| <span class="variable">$http_content_length</span>| <span class="variable">$http_x_forwarded_proto</span>"</span>'<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a><strong>启动</strong></h4><p>测试Logstash配置文件是否正确<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/logstash/</span>bin<span class="regexp">/logstash -f /u</span>sr<span class="regexp">/local/</span>logstash<span class="regexp">/config/</span>logstash.conf --configtest --verbose</span><br></pre></td></tr></table></figure></p>
<p>启动Logstash(尽量使用Supervisord管理)<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/logstash/</span>bin<span class="regexp">/logstash -f /u</span>sr<span class="regexp">/local/</span>logstash<span class="regexp">/config/</span>logstash.conf</span><br></pre></td></tr></table></figure></p>
<h2 id="Sentinl"><a href="#Sentinl" class="headerlink" title="Sentinl"></a><strong>Sentinl</strong></h2><p>&emsp;&emsp;Sentinl是一个开源的Kibana插件，用于监控报警和报告，可弥补ELK缺乏报警的功能。<a href="https://github.com/sirensolutions/sentinl" target="_blank" rel="external">Sentinl项目地址</a></p>
<h3 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/kibana/</span><br><span class="line">bin/kibana plugin --install sentinl -u https://github.com/sirensolutions/sentinl/releases/download/snapshot/sentinl-latest.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="search-guard权限设置-1"><a href="#search-guard权限设置-1" class="headerlink" title="search-guard权限设置"></a><strong>search-guard权限设置</strong></h3><p>&emsp;&emsp;Sentinl需要查询Elasticsearch的数据，所以需要给<code>kibana.yml</code>中的用户相应的权限<br>&emsp;&emsp;<strong>sg_roles.yml</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sg_kibana_server:</span><br><span class="line">  cluster:</span><br><span class="line">    - cluster:monitor/nodes/info</span><br><span class="line">    - cluster:monitor/health</span><br><span class="line">  indices:</span><br><span class="line">    <span class="string">'?kibana'</span>:</span><br><span class="line">      <span class="string">'*'</span>:</span><br><span class="line">        - ALL</span><br><span class="line">    <span class="string">'watcher*'</span>:</span><br><span class="line">      <span class="string">'*'</span>:</span><br><span class="line">        - ALL</span><br><span class="line">    <span class="string">'*'</span>:</span><br><span class="line">      <span class="string">'*'</span>:</span><br><span class="line">        - indices:data/<span class="built_in">read</span>/search*</span><br></pre></td></tr></table></figure></p>
<h3 id="kibana设置"><a href="#kibana设置" class="headerlink" title="kibana设置"></a><strong>kibana设置</strong></h3><p>&emsp;&emsp;需要在<code>kibana.yml</code>中设置发邮帐号和监控相对应的Elasticsearch索引。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sentinl:</span><br><span class="line"> es:</span><br><span class="line">   timefield: <span class="string">'@timestamp'</span></span><br><span class="line">   default_index: watcher</span><br><span class="line">   <span class="built_in">type</span>: watch</span><br><span class="line">   alarm_index: watcher_alarms</span><br><span class="line"> sentinl:</span><br><span class="line">   <span class="built_in">history</span>: <span class="number">20</span></span><br><span class="line">   results: <span class="number">50</span></span><br><span class="line"> settings:</span><br><span class="line">   email:</span><br><span class="line">     active: <span class="literal">true</span></span><br><span class="line">     user: <span class="built_in">test</span>@<span class="number">163</span>.com</span><br><span class="line">     password: &lt;password&gt;</span><br><span class="line">     host: smtp.<span class="number">163</span>.com</span><br><span class="line">     ssl: <span class="literal">true</span></span><br><span class="line">   report:</span><br><span class="line">     active: <span class="literal">true</span></span><br><span class="line">     tmp_path: /tmp/</span><br></pre></td></tr></table></figure></p>
<h3 id="配置Watch监控"><a href="#配置Watch监控" class="headerlink" title="配置Watch监控"></a><strong>配置Watch监控</strong></h3><p>&emsp;&emsp;登录Kibana后进入Sentinl点击Watch创建监控规则。规则中的<code>email from</code>需要和<code>kibana.yml</code>中邮箱的<code>user</code>一致。<br>&emsp;&emsp;下面这个示例是5分钟内<code>nginx-</code>索引日志中<code>status</code>http状态码为<code>502</code>的记录出现超过<code>3</code>次则报警<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span>: <span class="string">"watcher"</span>,</span><br><span class="line">  <span class="string">"_type"</span>: <span class="string">"watch"</span>,</span><br><span class="line">  <span class="string">"_id"</span>: <span class="string">"ops_1"</span>,</span><br><span class="line">  <span class="string">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"_source"</span>: &#123;</span><br><span class="line">    <span class="string">"disable"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"uuid"</span>: <span class="string">"ops_1"</span>,</span><br><span class="line">    <span class="string">"trigger"</span>: &#123;</span><br><span class="line">      <span class="string">"schedule"</span>: &#123;</span><br><span class="line">        <span class="string">"later"</span>: <span class="string">"every 5 minutes"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"input"</span>: &#123;</span><br><span class="line">      <span class="string">"search"</span>: &#123;</span><br><span class="line">        <span class="string">"request"</span>: &#123;</span><br><span class="line">          <span class="string">"index"</span>: [</span><br><span class="line">            <span class="string">"&lt;nginx-&#123;now/d&#125;&gt;"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="string">"body"</span>: &#123;</span><br><span class="line">            <span class="string">"size"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"query"</span>: &#123;</span><br><span class="line">              <span class="string">"bool"</span>: &#123;</span><br><span class="line">                <span class="string">"must"</span>: &#123;</span><br><span class="line">                  <span class="string">"match"</span>: &#123;</span><br><span class="line">                    <span class="string">"status"</span>: <span class="string">"502"</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"filter"</span>: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="string">"range"</span>: &#123;</span><br><span class="line">                      <span class="string">"@timestamp"</span>: &#123;</span><br><span class="line">                        <span class="string">"gt"</span>: <span class="string">"now-5m"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"condition"</span>: &#123;</span><br><span class="line">      <span class="string">"script"</span>: &#123;</span><br><span class="line">        <span class="string">"script"</span>: <span class="string">"payload.hits.total &gt; 3"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"transform"</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">"actions"</span>: &#123;</span><br><span class="line">      <span class="string">"email_admin"</span>: &#123;</span><br><span class="line">        <span class="string">"throttle_period"</span>: <span class="string">"5m"</span>,</span><br><span class="line">        <span class="string">"email"</span>: &#123;</span><br><span class="line">          <span class="string">"to"</span>: <span class="string">"admin@gmail.com"</span>,</span><br><span class="line">          <span class="string">"from"</span>: <span class="string">"test@163.com"</span>,</span><br><span class="line">          <span class="string">"subject"</span>: <span class="string">"Sentinl Alarm"</span>,</span><br><span class="line">          <span class="string">"priority"</span>: <span class="string">"high"</span>,</span><br><span class="line">          <span class="string">"body"</span>: <span class="string">"Found &#123;&#123;payload.hits.total&#125;&#125; 502 Events"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Supervisord"><a href="#Supervisord" class="headerlink" title="Supervisord"></a><strong>Supervisord</strong></h2><p>&emsp;&emsp;使用Supervisord来管理Logstash、Zookeeper和Kafka的启动/停止</p>
<h3 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> -U setuptools</span><br><span class="line">pip <span class="keyword">install</span> supervisor</span><br></pre></td></tr></table></figure>
<h3 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a><strong>配置</strong></h3><p>生成模板配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span>_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure></p>
<h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a><strong>启动</strong></h3><ul>
<li><p>启动Supervisor</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord</span><br></pre></td></tr></table></figure>
</li>
<li><p>supervisorctl<br>  通过supervisorctl控制程序的启动，也可以通过Web界面管理<strong><a href="http://supervisor_server_ip:9001" target="_blank" rel="external">http://supervisor_server_ip:9001</a></strong></p>
  <figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl  [start|<span class="string">stop</span>|<span class="string">restart</span>|<span class="string">reread</span>|<span class="string">update] program_name</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;&emsp;ELK(Elasticsearch/Logstash/Kibana)是目前对日志采集分析比较适合的解决方案；Kafka是一个分布式高可用高吞吐的消息队列软件，在日志量大及对数据可靠性要求高的场景使用；Search-Guard是一款开源的、对Elast]]>
    </summary>
    
      <category term="ELK" scheme="http://yoursite.com/tags/ELK/"/>
    
      <category term="OPS" scheme="http://yoursite.com/categories/OPS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《深入理解Linux内核》读书笔记]]></title>
    <link href="http://yoursite.com/2017/02/02/linux-kernel-note/"/>
    <id>http://yoursite.com/2017/02/02/linux-kernel-note/</id>
    <published>2017-02-02T04:42:40.000Z</published>
    <updated>2019-03-31T04:51:05.873Z</updated>
    <content type="html"><![CDATA[<p><span id="introduction"></span></p>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a><strong>绪论</strong></h2><h3 id="Unix文件系统概述"><a href="#Unix文件系统概述" class="headerlink" title="Unix文件系统概述"></a><strong>Unix文件系统概述</strong></h3><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a><strong>文件</strong></h4><p>&emsp;&emsp;Unix文件是以字节序列组成的信息载体，文件被组织在一个<strong>树结构</strong>的命名空间中。除叶节点外，树的所有节点表示目录名。<strong>目录节点包含其下的文件及目录的所有信息。</strong><br>&emsp;&emsp;Unix的进程都有一个当前目录，当前目录属于进程<strong>执行上下文(execution context)</strong>，标识进程所在的当前目录。进程使用<strong>路径名(pathname)</strong>标识某个特定文件，路径名由斜杠及一系列指向文件的目录名交替组成。若路径名的第一个字符为’/‘，则此路径为<strong>绝对路径</strong>；若第一项为目录名或文件名，则此路径为<strong>相对路径</strong>，<strong><code>.</code></strong>标识当前目录、<strong><code>..</code></strong>标识父目录。</p>
<h4 id="软链接-amp-硬链接"><a href="#软链接-amp-硬链接" class="headerlink" title="软链接 &amp; 硬链接"></a><strong>软链接 &amp; 硬链接</strong></h4><p>&emsp;&emsp;使用<strong><code>ln</code></strong>命令为由路径<code>P1</code>标识的文件创建一个名为<code>P2</code>的硬链接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ln P1 P2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;硬链接有2个限制：</p>
<ol>
<li>不能为目录创建硬链接</li>
<li>只能在同一文件系统中创建硬链接</li>
</ol>
<p>&emsp;&emsp;软链接又可称之为符号链接。路径名可指向位于任意文件系统的任意文件或目录，甚至<strong>可指向一个不存在的文件</strong>(硬链接只能对已存在的文件进行创建)。同样使用<strong><code>ln</code></strong>命令创建软链接<br>&emsp;&emsp;创建一个名为<code>P2</code>的软链接并指向路径名<code>P1</code>，任何对<code>P2</code>的操作都会自动转换到<code>P1</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ln <span class="operator">-s</span> P1 P2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;硬链接是有着与原文件<strong>相同inode号</strong>仅文件名不同的文件，而软链接是拥有属于自己的inode号的，软链接的数据块内容存放着指向原文件的路径。</p>
<h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a><strong>文件类型</strong></h4><p>&emsp;&emsp;Unix文件类型包括如下：</p>
<ul>
<li>普通文件</li>
<li>目录</li>
<li>软链接(符号链接)</li>
<li>块设备文件</li>
<li>字符设备文件</li>
<li>管道、命名管道</li>
<li>套接字(socket)</li>
</ul>
<h4 id="文件描述符-fd-amp-索引节点-inode"><a href="#文件描述符-fd-amp-索引节点-inode" class="headerlink" title="文件描述符(fd) &amp; 索引节点(inode)"></a><strong>文件描述符(fd) &amp; 索引节点(inode)</strong></h4><p>&emsp;&emsp;除设备文件和特殊文件系统文件外，Unix文件都由字符序列组成。Unix对文件的内容和描述文件的信息加以区分，文件内容不包含控制信息(文件长度、文件结束符等)。<br>&emsp;&emsp;文件系统处理文件所需的控制信息都包含在<strong>索引节点</strong>(<strong>inode</strong>)中。每个文件都有自己的索引节点，文件系统用索引节点标识文件。<br>&emsp;&emsp;索引节点(inode)包含如下属性：</p>
<ul>
<li>文件类型</li>
<li>与文件相关的硬链接个数</li>
<li>以字节为单位的文件长度</li>
<li>设备标识符</li>
<li>文件系统中标识文件的索引节点号</li>
<li>文件拥有者ID</li>
<li>文件的组ID</li>
<li>时间戳(改变时间、最后访问时间、最后修改时间)</li>
<li>访问权限及文件模式</li>
</ul>
<h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a><strong>访问权限</strong></h4><p>&emsp;&emsp;文件的潜在用户分三类：</p>
<ul>
<li>文件拥有者(<strong><code>u</code></strong>ser)</li>
<li>同组用户，不包括拥有者(<strong><code>g</code></strong>roup)</li>
<li>所有剩下的用户(<strong><code>o</code></strong>ther)</li>
</ul>
<p>&emsp;&emsp;访问权限有三种：读、写和可执行。因此文件访问权限的组合有九种不同的二进制标记。除此之外，还有三种附加标记——<strong><code>suid</code></strong>、<strong><code>sgid</code></strong>和<strong><code>sticky</code></strong>用于定义文件模式。</p>
<ul>
<li><code>suid</code>：进程执行文件时保持文件拥有者的UID。</li>
<li><code>sgid</code>：进程执行文件时保持用户组的GID。</li>
<li><code>sticky</code>：向内核发出请求，当程序结束后依然将其保存在内存中(此标志已过时)。</li>
</ul>
<h3 id="Unix内核概述"><a href="#Unix内核概述" class="headerlink" title="Unix内核概述"></a><strong>Unix内核概述</strong></h3><h4 id="进程-内核模式"><a href="#进程-内核模式" class="headerlink" title="进程/内核模式"></a><strong>进程/内核模式</strong></h4><p>&emsp;&emsp;CPU可运行在用户态下，也可运行在内核态下。尽管CPU会拥有不同的执行状态，但标准的Unix内核仅用到<strong>用户态</strong>和<strong>内核态</strong>。<br>&emsp;&emsp;一个程序在执行时，大部分时间处于用户态下，只有需要内核所提供的服务时才切换到内核态，程序在用户态下不能直接访问内核数据结构和内核程序。当内核满足用户程序请求后，内核会让程序重新回到用户态。<br>&emsp;&emsp;请求内核服务的进程使用<strong>系统调用(system call)</strong>的特殊编程机制完成从用户态到内核态的转换(系统调用只是其中的一种方式)。每个系统调用都设置一组识别进程请求的参数，进程调用后执行与硬件相关的CPU指令。<br>&emsp;&emsp;除用户进程外，Unix系统还有几个<strong>内核线程(kernel thread)</strong>的<strong>特权进程</strong>，特权进程有如下特点：</p>
<ul>
<li>以内核态运行在内核地址空间中</li>
<li>不与用户直接交互、不需要终端设备</li>
<li>在系统启动时创建，一直处于活跃状态直到系统关闭</li>
</ul>
<h4 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a><strong>进程实现</strong></h4><p>&emsp;&emsp;为了内核能管理进程，每个进程由<strong>进程描述符(process descriptor)</strong>表示，进程描述符包含有关进程当前状态的信息。<br>&emsp;&emsp;当内核需要暂停一个正在执行中的进程时，会把相关处理器寄存器的内容保存到进程描述符中，这些寄存器包括：</p>
<ul>
<li>程序计数器(PC)和栈指针(SP)寄存器</li>
<li>通用寄存器</li>
<li>浮点寄存器</li>
<li>包含CPU状态信息的处理器控制寄存器</li>
<li>用来跟踪进程对RAM访问的内存管理寄存器</li>
</ul>
<p>&emsp;&emsp;当内核需要恢复一个进程时，会用进程描述符中合适的字段来装载寄存器。<br>&emsp;&emsp;当进程不在CPU上执行时，那正在等待事件。内核可区分多种等待状态，这些等待状态由进程描述符队列实现，每个队列对应一组正在等待某事件的进程。</p>
<h4 id="可重入内核"><a href="#可重入内核" class="headerlink" title="可重入内核"></a><strong>可重入内核</strong></h4><p>&emsp;&emsp;所有Unix内核都是<strong>可重入的(reentrant)</strong>，可重入意味着多个进程可同时在内核态下执行。<br>&emsp;&emsp;提供可重入的其中一种方式是编写可重入函数，可重入函数只能修改局部变量而不能修改全局变量。对于非重入函数，可利用锁机制保证一次只有一个进程执行一个非重入函数。<br>&emsp;&emsp;进程即使处于内核态，当一个硬件中断产生时，可重入内核也能将正在执行的进程挂起。产生硬件中断的设备控制器能快速的收到内核的应答，设备控制器在CPU处理中断时能执行其他任务，这样能提高设备控制器的吞吐量。<br>&emsp;&emsp;为了说明可重入性对内核组织的影响。引入<strong>内核控制路径(kernel control path)</strong>概念，内核控制路径表示内核处理系统调用、异常或中断所执行的指令序列。<br>&emsp;&emsp;最简单的情况下，CPU从第一条指令到最后一条指令顺序执行内核控制路径。但当以下事件之一发生时，CPU交错执行内核控制路径：</p>
<ul>
<li>用户态下的进程调用一个系统调用，相应的内核控制路径确定这个请求无法立即满足。于是，内核控制路径调用调度程序选择一个新的进程执行。因此发生进程切换。第一个内核控制路径没完成，CPU便开始执行其他的内核控制路径。此情况下，两条控制路径代表两个不同的进程在执行。</li>
<li>当正在执行一个内核控制路径时，CPU检测到一个异常，第一个控制路径被挂起而CPU开始执行合适的过程。</li>
<li>当CPU正在运行一个启用了中断的内核控制路径时，一个硬件中断产生。第一个内核控制路径还未执行完，CPU开始执行另一个内核控制路径来处理中断，中断处理完后第一个内核控制路径恢复。</li>
<li>在支持抢占式调度的内核中，若一个更高优先级的进程进入调度队列，则CPU会中断第一个执行控制路径，优先响应更高优先级的进程。</li>
</ul>
<h4 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a><strong>进程地址空间</strong></h4><p>&emsp;&emsp;每个进程都运行在属于自己的私有地址空间中，地址空间的最大长度和物理内存无关，所以称之为<strong>虚拟地址空间</strong>。Linux将地址空间根据用户态和内核态不同分为<strong>用户空间</strong>和<strong>内核空间</strong>。用户态下进程的地址空间在用户空间中，涉及<strong>私有栈</strong>、<strong>数据区</strong>和<strong>代码区</strong>，但进入内核态则使用内核空间的数据区和代码区。<br>&emsp;&emsp;虽说进程访问的是私有地址空间，但进程间也能共享部分地址空间，比如在实现进程间通信时，其中一种方式称为<strong>共享内存</strong>，是通过共享部分地址空间从而实现进程间通信的。<br>&emsp;&emsp;Linux的<strong><code>mmap()</code></strong>系统调用允许<strong>块设备</strong>的文件映射到进程的地址空间中，若一个文件由多个进程共享，那么这些进程的地址空间都包含该文件的内存映射。</p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a><strong>进程间通信</strong></h4><p>&emsp;&emsp;目前Linux系统中进程间通信主要的方式有以下几种：</p>
<ul>
<li>管道(pipe)和命名管道(FIFO)</li>
<li>信号(signal)</li>
<li>消息队列</li>
<li>共享内存</li>
<li>套接字(socket)</li>
</ul>
<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a><strong>进程管理</strong></h4><p>&emsp;&emsp;Linux系统是通过调用<strong><code>fork()</code></strong>创建新进程的。<strong><code>fork()</code></strong>会创建一个与父进程<strong>完全相同</strong>的子进程，子进程被创建后继续执行<code>fork()</code>后面的代码。为了效率考虑Linux系统使用<strong>Copy-On-Write</strong>机制，简单的说就是<code>fork()</code>后的父子进程都使用相同的物理内存区域，子进程的代码区、数据区和堆栈区等都指向父进程(父子进程的虚拟地址空间是不同的)，只有当父或子进程需要进行写入时才为子进程分配数据区、堆栈区(代码区(<code>exec()</code>))并复制父进程的内容给子进程。</p>
<ul>
<li><strong>僵尸进程(zombie process)</strong><br>  &emsp;&emsp;Linux中是通过父进程调用<code>fork()</code>创建出新的子进程，当子进程执行完毕调用<code>exit()</code>结束自己释放绝大多数资源后，子进程并非立即就在系统中消失而是会留下部分信息(<code>PID</code>、<code>退出状态</code>、<code>CPU使用时间</code>等)并在进程列表中保留位置(即占用一个PID)，直到父进程调用<code>wait()/waitpid()</code>收集完子进程残留的信息后才会使子进程彻底从系统中消失。子进程调用<code>exit()</code>到父进程调用<code>wait()/waitpid()</code>之间所处于的状态称其为<strong>僵尸进程</strong>。<br>  &emsp;&emsp;僵尸进程是不能通过<code>kill</code>命令让其消失的，因为僵尸进程已经<code>exit()</code>退出了只是还残留信息等待被父进程收集而已。假若父进程中没有写<code>wait()/waitpid()</code>操作或父进程忙于执行其他任务无法执行<code>wait()/waitpid()</code>，那么系统中可能会出现很多僵尸进程(僵尸进程占用PID，系统PID资源也是有限的)。其中一个办法是之间杀死父进程，让子进程变成<strong>孤儿进程</strong>由<strong><code>init进程</code></strong>接管并收集残留信息使僵尸进程消失。</li>
<li><strong>进程组(process group) &amp; 登录会话(login session)</strong><ul>
<li><strong>进程组(process group)</strong><br>  &emsp;&emsp;Linux操作系统引入<strong>进程组(process group)</strong>是为了能对更方便的管理多个进程，若将信号(signal)发送给一个进程组则<strong>该进程组的所有进程都会收到该信号</strong>。<br>  &emsp;&emsp;每个进程组会有一个<strong>进程组组长(process group leader)</strong>，<strong>组长进程(group leader)的<code>PID</code>会成为进程组ID(process group ID, <code>PGID</code>)</strong>。新创建的进程会被加入到其父进程的进程组中。<br>  &emsp;&emsp;<strong>进程组(process group)的存在和组长进程(group leader)是否存在无关</strong>，只要进程组(process group)中有一个进程存在则进程组(process group)就存在。只有当进程组(process group)内所有进程都退出进程组(process group)才会消失。</li>
<li><strong>登录会话(login session)</strong><br>  &emsp;&emsp;Linux系统也引入了<strong>登录会话(login session)</strong>，一个或多个进程组(process group)组成一个登录会话(login session)。会话由其中的某个进程建立，该进程称为<strong>会话首进程(session leader)</strong>。会话首进程(session leader)的<code>PID</code>成为会话ID<code>session ID, SID</code>。若会话首进程(session leader)退出，内核将发送<code>SIGHUP</code>信号给前台进程组。<br>  &emsp;&emsp;一个登录会话(login session)可让多个进程组(process group)处于活动状态，但只能有<strong>一个</strong>进程组(process group)处于前台(foreground)，其他进程组都是后台(background)。前台进程组可以访问终端，后台进程组试图访问终端时会收到<code>SIGTTIN</code>/<code>SIGTTOUT</code>信号。可使用<code>bg</code>和<code>fg</code>将一个进程组放到后台或前台。</li>
</ul>
</li>
</ul>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h4><ul>
<li><p><strong>虚拟内存</strong><br>  &emsp;&emsp;在内存管理上，Linux系统引入<strong>虚拟内存(virtual memory)</strong>这个抽象的逻辑层。虚拟内存(virtual memory)是处于<em>应用程序内存申请</em>和<em>硬件内存管理单元(Memory Management Unit, <code>MMU</code>)</em>之间。<br>  &emsp;&emsp;虚拟内存(virtual memory)的用途和优点：</p>
<ul>
<li>支持多进程并行执行</li>
<li>程序所需内存大于实际物理内存是也可运行(Linux有<code>overcommit</code>机制)</li>
<li>程序只有部分代码载入内存时进程可执行程序</li>
<li>允许每个进程访问可用物理内存的子集</li>
<li>进程可以共享函数库或程序的一个单独内存映象</li>
<li>程序是可重定位的，可以把程序放在物理内存的任何地方</li>
<li>程序员可以编写机器无关代码，无需关系物理内存的组织结构<br>&emsp;&emsp;虚拟内存子系统中最重要的概念是<strong>虚拟地址空间(virtual address space)</strong>，进程所使用的内存地址并非物理内存地址而是<strong>虚拟地址</strong>。虚拟地址由内核和<code>MMU</code>协同定位出其在内存中的物理地址。<br>&emsp;&emsp;现在的CPU有能自动把虚拟地址转换成物理地址的硬件电路，使得可以将<code>RAM</code>划分成长度为<code>4K</code>或<code>8K</code>的<strong>页框(page frame)</strong>并引入一组<strong>页表</strong>来指定虚拟地址和物理地址的关系。</li>
</ul>
</li>
<li><p><strong>随机访问存储器RAM</strong><br>  &emsp;&emsp;<strong>RAM</strong>基本别分为两部分：</p>
<ul>
<li>若干兆节用于存放<strong>内核映象</strong>，主要是<strong>内核代码</strong>和<strong>内核静态数据结构</strong>。</li>
<li>剩余部分全由虚拟内存子系统处理。主要用于三个方面：<ul>
<li>满足内核对缓冲区、描述符及其他动态内核数据结构的请求</li>
<li>满足进程对一般内存区的请求及对文件内存映射的请求</li>
<li>借助于高速缓存从磁盘及其他缓冲设备获得较好的性能<br>&emsp;&emsp;虚拟内存子系统另外一个需要处理的问题是<strong>内存碎片</strong>，因为即使存在可用内存，但如果不能作为一个<strong>连续</strong>的块使用时，申请内存会失败的。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>内核内存分配器KMA</strong><br>  &emsp;&emsp;内核内存分配器(Kernel Memory Allocator，<strong><code>KMA</code></strong>)是一个子系统，用于满足系统所有对内存的请求。KMA需要有如下特点：</p>
<ul>
<li>速度快，性能高</li>
<li>必须把内存的浪费减少到最少</li>
<li>必须努力减轻内存碎片问题</li>
<li>必须能与其他内存管理子系统合作<br>&emsp;&emsp;根据不同的算法有多种不同的KMA，Linux的KMA使用了<strong>Slab分配算法</strong>。</li>
</ul>
</li>
<li><p><strong>进程虚拟地址空间处理</strong><br>  &emsp;&emsp;进程的虚拟地址空间包括进程能使用的所有虚拟内存地址。内核常用一组<em>内存区描述符</em>描述进程虚拟地址空间。<br>  &emsp;&emsp;当进程使用<code>exec()</code>系统调用执行程序时，内核分配给进程的虚拟地址空间由以下<em>内存区</em>组成：</p>
<ul>
<li>程序的可执行代码(代码区)</li>
<li>程序的初始化数据(数据区)</li>
<li>程序的未初始化数据(数据区)</li>
<li>初始程序栈(用户态栈)</li>
<li>所需共享库的可执行代码和数据</li>
<li>堆(由程序动态申请的内存)<br>Linux系统都是采用<strong>请求调页(demand paging)</strong>的内存分配策略。进程可在其所需内存页没加载进内存前开始执行，当进程访问页不存在时，<code>MMU</code>产生一个异常，异常处理程序定位到受影响的内存区，分配空闲页并用适当的数据页进行初始化。有了<strong>请求调页(demand paging)</strong>内存分配策略，当进行使用<code>malloc()</code>系统调用动态申请内存时，内核仅需要修改<em>堆内存区</em>大小即可。</li>
</ul>
</li>
<li><p><strong>高速缓存</strong><br>  &emsp;&emsp;所谓高速缓存，就是将内存作为磁盘或其他设备的缓存。将从磁盘读入的内容缓存在内存中以便再次使用时能快速提供数据，不用重新从磁盘再加载进内存。对于写入磁盘的数据，会先直接在内存中修改，内核会将变更的数据标记为<code>dirty</code>并周期性地将这些<code>dirty</code>数据写回磁盘，避免重复低效的I/O操作。</p>
</li>
</ul>
<p><span id="memory_addressing"></span></p>
<h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a><strong>内存寻址</strong></h2><p>&emsp;&emsp;《深入理解Linux内核》内存寻址这章节是以<strong><code>80x86</code>微处理器</strong>为主来讲解芯片级别的内存寻址的。</p>
<h3 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a><strong>内存地址</strong></h3><p>&emsp;&emsp;<code>80x86</code>微处理器将内存区分为三种不同的地址：</p>
<ul>
<li><strong>逻辑地址(logical address)</strong><ul>
<li>包含在机器语言指令中用来指定一个操作数或一条指令的地址。</li>
<li>每个<strong>逻辑地址(logical address)</strong>由一个<strong>段(segment)</strong>和<strong>偏移量(offset/displacement)</strong>组成。</li>
</ul>
</li>
<li><strong>线性地址(linear address)</strong>/<strong>虚拟地址(virtual address)</strong><ul>
<li><code>32</code>位无符号整数。最大可表达<strong><code>4GB</code></strong>的地址。(32位系统中单进程寻址最大4G的原因)</li>
<li>通常用<strong>十六进制</strong>表示。<strong><code>0x00000000</code></strong> ~ <strong><code>0xffffffff</code></strong></li>
</ul>
</li>
<li><strong>物理地址(physical address)</strong><ul>
<li>用于内存芯片级内存单元寻址。</li>
<li>物理地址(physical address)和从微处理器的地址引脚发送到内存总线上的电信号相对应。</li>
<li>由<strong><code>32</code></strong>或<strong><code>64</code></strong>位无符号整数表示。</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;<strong>内存控制单元(MMU)</strong>通过<strong>分段单元(segmentation unit)</strong>硬件电路将逻辑地址(logical address)转换成虚拟地址(virtual address)，再通过<strong>分页单元(paging unit)</strong>硬件电路将虚拟地址(virtual address)转换物理地址(physical address)。<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑地址<span class="comment">(logical address)</span>——&gt;[分段单元<span class="comment">(segmentation unit)</span>]——&gt;虚拟地址<span class="comment">(virtual address)</span>——&gt;[分页单元<span class="comment">(paging unit)</span>]——&gt;物理地址<span class="comment">(physical address)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a><strong>分段</strong></h3><p>&emsp;&emsp;从<code>80286</code>模型开始，Intel微处理器以<code>2</code>种不同方式执行地址转换：</p>
<ul>
<li><strong>实模式(real mode)</strong>：之所以存在<em>实模式</em>是为了维持处理器与早期模型兼容并让操作系统自举</li>
<li><strong>保护模式(protected mode)</strong>：目前主要的地址转换模式，接下来主要讨论的内容</li>
</ul>
<h4 id="段选择符-amp-段寄存器"><a href="#段选择符-amp-段寄存器" class="headerlink" title="段选择符 &amp; 段寄存器"></a><strong>段选择符 &amp; 段寄存器</strong></h4><p>&emsp;&emsp;<strong>逻辑地址</strong> = <strong>段标识符</strong> + <strong>段内偏移量</strong></p>
<ul>
<li><strong>段标识符</strong>：<strong><code>16</code></strong>位长的字段，称<strong>段选择符(Segment Selector)</strong>，这<code>16</code>位长的<strong>段选择符</strong>结构如下<ul>
<li><code>15</code>~<code>3</code>：索引号</li>
<li><code>3</code>~<code>1</code>：<strong>TL</strong>——表指示器</li>
<li><code>1</code>~<code>0</code>：<strong>RPL</strong>——请求者特权级</li>
</ul>
</li>
<li><strong>偏移量</strong>：<strong><code>32</code></strong>位长的字段</li>
</ul>
<p>&emsp;&emsp;为能快速找到<strong>段选择符(Segment Selector)</strong>，处理器提供<strong>段寄存器</strong>，<strong>段寄存器的唯一目的就是存放段选择符</strong>。总共有<strong>6</strong>个段寄存器：<strong>cs</strong>、<strong>ss</strong>、<strong>ds</strong>、<strong>es</strong>、<strong>fs</strong>和<strong>gs</strong>，其中<code>3</code>个段寄存器有专门用途：</p>
<ul>
<li><strong>cs</strong>：代码段寄存器，指向包含程序指令的段。cs寄存器有个非常重要的功能：含有一个<code>2</code>位长的字段，用以指明CPU当前特权级，<code>0</code>表示最高优先级，<code>3</code>表示最低优先级。Linux只使用<code>0</code>和<code>3</code>分别称之为<strong>内核态</strong>和<strong>用户态</strong>。</li>
<li><strong>ss</strong>：栈段寄存器，指向包含程序栈的段</li>
<li><strong>ds</strong>：数据段寄存器，指向包含静态数据或全局数据段</li>
</ul>
<h4 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a><strong>段描述符</strong></h4><p>&emsp;&emsp;<strong>段描述符(Segment Descriptor)</strong>是用于描述段的特征的。<br>&emsp;&emsp;每个段都由一个<strong><code>8</code>字节</strong>的<strong>段描述符(Segment Descriptor)</strong>表示，<strong>段描述符(Segment Descriptor)</strong>存放在<strong>全局描述符表(Global Descriptor Table，GDT)</strong>或<strong>局部描述符表(Local Descriptor Table，LDT)</strong>中。<br>&emsp;&emsp;通常只定义一个GDT，若进程除存放在GDT中的段外仍需要新段，则创建属于自己的LDT来存放。<br>&emsp;&emsp;GDT在主存中的地址和大小存在<strong>gdtr控制寄存器</strong>中，当前正被使用的LDT地址和大小放在<strong>ldtr控制寄存器</strong>中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><span id="introduction"></span></p>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a><strong>绪论</strong></h2><h3 id="Unix文件系统概]]>
    </summary>
    
      <category term="Linux Kernel" scheme="http://yoursite.com/tags/Linux-Kernel/"/>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 内存小记]]></title>
    <link href="http://yoursite.com/2016/11/11/linux-memory/"/>
    <id>http://yoursite.com/2016/11/11/linux-memory/</id>
    <published>2016-11-11T10:28:14.000Z</published>
    <updated>2019-03-31T04:24:48.684Z</updated>
    <content type="html"><![CDATA[<p>&emsp;最近遇到几个有关Linux内存的问题，于是稍微整理了一下有关Linux内存方面的内容稍作记录。</p>
<h3 id="free-m"><a href="#free-m" class="headerlink" title="free -m"></a><strong>free -m</strong></h3><p>&emsp;一般看内存最直接就是输入<code>free -m</code>命令查看，显示的结果恐怕也是问得最多的(<code>free</code>命令实际是通过<strong><code>/proc/meminfo</code></strong>获得内存数值的)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&gt; free -m</span><br><span class="line">                   total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          <span class="number">3922</span>      <span class="number">2731</span>      <span class="number">1190</span>        <span class="number">341</span>        <span class="number">166</span>        <span class="number">963</span></span><br><span class="line">-/+ buffers/cache:    <span class="number">1601</span>      <span class="number">2320</span></span><br><span class="line">Swap:         <span class="number">1952</span>          <span class="number">0</span>       <span class="number">1952</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">total</th>
<th style="text-align:left">used</th>
<th style="text-align:left">free</th>
<th style="text-align:left">shared</th>
<th style="text-align:left">buffers</th>
<th style="text-align:left">cached</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Mem:</td>
<td style="text-align:left">总内存</td>
<td style="text-align:left">已使用内存<code>use+slab+buffers+cached</code></td>
<td style="text-align:left">完全空闲内存</td>
<td style="text-align:left">进程间共享内存</td>
<td style="text-align:left">buffers(详解见下)</td>
<td style="text-align:left">cached(详解见下)</td>
</tr>
<tr>
<td style="text-align:left">-/+ buffers/cache:</td>
<td style="text-align:left"></td>
<td style="text-align:left">实际使用内存<code>use+slab</code></td>
<td style="text-align:left">空闲内存<code>free+buffers+cached</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Swap:</td>
<td style="text-align:left">总swap</td>
<td style="text-align:left">已使用swap</td>
<td style="text-align:left">空闲swap</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>Mem:</strong>中的<strong>used</strong>是包括了<code>各进程使用内存+slab+buffers+cached</code>，即<code>2731 = 1601(use+slab) + 166(buffers) + 963(cached)</code> (由于使用<code>-m</code>以兆单位显示，计算时会有一点点出入。)</li>
<li><strong>Mem:</strong>中的<strong>free</strong>则表示完完全全没有被用于其他用途的内存，换句话说就是”多余”的、”浪费”的内存。</li>
<li><strong>-/+ buffers/cache</strong>中的<strong>used</strong>是系统实际使用的内存(slab的缓存也是包括在此used中的)，不包括<code>buffers</code>和<code>cached</code>，即<code>1601 = 2731(used) - 166(buffers) - 963(cached)</code>。</li>
<li><strong>-/+ buffers/cache</strong>中的<strong>free</strong>表示系统空闲内存，指系统<strong>最多</strong>还可用的内存量。此处的空闲内存是包含了<code>buffers</code>和<code>cached</code>的，即<code>2320 = 1190(free)  + 166(buffers) + 963(cached)</code><br>理论上认为<code>buffers</code>和<code>cached</code>是可释放回收的内存，因为内存的读取速度比硬盘快Linux充分利用内存资源以加快读取速度。但需要注意一点<strong>并非所有的<code>buffers</code>和<code>cached</code>都可被释放回收</strong>。</li>
<li>关于<code>buffers</code>和<code>cached</code>：<ul>
<li><code>cached</code>：是统计所有文件缓存的page总数，即是VFS的<strong>page cache</strong>总数。</li>
<li><code>buffers</code>：是统计所有block device(块设备)的bd_inode的address_space的page总数。<a href="https://www.quora.com/Linux-Kernel/What-is-the-major-difference-between-the-buffer-cache-and-the-page-cache/answer/Robert-Love-1" target="_blank" rel="external">网上资料</a>说对元数据(<code>metadata</code>)的操作也会缓存到<code>buffers</code>中，源码中没找到，此部分待验证。</li>
</ul>
</li>
</ol>
<h3 id="Linux-Cache"><a href="#Linux-Cache" class="headerlink" title="Linux Cache"></a><strong>Linux Cache</strong></h3><p>&emsp;为进一步说明<code>cached</code>和<code>buffers</code>，需要先弄清楚Linux的内存Cache机制，为了明白Linux的Cache机制需要去了解源码中有关<strong><code>address_space</code></strong>结构体的具体定义。<br>&emsp;Linux为提高读写数据速度和减少磁盘IO，会最大程度的将用到的数据存储在内存中。Linux内存管理是以页(page)为基本单位，当内核进行读操作时，首先检查数据是否存在于page cache中，存在则直接从内存读取数据，不存在则从磁盘读取并将该数据放入page cache，如果内存足够该数据会在page cache中长时间驻留。当内核进行写操作时，会直接在page cache中进行并将该页(page)标记为<strong>dirty</strong>，内核会周期性将dirty page写回到磁盘并取消ditry标记。<br>&emsp;大部分的file IO都会使用到page cache。但也可以指定不使用page cache，当进程打开文件时使用<strong><code>O_DIRECT</code></strong>标志，不使用page cache而是使用进程用户态地址空间的缓冲区。</p>
<h4 id="page数据产生方式"><a href="#page数据产生方式" class="headerlink" title="page数据产生方式"></a><strong>page数据产生方式</strong></h4><p>&emsp;内存中的page数据大致有两种产生方式：</p>
<ul>
<li><strong>读取文件(file IO)</strong>：这些page中的数据是通过读取文件产生的，这些page的拥有者是该文件的inode。这种方式是最为常用。</li>
<li><strong>直接读取块设备(block IO)</strong>：这些page中的数据是通过直接操作块设备(<code>如:/dev/sda1</code>)产生的，这些page的拥有者是块设备的主inode(块设备在bdev文件系统中的inode称主inode，在宿主文件系统[如ext4]中的inode称次inode)</li>
</ul>
<h4 id="页面描述符"><a href="#页面描述符" class="headerlink" title="页面描述符"></a><strong>页面描述符</strong></h4><p>&emsp;每个page有一个<strong>页面描述符(struct page)</strong>，页面描述符结构中含有<strong><code>mapping</code></strong>和<strong><code>index</code></strong>变量，用于连接page和page cache。</p>
<ul>
<li><strong><code>mapping</code></strong>：指向该page的inode的<strong>address_space</strong>对象。</li>
<li><strong><code>index</code></strong>：该page所有者地址空间中以页(page)为单位的偏移量。</li>
</ul>
<h4 id="address-space结构体"><a href="#address-space结构体" class="headerlink" title="address_space结构体"></a><strong>address_space结构体</strong></h4><p>&emsp;<strong><code>address_space</code></strong>是内存Cache中核心的数据结构，在<a href="https://github.com/torvalds/linux/blob/master/include/linux/fs.h#L431" target="_blank" rel="external">include/linux/fs.h</a>中定义。<br>&emsp;本次主要留意的是<strong><code>host</code></strong>和<strong><code>nrpages</code></strong>字段，<strong><code>host</code></strong>指向拥有该<code>address_space</code>对象的<code>inode</code>/<code>block_device</code>、<strong><code>nrpages</code></strong>表示该<code>inode</code>/<code>block_device</code>的页总数(解释<code>buffers</code>时会用到此字段，详见下)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> address_space &#123;</span><br><span class="line">    <span class="keyword">struct</span> inode		*host;		<span class="comment">/* owner: inode, block_device */</span></span><br><span class="line">    <span class="keyword">struct</span> radix_tree_root	page_tree;	<span class="comment">/* radix tree of all pages */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>		tree_lock;	<span class="comment">/* and lock protecting it */</span></span><br><span class="line">    <span class="keyword">atomic_t</span>		i_mmap_writable;<span class="comment">/* count VM_SHARED mappings */</span></span><br><span class="line">    <span class="keyword">struct</span> rb_root		i_mmap;		<span class="comment">/* tree of private and shared mappings */</span></span><br><span class="line">    <span class="keyword">struct</span> rw_semaphore	i_mmap_rwsem;	<span class="comment">/* protect tree, count, list */</span></span><br><span class="line">    <span class="comment">/* Protected by tree_lock together with the radix tree */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>		nrpages;	<span class="comment">/* number of total pages */</span></span><br><span class="line">    <span class="comment">/* number of shadow or DAX exceptional entries */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>		nrexceptional;</span><br><span class="line">    <span class="keyword">pgoff_t</span>			writeback_index;<span class="comment">/* writeback starts here */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> address_space_operations *a_ops;	<span class="comment">/* methods */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;		<span class="comment">/* error bits */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>		private_lock;	<span class="comment">/* for use by the address_space */</span></span><br><span class="line">    <span class="keyword">gfp_t</span>			gfp_mask;	<span class="comment">/* implicit gfp mask for allocations */</span></span><br><span class="line">    <span class="keyword">struct</span> list_head	private_list;	<span class="comment">/* ditto */</span></span><br><span class="line">    <span class="keyword">void</span>			*private_data;	<span class="comment">/* ditto */</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br></pre></td></tr></table></figure></p>
<h4 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a><strong>映射关系</strong></h4><p>&emsp;根据page中数据的产生方式不同所映射的关系也有些许差别：</p>
<ol>
<li>若page cache中page的数据来自文件(file IO)，那么该page中数据的拥有者为该文件的inode。VFS的<a href="https://github.com/torvalds/linux/blob/master/include/linux/fs.h#L604" target="_blank" rel="external"><code>inode</code>结构体</a>中有<code>i_data</code>字段而<strong><code>address_space</code></strong>则在该<code>i_data</code>字段中。<code>inode</code>结构体中除了有<code>i_data</code>外还有<code>i_mapping</code>，<strong><code>i_mapping</code></strong>指向该<code>inode</code>对应的<code>address_space</code>。<code>address_space</code>中的<code>host</code>字段指向所属的<code>inode</code>。大致关系如下图所示，<a href="http://blog.chinaunix.net/uid-28977986-id-3777252.html" target="_blank" rel="external">图片来源</a><br><img src="http://blog.chinaunix.net/attachment/201306/26/28977986_1372230654sA21.jpg" alt="page-address_space-inode关系图"></li>
<li>若page cache中page的数据来自块设备(block IO)，那么该page中的数据(<code>块设备的原始数据</code>)拥有者为该块设备的主inode。<code>address_space</code>则在<code>bdev</code>文件系统的inode(主inode)中，<code>i_mapping</code>字段指向<code>主inode</code>中的<code>address_space</code>。<code>address_space</code>中的<code>host</code>指向该<code>主inode</code>。</li>
</ol>
<h4 id="cached-amp-buffers"><a href="#cached-amp-buffers" class="headerlink" title="cached &amp; buffers"></a><strong>cached &amp; buffers</strong></h4><p>&emsp;上面说了这么多终于可以来解释<code>free -m</code>中的<code>cached</code>和<code>buffers</code>。</p>
<ul>
<li><strong><code>cached</code></strong>：<code>cached</code>就是进程在读写操作文件(fiel IO)所产生的驻留内存的数据，就是VFS中的<code>page cache</code>。</li>
<li><p><strong><code>buffers</code></strong>：</p>
<ol>
<li>为了更详细的解释<code>buffers</code>，我们直接查看相关源码。<code>free</code>命令是统计<code>/proc/meminfo</code>中的数值，而<code>/proc/meminfo</code>的值是调用<code>sysinfo</code>获得的。</li>
<li><p>在<a href="https://github.com/torvalds/linux/blob/master/fs/proc/meminfo.c#L47" target="_blank" rel="external">linux/fs/proc/meminfo.c</a>中有结构体<code>sysinfo</code>，而<code>sysinfo</code>结构体<a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/sysinfo.h#L13" target="_blank" rel="external">linux/include/uapi/linux/sysinfo.h</a>中使用了<code>bufferram</code>，而<code>bufferram</code>正是<code>free</code>命令中<code>buffers</code>的数值来源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sysinfo &#123;</span><br><span class="line">       <span class="keyword">__kernel_long_t</span> uptime;		<span class="comment">/* Seconds since boot */</span></span><br><span class="line">       <span class="keyword">__kernel_ulong_t</span> loads[<span class="number">3</span>];	<span class="comment">/* 1, 5, and 15 minute load averages */</span></span><br><span class="line">       <span class="keyword">__kernel_ulong_t</span> totalram;	<span class="comment">/* Total usable main memory size */</span></span><br><span class="line">       <span class="keyword">__kernel_ulong_t</span> freeram;	<span class="comment">/* Available memory size */</span></span><br><span class="line">       <span class="keyword">__kernel_ulong_t</span> sharedram;	<span class="comment">/* Amount of shared memory */</span></span><br><span class="line">       <span class="keyword">__kernel_ulong_t</span> bufferram;	<span class="comment">/* Memory used by buffers */</span></span><br><span class="line">       <span class="keyword">__kernel_ulong_t</span> totalswap;	<span class="comment">/* Total swap space size */</span></span><br><span class="line">       <span class="keyword">__kernel_ulong_t</span> freeswap;	<span class="comment">/* swap space still available */</span></span><br><span class="line">       __u16 procs;		   	<span class="comment">/* Number of current processes */</span></span><br><span class="line">       __u16 pad;		   	<span class="comment">/* Explicit padding for m68k */</span></span><br><span class="line">       <span class="keyword">__kernel_ulong_t</span> totalhigh;	<span class="comment">/* Total high memory size */</span></span><br><span class="line">       <span class="keyword">__kernel_ulong_t</span> freehigh;	<span class="comment">/* Available high memory size */</span></span><br><span class="line">       __u32 mem_unit;			<span class="comment">/* Memory unit size in bytes */</span></span><br><span class="line">       <span class="keyword">char</span> _f[<span class="number">20</span>-<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">__kernel_ulong_t</span>)-<span class="keyword">sizeof</span>(__u32)];	<span class="comment">/* Padding: libc5 uses this.. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<a href="https://github.com/torvalds/linux/blob/master/mm/page_alloc.c#L4140" target="_blank" rel="external">mm/page_alloc.c</a>中可以看出<code>bufferram</code>的值来至于函数<code>nr_blockdev_pages()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">si_meminfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">       val-&gt;totalram = totalram_pages;</span><br><span class="line">       val-&gt;sharedram = global_node_page_state(NR_SHMEM);</span><br><span class="line">       val-&gt;freeram = global_page_state(NR_FREE_PAGES);</span><br><span class="line">       val-&gt;bufferram = nr_blockdev_pages();</span><br><span class="line">       val-&gt;totalhigh = totalhigh_pages;</span><br><span class="line">       val-&gt;freehigh = nr_free_highpages();</span><br><span class="line">       val-&gt;mem_unit = PAGE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<a href="https://github.com/torvalds/linux/blob/master/fs/block_dev.c#L746" target="_blank" rel="external">fs/block_dev.c</a>中函数<code>nr_blockdev_pages()</code>返回<code>ret</code>。<br>&emsp;可以看到<code>ret</code>是将所有块设备(<code>block device</code>)对应的<code>bd_inode</code>中的<code>i_mapping</code>的<code>nrpages</code>累加。<code>i_mapping</code>是指向<code>address_space</code>的，而<code>nrpages</code>在<code>address_space</code>结构体中的定义是所有者的页的总数。换句话说，<code>free</code>中的<code>buffers</code>是统计所有块设备操作(<code>block IO</code>)产生的page总数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">nr_blockdev_pages</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">       <span class="keyword">struct</span> block_device *bdev;</span><br><span class="line">       <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">       spin_lock(&amp;bdev_lock);</span><br><span class="line">       list_for_each_entry(bdev, &amp;all_bdevs, bd_list) &#123;</span><br><span class="line">           ret += bdev-&gt;bd_inode-&gt;i_mapping-&gt;nrpages;</span><br><span class="line">       &#125;</span><br><span class="line">       spin_unlock(&amp;bdev_lock);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若想增加<code>buffers</code>的值，直接对块设备进行操作产生<code>block IO</code>，由此产生的page就会被缓存在<code>buffers</code>中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; cat /dev/sda1 &gt; /dev/null</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h4 id="手动清理缓存"><a href="#手动清理缓存" class="headerlink" title="手动清理缓存"></a><strong>手动清理缓存</strong></h4><p>&emsp;当缓存占用过多时，可手动对缓存进行清理，主要涉及到<strong><code>/proc/sys/vm/drop_caches</code></strong>值的调整。<br>&emsp;在清理缓存前，最好先同步数据，即将内存中被标记为<code>dirty</code>的数据写入磁盘。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; sync</span><br></pre></td></tr></table></figure></p>
<p>&emsp;<strong><code>/proc/sys/vm/drop_caches</code></strong>默认值为<code>0</code>(不清除缓存)，可选值有<code>1</code>、<code>2</code>和<code>3</code>，不同值所清理的缓存各有不同。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#清理page cache</span></span><br><span class="line">$&gt; <span class="built_in">echo</span> <span class="number">1</span> &gt; /proc/sys/vm/drop_caches</span><br><span class="line"><span class="comment">#清理dentries和inodes缓存</span></span><br><span class="line">$&gt; <span class="built_in">echo</span> <span class="number">2</span> &gt; /proc/sys/vm/drop_caches</span><br><span class="line"><span class="comment">#1&amp;2，清理page cache、dentries和inodes缓存</span></span><br><span class="line">$&gt; <span class="built_in">echo</span> <span class="number">3</span> &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure></p>
<p>&emsp;<code>page cache</code>前面讲了很多就不再细说。简单说说<code>dentries</code>和<code>inodes</code>。<code>dentry</code>和<code>inode</code>在VFS(Virtual file system)中是比较重要的。</p>
<ul>
<li><strong>inode</strong>：<code>inode</code>是文件对象的元数据，<code>inode</code>包含如下信息(<code>inode</code><strong>不包含</strong>数据和文件名)：<ul>
<li>文件类型</li>
<li>权限<code>rwx</code></li>
<li>属组<code>group id</code></li>
<li>拥有者<code>user id</code></li>
<li>文件字节数<code>size</code></li>
<li>时间戳<code>ctime  mtime atime</code></li>
<li>硬链接数</li>
<li>inode号</li>
<li>设备标识符</li>
</ul>
</li>
<li><strong>dentry</strong>：<code>dentry</code>即目录项，<code>dentry</code>主要作用是<strong>连接文件名和其<code>inode</code></strong>，由于<code>inode</code>中并没有包含文件名及路径信息，因此需要利用<code>dentry</code>构建并维护文件系统的目录树，每个文件的<code>dentry</code>链接到父目录的<code>dentry</code>从而形成了文件系统的结构树。<code>dentry</code>是一个纯粹的<strong>内存结构</strong>，由文件系统在提供文件访问的过程中在<strong>内存中</strong>直接创建。<code>dentry</code>结构体在源码中定义<a href="https://github.com/torvalds/linux/blob/master/include/linux/dcache.h#L83" target="_blank" rel="external">include/linux/dcache.h</a>。 <code>dentry</code>中包含文件名<code>d_name</code>、inode号<code>d_inode</code>、指向父目录的指针<code>d_parent</code>等等信息。<br>&emsp;当需要读取文件<code>/home/mogl/test.txt</code>时，总是从<code>/</code>目录开始查找，每个文件对象对应唯一一个<code>inode</code>，<code>/</code>的<code>inode number == 0</code>。读取<code>/</code>过程中在内存中创建<code>/</code>的<code>dentry</code>并将其缓存(有了缓存访问文件系统时便会非常快捷)。在Linux中目录也是文件，目录文件内容包括<code>目录下的文件名</code>和<code>inode number</code>，根据这些内容找到下级文件和其<code>inode</code></li>
</ul>
<h4 id="调整内核缓存倾向"><a href="#调整内核缓存倾向" class="headerlink" title="调整内核缓存倾向"></a><strong>调整内核缓存倾向</strong></h4><p>&emsp;可通过调整<strong><code>/proc/sys/vm/vfs_cache_pressure</code></strong>的值来调整内核清理<code>inode</code>和<code>dentry</code>缓存的倾向。<br>&emsp;<code>/proc/sys/vm/vfs_cache_pressure</code>默认值为<code>100</code>，内核根据<code>page cache</code>和<code>swap cache</code>将<code>inode</code>和<code>dentry</code>缓存保持一个合理的比例。</p>
<ul>
<li>降低<code>vfs_cache_pressure</code>(<code>vfs_cache_pressure &lt; 100</code>)会导致内核倾向于<strong>保留</strong>dentry和inode缓存。</li>
<li>增加<code>vfs_cache_pressure</code>(<code>vfs_cache_pressure &gt; 100</code>)，则会导致内核倾向于<strong>清除缓存重新加载</strong>dentries和inodes。</li>
</ul>
<h3 id="proc-meminfo"><a href="#proc-meminfo" class="headerlink" title="/proc/meminfo"></a><strong>/proc/meminfo</strong></h3><p>&emsp;<strong><code>/proc/meminfo</code></strong>是查看内存使用情况最主要的接口，很多命令诸如<code>free</code>、<code>vmstat</code>等都从这里获取数值的。<code>/proc/meminfo</code>信息很多，看懂其中的信息能让我们对系统内存的使用情况有更清晰的了解。先来看看<code>/proc/meminfo</code>的内容，然后逐个分析说明。<code>/proc/meminfo</code>的内容是通过<a href="https://github.com/torvalds/linux/blob/master/fs/proc/meminfo.c#L45" target="_blank" rel="external">fs/proc/meminfo.c 的 meminfo_proc_show()</a>函数获取的。<br>&emsp;参考文章<a href="https://access.redhat.com/solutions/406773" target="_blank" rel="external">RedHat Knowledgebase</a>、<a href="http://linuxperf.com/?p=142" target="_blank" rel="external">/proc/meminfo之迷</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">MemTotal:        <span class="number">4016668</span> kB</span><br><span class="line">MemFree:         <span class="number">1294904</span> kB</span><br><span class="line">Buffers:           <span class="number">86000</span> kB</span><br><span class="line">Cached:           <span class="number">985016</span> kB</span><br><span class="line">SwapCached:       <span class="number">121488</span> kB</span><br><span class="line">Active:          <span class="number">1580604</span> kB</span><br><span class="line">Inactive:         <span class="number">969872</span> kB</span><br><span class="line">Active(anon):    <span class="number">1234064</span> kB</span><br><span class="line">Inactive(anon):   <span class="number">657144</span> kB</span><br><span class="line">Active(file):     <span class="number">346540</span> kB</span><br><span class="line">Inactive(file):   <span class="number">312728</span> kB</span><br><span class="line">Unevictable:         <span class="number">116</span> kB</span><br><span class="line">Mlocked:             <span class="number">116</span> kB</span><br><span class="line">HighTotal:       <span class="number">3166364</span> kB</span><br><span class="line">HighFree:        <span class="number">1010456</span> kB</span><br><span class="line">LowTotal:         <span class="number">850304</span> kB</span><br><span class="line">LowFree:          <span class="number">284448</span> kB</span><br><span class="line">SwapTotal:       <span class="number">1999868</span> kB</span><br><span class="line">SwapFree:        <span class="number">1745832</span> kB</span><br><span class="line">Dirty:                <span class="number">80</span> kB</span><br><span class="line">Writeback:             <span class="number">0</span> kB</span><br><span class="line">AnonPages:       <span class="number">1392656</span> kB</span><br><span class="line">Mapped:           <span class="number">274004</span> kB</span><br><span class="line">Shmem:            <span class="number">411748</span> kB</span><br><span class="line">Slab:             <span class="number">100572</span> kB</span><br><span class="line">SReclaimable:      <span class="number">74076</span> kB</span><br><span class="line">SUnreclaim:        <span class="number">26496</span> kB</span><br><span class="line">KernelStack:        <span class="number">5824</span> kB</span><br><span class="line">PageTables:        <span class="number">25468</span> kB</span><br><span class="line">NFS_Unstable:          <span class="number">0</span> kB</span><br><span class="line">Bounce:                <span class="number">0</span> kB</span><br><span class="line">WritebackTmp:          <span class="number">0</span> kB</span><br><span class="line">CommitLimit:     <span class="number">4008200</span> kB</span><br><span class="line">Committed_AS:   <span class="number">11152492</span> kB</span><br><span class="line">VmallocTotal:     <span class="number">122880</span> kB</span><br><span class="line">VmallocUsed:       <span class="number">70840</span> kB</span><br><span class="line">VmallocChunk:      <span class="number">25384</span> kB</span><br><span class="line">HardwareCorrupted:     <span class="number">0</span> kB</span><br><span class="line">AnonHugePages:    <span class="number">339968</span> kB</span><br><span class="line">HugePages_Total:       <span class="number">0</span></span><br><span class="line">HugePages_Free:        <span class="number">0</span></span><br><span class="line">HugePages_Rsvd:        <span class="number">0</span></span><br><span class="line">HugePages_Surp:        <span class="number">0</span></span><br><span class="line">Hugepagesize:       <span class="number">2048</span> kB</span><br><span class="line">DirectMap4k:       <span class="number">32760</span> kB</span><br><span class="line">DirectMap2M:      <span class="number">878592</span> kB</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>MemTotal</strong><br>  &emsp;系统内存总量。这里的内存总量并非总的物理内存，而是除去硬件和kernel占用后内核能支配的内存。</li>
<li><strong>MemFree</strong><br>  &emsp;系统完全没有使用的内存。<code>free</code>命令中<code>Mem:</code>行的<code>free</code>(不包含<code>buffers</code>和<code>cached</code>)</li>
<li><strong>Buffers</strong><br>  &emsp;如前面所说<code>buffers</code>是统计所有block device(块设备)的bd_inode的address_space的page总数。即直接操作块设备的<code>block IO</code>会将缓存放到<code>buffers</code>中。</li>
<li><strong>Cached</strong><br>  &emsp;如前面所说<code>cached</code>是<code>VFS</code>的<code>page cache</code>，操作文件的<code>file IO</code>缓存会放到<code>cached</code>中。</li>
<li><strong>SwapCached</strong><br>  &emsp;统计曾经被<code>swap out</code>后现在又被<code>swap in</code>(即同时存在于<code>memory</code>和<code>swapfile</code>中)并且从又被<code>swap in</code>起就一直没有改变(即非<code>dirty</code>)的页(<code>page</code>)。这些页(<code>page</code>)如果需要再次被<code>swap out</code>的话无需进行<code>write</code>操作(回写磁盘)，这样能节省I/O和提升性能。</li>
<li><strong>Active</strong><br>  &emsp;最近经常被使用的内存页，<code>Active</code>的内存页一般不会被<code>swap out</code>或回收。<br>  &emsp;<strong><code>Active</code> = <code>Active(anon) + Active(file)</code></strong></li>
<li><strong>Inactive</strong><br>  &emsp;最近不经常被使用的内存页，<code>Inactive</code>的内存页很可能会被<code>swap out</code>或回收。<br>  &emsp;<strong><code>Inactive</code> = <code>Inactive(anon) + Inactive(file)</code></strong></li>
<li><strong>Active(anon)</strong><br>  &emsp;最近经常被使用的匿名页，<code>Active(anon)</code>的匿名页一般不会被<code>swap out</code>或回收。<br>  &emsp;Linux的内存页大致可分成两种：<ul>
<li><strong>文件页(file pages)</strong>，<code>page cache</code>等文件缓存对于的内存页</li>
<li><strong>匿名页(anonymous pages)</strong>，进程用户模式下的堆栈或使用<code>mmap</code>匿名映射的内存区</li>
</ul>
</li>
<li><strong>Inactive(anon)</strong><br>  &emsp;最近不经常被使用的匿名页。</li>
<li><strong>Active(file)</strong><br>  &emsp;最近经常被使用的文件页。</li>
<li><strong>Inactive(file)</strong><br>  &emsp;最近不经常被使用的文件页。</li>
<li><strong>Unevictable</strong><br>  &emsp;内存中不能被移除的内存页。</li>
<li><strong>Mlocked</strong><br>  &emsp;内存中被<strong><code>mlock()</code></strong>系统调用锁定的内存。<code>Mlocked</code>也是<code>Unevictable</code>的，当<code>Mlocked</code>增加时，<code>Unevictable</code>跟着增加而<code>Active/Inactive</code>则减小。</li>
<li><strong>HighTotal</strong><br>  &emsp;所有可用的高位内存[<code>ZONE_HIGHMEM(896MB~结束)</code>]。在x86结构中，物理内存分三种区域类型：ZONE_DMA(内存开始的16MB)、ZONE_NORMAL(16MB~896MB)、ZONE_HIGHMEM(896MB~结束)。该区域主要用于用户空间的程序或缓存页，该区域不能直接映射到内核空间。<br>  &emsp;<code>HighTotal</code>、<code>HighFree</code>、<code>LowTotal</code>和<code>LowFree</code>这几个参数在CentOS6已经被除去。</li>
<li><strong>SwapTotal</strong><br>  &emsp;总swap空间大小。</li>
<li><strong>SwapFree</strong><br>  &emsp;可用swap空间大小。</li>
<li><strong>Dirty</strong><br>  &emsp;内存中被标记为<code>dirty</code>的数据，这些数据需要被写回到磁盘中。</li>
<li><strong>Writeback</strong><br>  &emsp;正准备回写磁盘的内存缓存页。</li>
<li><strong>AnonPages</strong><br>  &emsp;统计内存中匿名页(anonymous pages)大小。<ul>
<li>VFS的所有page cache都属于文件页(file pages)，都不是匿名页(anonymous pages)。</li>
<li>匿名页(anonymous pages)是和用户进程共生的。一旦进程退出，则匿名页(anonymous pages)也随之释放，并不会像文件页(file pages)那样还缓存在内存中。</li>
</ul>
</li>
<li><strong>Mapped</strong><br>  &emsp;统计被mmaped的内存大小。<br>  &emsp;在内存的<code>file pages</code>和<code>anonymous pages</code>中，<code>page cache</code>属于<code>file pages</code>。<code>page cache</code>中的缓存页可能已经不被进程使用，但仍以缓存被保留在内存中。而另一些<code>page cache</code>的缓存页则正在被进程使用，如libraries或mmap的文件等，这些内存文件页称之为<code>mmaped</code>。<br>  &emsp;因为<code>shared memory</code>和<code>tmpfs</code>属于<code>page cache</code>，故<code>mmaped</code>中包含：<code>share memory(attached)</code>和<code>tmpfs(mapped)</code>。结合下面的<strong><code>Shmem</code></strong>一起看。</li>
<li><strong>Shmem</strong><br>  &emsp;共享内存(<strong><code>shared memory</code></strong>)的内存大小。<code>Shmem</code>统计的是实际分配使用的内存大小，而非申请的内存大小。<br>  &emsp;<code>shared memory</code>的内存页会被统计进<code>Cached(page cache)</code>和<code>Mapped(attached)</code><br>  &emsp;<code>shared memory</code>包括：<ul>
<li>SysV shared memory(<code>shmget</code>)</li>
<li>POSIX shared memory(<code>shm_open</code>)</li>
<li>shared anonymous mmap(<code>mmap</code>)</li>
</ul>
</li>
<li><strong>Slab</strong> 、<strong>SReclaimable</strong> 、<strong>SUnreclaim</strong><br>  &emsp;<strong><code>Slab</code></strong> == <strong><code>SReclaimable</code></strong>a + <strong><code>SUnreclaim</code></strong><br>  &emsp;<strong><code>SReclaimable</code></strong>为在内存有压力时可回收的部分，<strong><code>SUnreclaim</code></strong>为在即使在内存有压力时都不可回收的部分。<br>  &emsp;<strong><code>Slab</code></strong>是统计内核数据结构缓存大小(<code>dentry</code>&amp;<code>inode</code>)，这个和上面说的<code>/proc/sys/vm/vfs_cache_pressure</code>和<code>/proc/sys/vm/drop_caches</code>相关内容联系起来。<br>  &emsp;若想查看slab缓存更详细内容，可使用<strong><code>slabtop</code></strong>命令。</li>
<li><strong>KernelStack</strong><br>  &emsp;KernelStack(内核栈)是进程进入内核态(syscall/trap/exception)后使用的，其与用户栈是分开的，用户态时是无法使用内核栈的。<br>  &emsp;KernelStack(内核栈)的大小是固定的，从<code>2.6.32</code>版本后默认是<strong><code>16K</code></strong>，此前一般为<code>4K</code>或<code>8K</code>。<br>  &emsp;KernelStack(内核栈)是常驻内存且不可被回收的。</li>
<li><strong>PageTables</strong><br>  &emsp;<code>page table</code>用于将内存的虚拟地址映射成物理地址，<code>PageTables</code>统计<code>page table</code>所占内存的大小。<br>  &emsp;内存地址分配越多<code>page table</code>也会随之增大；若多个进程都命中(<code>attached</code>)相同的共享内存段，<code>PageTables</code>的值会变得比较大。</li>
<li><strong>NFS_Unstable</strong><br>  &emsp;<strong><code>NFS_Unstable</code></strong>统计已发给NFS Server但尚未写入磁盘的缓存页的大小。</li>
<li><strong>Bounce</strong><br>  &emsp;<strong><code>Bounce</code></strong>是统计用于块设备<code>bounce buffers</code>的内存大小。<br>  &emsp;某些设备只能访问低端内存，当I/O请求需要访问高端内存时，为了解决不能访问高端内存的问题，内核会在低端内存中分配一个临时buffer用于将高端内存的数据拷贝到此buffer区域中，此成为<code>bounce buffers</code>。</li>
<li><strong>WritebackTmp</strong><br>  &emsp;统计被<strong>FUSE</strong>用作临时回写缓存(<code>temporary writeback buffers</code>)的内存大小。</li>
<li><strong>CommitLimit</strong>、<strong>Committed_AS</strong><ul>
<li><strong>overcommit机制</strong><br>  &emsp;要弄清楚<code>CommitLimit</code>和<code>Committed_AS</code>，需要先解释一下Linux的<strong>overcommit</strong>机制——Linux允许进程申请超过当前实际可用大小的内存空间。但允许申请并不代表就实际分配如此大小的内存给进程，Linux是在进程使用内存时才实际将内存分配给进程。<code>commit</code>对应进程申请内存。对于<code>overcommit</code>在<code>2.6</code>内核版本后的Linux系统可用通过修改<strong><code>/proc/sys/vm/overcommit_memory</code></strong>来调整内存overcommit的行为，<code>/proc/sys/vm/overcommit_memory</code>允许使用<code>0</code>、<code>1</code>和<code>2</code>三个值。<ul>
<li><code>0</code>：<strong>Heuristic overcommit handling</strong>，默认值。允许overcommit，但内存会根据算法预测申请内存的行为是否合理，拒绝掉不合理的overcommit申请。</li>
<li><code>1</code>：<strong>Always overcommit</strong>，允许overcommit，只要进程申请内存就通过申请。</li>
<li><code>2</code>：<strong> Don’t overcommit</strong>，禁止overcommit。</li>
</ul>
</li>
<li><strong>OOM killer机制</strong><br>  &emsp;为了防止内存的overcommit机制导致内存不足，Linux设计了<strong>OOM killer</strong>机制。当Linux系统发现内存不足时，会比较所有进程的<strong><code>oom_score</code></strong><code>(/proc/&lt;pid&gt;/oom_score)</code>，通过杀死<code>oom_score</code>数值大的进程来释放内存。若要手动调整某个进程的<code>oom_score</code>，则需要通过修改<strong><code>oom_score_adj</code></strong>来实现(<code>echo -20 &gt; /proc/&lt;pid&gt;/oom_score_ad</code>)。</li>
<li><strong>CommitLimit</strong><br>  &emsp;<strong><code>CommitLimit</code></strong>是内存overcommit的判断值，申请的内存总大小超过<code>CommitLimit</code>的值即为overcommit。<br>  &emsp;<strong><code>CommitLimit</code></strong>是通过计算得到的，计算公式——<strong><code>CommitLimit = RAM * (overcommit_ratio/100) + swap</code></strong>。<code>overcommit_ratio</code>默认值为<code>50</code>，表示物理内存大小的50%，可通过<code>/proc/sys/vm/overcommit_ratio</code>调整。<br>  &emsp;若使用了<strong>huge pages</strong>(见下一个参数)则需要减去huage pages的大小，即计算公式——<strong><code>CommitLimit = (RAM - huge_pages) * (overcommit/100) + swap</code></strong></li>
<li><strong>Committed_AS</strong><br>  &emsp;表示所有进程已申请的内存总数。若<code>Committed_AS</code>超过<code>CommitLimit</code>则表示overcommit。</li>
</ul>
</li>
<li><strong>VmallocTotal</strong><br>  &emsp;<code>vmalloc</code>是以字节为单位分配虚拟地址连续的内存块。<br>  &emsp;<code>VmallocTotal</code>是表示可以<code>vmalloc</code>的内存大小。</li>
<li><strong>VmallocUsed</strong><br>  &emsp;已被使用的<code>vmalloc</code>虚拟内存大小。</li>
<li><strong>VmallocChunk</strong><br>  &emsp;统计可用的连续虚拟内存大小。</li>
<li><strong>HardwareCorrupted</strong><br>  &emsp;统计物理故障内存大小。当系统检测到内存的物理页面故障时，会将故障的内存页删除并统计到<code>HardwareCorrupted</code>。</li>
<li><strong>AnonHugePages</strong><br>  &emsp;<strong>AnonHugePages</strong>统计的是<strong>THP(Transparent HugePages)透明大页</strong>，<strong>THP(Transparent HugePages)</strong>和接下来的<strong>HugePages</strong>不太一样，先看看<strong>THP(Transparent HugePages)</strong>。<br>  &emsp;<strong>THP(Transparent HugePages)</strong>是使管理HugePage变得自动化而创造的。系统中存在着<strong><code>khugepaged</code></strong>进程，此进程会一直扫描所有进程使用的内存并视情况将<code>4k page</code>变成<code>huge page</code>。<br>  &emsp;<strong>THP(Transparent HugePages)</strong>是在系统运行时<strong>动态</strong>分配内存的，而<strong>HugePage</strong>是在系统启动时<strong>预先</strong>固定分配并在系统运行时不在改变。<br>  &emsp;使用<strong>THP(Transparent HugePages)</strong>可能会到来一些问题，有时候会需要将其关闭(默认开启)，关闭<strong>THP(Transparent HugePages)</strong>：<ul>
<li><code>echo never &gt; /sys/kernel/mm/redhat_transparent_hugepage/enabled</code></li>
<li><code>echo never &gt; /sys/kernel/mm/redhat_transparent_hugepage/defrag</code></li>
</ul>
</li>
<li><strong>HugePages_Total</strong>、<strong>HugePages_Free</strong>、<strong>HugePages_Rsvd</strong>、<strong>HugePages_Surp</strong>、<strong>Hugepagesize</strong><br>  &emsp;<strong>HugePage</strong>称之为大页。Linux内存的标准页大小(page size)为<strong><code>4K</code></strong>而<strong>HugePage</strong>常见大小(page size)为<strong><code>2M</code></strong>。<br>  &emsp;解释<strong>HugePage</strong>前，需要先了解<strong>TLB(Translation Lookaside Buffer)</strong>。Linux系统中进程使用内存地址为<strong>虚拟地址(Virtual Address)</strong>，但数据是要通过内存的<strong>物理地址(Physical Address)</strong>才能访问的。于是这就涉及到<strong>虚拟地址(Virtual Address)</strong>转<strong>物理地址(Physical Address)</strong>，而<strong>page table</strong>是专门用于虚拟地址转物理地址的(使用HugePage可减小<code>PageTables</code>大小)。对于使用大量内存的进程来说，查找<strong>page table</strong>太慢，于是设置了<strong>TLB(Translation Lookaside Buffer)</strong>，用于缓存内存地址映射关系以加快映射。增大<code>page size</code>，使得相同大小的TLB(Translation Lookaside Buffer)能覆盖到更多的内存，从而提高TLB(Translation Lookaside Buffer)的命中率，从而提高内存地址转换的速度，这是<strong>HugePage</strong>的一个主要作用。<br>  &emsp;正如上面所说<strong>HugePage</strong>是在系统启动时就预先固定分配好的，并且<strong>HugePage</strong>会常驻内存中。也就是说如果<code>4G</code>大小的内存的系统设置了<code>1G</code>大小的<strong>HugePage</strong>，那么在系统启动后，系统的可用内存则只有<code>3G</code>。系统启动后可以通过调整<strong><code>/proc/sys/vm/nr_hugepages</code></strong>参数值来调整<strong>HugePage</strong>的大小。<ul>
<li><strong>HugePages_Total</strong>：分配给<strong>huge page</strong>的内存页面数目，<strong><code>HugePageSize = HugePages_Total * Hugepagesize</code></strong></li>
<li><strong>HugePages_Free</strong>：系统中从未被使用的<strong>huge page</strong>内存页面数目。</li>
<li><strong>HugePages_Rsvd</strong>：系统中被分配但仍未被使用的<strong>huge page</strong>内存页面数目。这里需要注意<strong>HugePages_Free</strong>和<strong>HugePages_Rsvd</strong>，当进程申请HugePage时，会预订一块大页内存，此时<strong>HugePages_Rsvd</strong>会增加但<strong>HugePages_Free</strong>不会减少。只有当进行写入数据到预订的大页内存时，<strong>HugePages_Free</strong>才会减少，而此时<strong>HugePages_Rsvd</strong>也会减少。</li>
<li><strong>HugePages_Surp</strong>：超过系统设定的常驻HugePages内存页数目的内存页面数目。</li>
<li><strong>Hugepagesize</strong>：单个huge page的内存页面大小，通常为<code>2048Kb</code></li>
</ul>
</li>
<li><strong>DirectMap4k</strong>、<strong>DirectMap2M</strong><br>  &emsp;<strong>DirectMap4k</strong>表示TLB(Translation Lookaside Buffer)映射为<code>4K</code>的内存数目，<strong>DirectMap2M</strong>表示TLB(Translation Lookaside Buffer)映射为<code>2M</code>的内存数目。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;最近遇到几个有关Linux内存的问题，于是稍微整理了一下有关Linux内存方面的内容稍作记录。</p>
<h3 id="free-m"><a href="#free-m" class="headerlink" title="free -m"></a><stron]]>
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CDH5.7部署及Hadoop生态圈简录]]></title>
    <link href="http://yoursite.com/2016/09/19/cdh-hadoop/"/>
    <id>http://yoursite.com/2016/09/19/cdh-hadoop/</id>
    <published>2016-09-19T12:10:33.000Z</published>
    <updated>2019-03-31T04:24:48.664Z</updated>
    <content type="html"><![CDATA[<h2 id="基础环境-amp-软件包"><a href="#基础环境-amp-软件包" class="headerlink" title="基础环境 &amp; 软件包"></a><strong>基础环境 &amp; 软件包</strong></h2><ul>
<li>CentOS6.8 64bit</li>
<li>Cloudera Manager5.7.0</li>
<li>jdk1.7.0_75</li>
<li>MySQL5.6</li>
<li><a href="http://archive.cloudera.com/cm5/cm/5/cloudera-manager-el6-cm5.7.0_x86_64.tar.gz" target="_blank" rel="external">cloudera-manager-el6-cm5.7.0</a></li>
<li><a href="http://archive.cloudera.com/cdh5/parcels/5.7.0/CDH-5.7.0-1.cdh5.7.0.p0.45-el6.parcel" target="_blank" rel="external">CDH-5.7.0-1.cdh5.7.0.p0.45-el6.parcel</a></li>
<li><a href="http://archive.cloudera.com/cdh5/parcels/5.7.0/CDH-5.7.0-1.cdh5.7.0.p0.45-el6.parcel.sha1" target="_blank" rel="external">CDH-5.7.0-1.cdh5.7.0.p0.45-el6.parcel.sha1</a></li>
<li><a href="http://archive.cloudera.com/cdh5/parcels/5.7.0/manifest.json" target="_blank" rel="external">manifest.json</a></li>
<li><a href="http://dev.mysql.com/downloads/connector/j/" target="_blank" rel="external">mysql-connector-java-5.1.38-bin.jar</a></li>
</ul>
<h2 id="系统环境设置"><a href="#系统环境设置" class="headerlink" title="系统环境设置"></a><strong>系统环境设置</strong></h2><h3 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a><strong>配置JDK</strong></h3><p>&emsp;下载jdk，环境变量配置<strong><code>/etc/profile</code></strong>，所有节点均需要配置。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/java/jdk1.<span class="number">7</span></span><br><span class="line">PATH=<span class="variable">$JAVA</span>_HOME/bin:<span class="variable">$PATH</span></span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA</span>_HOME/lib/dt.jar:<span class="variable">$JAVA</span>_HOME/lib/tools.jar</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure></p>
<h3 id="配置hostname"><a href="#配置hostname" class="headerlink" title="配置hostname"></a><strong>配置hostname</strong></h3><ul>
<li><p><strong><code>/etc/sysconfig/network</code></strong></p>
  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">NETWORKING=</span>yes</span><br><span class="line"><span class="variable">HOSTNAME=</span><span class="literal">master</span>-<span class="keyword">node</span><span class="identifier"></span><span class="title"></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>/etc/hosts</code></strong><br>  &emsp;所有节点的IP及hostname</p>
</li>
</ul>
<h3 id="ssh免密"><a href="#ssh免密" class="headerlink" title="ssh免密"></a><strong>ssh免密</strong></h3><p>&emsp;主节点ssh免密登录所有节点<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P <span class="string">''</span> -f ~<span class="regexp">/.ssh/i</span>d_rsa</span><br><span class="line">ssh-<span class="keyword">copy</span>-id all_nodes</span><br></pre></td></tr></table></figure></p>
<h3 id="关闭iptables-selinux"><a href="#关闭iptables-selinux" class="headerlink" title="关闭iptables/selinux"></a><strong>关闭iptables/selinux</strong></h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&gt;</span> /etc/init.d/iptables stop</span><br><span class="line"><span class="variable">$&gt;</span> chkconfig iptables off</span><br><span class="line"><span class="comment">#临时关闭selinux</span></span><br><span class="line"><span class="variable">$&gt;</span> setenforce <span class="number">0</span></span><br><span class="line"><span class="comment">#永久关闭selinux</span></span><br><span class="line"><span class="variable">$&gt;</span> vim /etc/selinux/config</span><br><span class="line"><span class="constant">SELINUX</span>=disabled</span><br></pre></td></tr></table></figure>
<h3 id="NTP配置"><a href="#NTP配置" class="headerlink" title="NTP配置"></a><strong>NTP配置</strong></h3><h4 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a><strong>主节点</strong></h4><ul>
<li><p><code>/etc/ntp.conf</code></p>
  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">driftfile /var/<span class="class"><span class="keyword">lib</span>/<span class="title">ntp</span>/<span class="title">drift</span></span></span><br><span class="line">restrict <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">restrict -<span class="number">6</span> ::<span class="number">1</span></span><br><span class="line">restrict default nomodify notrap</span><br><span class="line">server pool.ntp.org prefer</span><br><span class="line">includefile /etc/ntp/crypto/pw</span><br><span class="line">keys /etc/ntp/keys</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动NTP</p>
  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; /etc/init.d/ntpd <span class="built_in">start</span></span><br><span class="line">$&gt; chkconfig ntpd <span class="command"><span class="keyword">on</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="从节点"><a href="#从节点" class="headerlink" title="从节点"></a><strong>从节点</strong></h4><ul>
<li><p><code>/etc/ntp.conf</code></p>
  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">driftfile /var/<span class="class"><span class="keyword">lib</span>/<span class="title">ntp</span>/<span class="title">drift</span></span></span><br><span class="line">restrict <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">restrict -<span class="number">6</span> ::<span class="number">1</span></span><br><span class="line">restrict default kod nomodify notrap nopeer noquery</span><br><span class="line">   <span class="comment">#restrict -6 default kod nomodify notrapnopeer noquery</span></span><br><span class="line">server master-node perfer</span><br><span class="line">   server pool.ntp.org</span><br><span class="line">includefile /etc/ntp/crypto/pw</span><br><span class="line">keys /etc/ntp/keys</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动NTP &amp; 同步时间</p>
  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ntpdate -u <span class="literal">master</span>-<span class="keyword">node</span><span class="identifier"></span><br><span class="line"></span><span class="title">$</span>&gt; /etc/init.d/ntpd <span class="literal">start</span></span><br><span class="line">$&gt; chkconfig ntpd on</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="优化项"><a href="#优化项" class="headerlink" title="优化项"></a><strong>优化项</strong></h3><p>&emsp;安装集群时会检测基础环境，需要对以下两项进行优化设置并添加到开机启动<code>/etc/rc.local</code><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; echo <span class="number">1</span> &gt; /<span class="keyword">proc</span>/sys/vm/swappiness</span><br><span class="line">$&gt; echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br></pre></td></tr></table></figure></p>
<h2 id="主节点安装配置MySQL"><a href="#主节点安装配置MySQL" class="headerlink" title="主节点安装配置MySQL"></a><strong>主节点安装配置MySQL</strong></h2><p>&emsp;MySQL只需要在主节点(cloudera-scm-server)上安装即可</p>
<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a><strong>安装MySQL</strong></h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&gt;</span> wget <span class="symbol">http:</span>/<span class="regexp">/repo.mysql.com/mysql</span>-community-release-el6-<span class="number">5</span>.noarch.rpm</span><br><span class="line"><span class="variable">$&gt;</span> rpm -ivh mysql-community-release-el6-<span class="number">5</span>.noarch.rpm</span><br><span class="line"><span class="variable">$&gt;</span> yum install mysql-server</span><br></pre></td></tr></table></figure>
<h3 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a><strong>配置MySQL</strong></h3><ul>
<li><p><code>/etc/my.cnf</code><br>  &emsp;由于要将数据全部都存放在大容量的/data分区下，所以需要对MySQL做些简单配置</p>
  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[mysqld]</span></span><br><span class="line"><span class="setting">datadir=<span class="value">/data/mysql</span></span></span><br><span class="line"><span class="setting">socket=<span class="value">/var/lib/mysql/mysql.sock</span></span></span><br><span class="line"><span class="setting">character-set-server=<span class="value">utf8</span></span></span><br><span class="line"><span class="setting">log-error=<span class="value">/data/log/mysql/mysqld.log</span></span></span><br><span class="line"><span class="setting">pid-file=<span class="value">/var/run/mysqld/mysqld.pid</span></span></span><br><span class="line"><span class="setting">symbolic-links=<span class="value"><span class="number">0</span></span></span></span><br><span class="line"><span class="setting">sql_mode=<span class="value">NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span></span></span><br><span class="line"><span class="title">[mysqld_safe]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&gt;</span> chkconfig mysqld on</span><br><span class="line"><span class="variable">$&gt;</span> mkdir -p /data/<span class="keyword">log</span>/mysql</span><br><span class="line"><span class="variable">$&gt;</span> /etc/init.d/mysqld start</span><br><span class="line"><span class="variable">$&gt;</span> mysqladmin -u root password <span class="string">'your_root_password'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>建表及授权</p>
  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&gt; mysql -uroot -p</span><br><span class="line">mysql&gt; <span class="keyword">create</span> database hive <span class="keyword">DEFAULT</span> CHARSET utf8 COLLATE utf8_general_ci;</span><br><span class="line">mysql&gt; <span class="keyword">create</span> database amon <span class="keyword">DEFAULT</span> CHARSET utf8 COLLATE utf8_general_ci;</span><br><span class="line">mysql&gt; <span class="keyword">create</span> database oozie <span class="keyword">DEFAULT</span> CHARSET utf8 COLLATE utf8_general_ci;</span><br><span class="line">mysql&gt; grant all privileges <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'master-node'</span> identified <span class="keyword">by</span> <span class="string">'your_root_password'</span> <span class="keyword">with</span> grant option;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="安装Cloudera-Manager-Server"><a href="#安装Cloudera-Manager-Server" class="headerlink" title="安装Cloudera Manager Server"></a><strong>安装Cloudera Manager Server</strong></h2><p>&emsp;在主节点上安装Cloudera Manager Server</p>
<ul>
<li><p>创建cloudera-scm用户</p>
  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd --<span class="built_in">system</span> --home=/<span class="keyword">opt</span>/<span class="keyword">cm</span>-<span class="number">5.7</span>.<span class="number">0</span>/run/cloudera-scm-server/ --<span class="keyword">no</span>-create-home --<span class="keyword">shell</span>=/bin/false --comment <span class="string">"Cloudera SCM User"</span> cloudera-scm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装配置Cloudera Manager Server<br>  &emsp;由于要将数据都放到/data分区，所以才需要创建软连接，否则不需要。</p>
  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&gt; tar -zxf cloudera-manager-el6-cm5.<span class="number">7.0</span>_x86_64.tar.gz</span><br><span class="line">$&gt; <span class="keyword">cp</span> -<span class="keyword">a</span> <span class="keyword">cm</span>-<span class="number">5.7</span>.<span class="number">0</span>/ /data</span><br><span class="line">$&gt; <span class="keyword">cp</span> -<span class="keyword">a</span> cloudera /data</span><br><span class="line">$&gt; <span class="keyword">ln</span> -<span class="keyword">s</span> /data/<span class="keyword">cm</span>-<span class="number">5.7</span>.<span class="number">0</span> /<span class="keyword">opt</span>/<span class="keyword">cm</span>-<span class="number">5.7</span>.<span class="number">0</span></span><br><span class="line">$&gt; <span class="keyword">ln</span> -<span class="keyword">s</span> /data/cloudera /<span class="keyword">opt</span>/cloudera</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化Cloudera Manager Server数据库</p>
  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&gt;</span> cp mysql-connector-java-<span class="number">5.1</span>.<span class="number">38</span>-bin.jar /opt/cm-<span class="number">5.7</span>.<span class="number">0</span>/share/cmf/<span class="class"><span class="keyword">lib</span>/<span class="title">mysql</span>-<span class="title">connector</span>-<span class="title">java</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="variable">$&gt;</span> mkdir -p /usr/share/java/ &amp;&amp; cp mysql-connector-java-<span class="number">5.1</span>.<span class="number">38</span>-bin.jar  /usr/share/java/mysql-connector-java.jar</span><br><span class="line"><span class="variable">$&gt;</span> /opt/cm-<span class="number">5.7</span>.<span class="number">0</span>/share/cmf/schema/scm_prepare_database.sh mysql cm -hmaster-node -uroot -p --scm-host master-node scm scm scm</span><br></pre></td></tr></table></figure>
</li>
<li><p>离线Parcels<br>  &emsp;在集群安装过程中需要下载parcels，由于国内网络原因需要先离线下载文件，再将以下文件放到<strong><code>/opt/cloudera/parcel-repo/</code></strong></p>
<ul>
<li>CDH-5.7.0-1.cdh5.7.0.p0.45-el6.parcel</li>
<li>CDH-5.7.0-1.cdh5.7.0.p0.45-el6.parcel.sha1    (必须将下载的原文件<code>CDH-5.7.0-1.cdh5.7.0.p0.45-el6.parcel.sha1</code>重命名成<code>CDH-5.7.0-1.cdh5.7.0.p0.45-el6.parcel.sha</code>，否则会重新下载)</li>
<li>manifest.json</li>
</ul>
</li>
<li><p>启动Cloudera Manager Server</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; /opt/cm-<span class="number">5.7</span><span class="number">.0</span>/etc/init.d/cloudera-scm-server start</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="安装Cloudera-Manager-Agent"><a href="#安装Cloudera-Manager-Agent" class="headerlink" title="安装Cloudera Manager Agent"></a><strong>安装Cloudera Manager Agent</strong></h2><p>&emsp;Cloudera Manager Agent在所有节点都需要安装，包括主节点。</p>
<ul>
<li><p>创建cloudera-scm用户</p>
  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; useradd --<span class="built_in">system</span> --home=/<span class="keyword">opt</span>/<span class="keyword">cm</span>-<span class="number">5.7</span>.<span class="number">0</span>/run/cloudera-scm-server/ --<span class="keyword">no</span>-create-home --<span class="keyword">shell</span>=/bin/false --comment <span class="string">"Cloudera SCM User"</span> cloudera-scm</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置cloudera-scm-agent<br>  &emsp;修改cm-5.7.0目录下文件<strong><code>cm-5.7.0/etc/cloudera-scm-agent/config.ini</code></strong>，将server_host修改成cloudera manager server地址<br>  &emsp;可自定义<code>log_file</code>路径</p>
  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">server_host=</span><span class="literal">master</span>-<span class="keyword">node</span><span class="identifier"></span><br><span class="line"></span><span class="title">log_file</span>=/data/cm-<span class="number">5.7</span>.<span class="number">0</span>/log/cloudera-scm-agent/cloudera-scm-agent.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步cloudera-scm-agent<br>  &emsp;将修改好配置的<strong><code>cm-5.7.0</code></strong>文件夹同步到剩余所有节点。<br>  &emsp;这里需要特别注意一点：<strong>绝对不能先启动cloudera-scm-agent再同步文件夹</strong>。因为<code>cloudera-scm-agent</code>启动后会在<code>/opt/cm-5.7.0/lib/cloudera-scm-agent/</code>目录下生成<code>uuid</code>，如果启动agent后再同步文件夹则会使得集群所有agent的<code>uuid</code>都相同，而<code>uuid</code>是用来标识集群中的每个节点的，必须唯一。假若先启动后同步的话，想要修复问题则需要删除<code>/opt/cm-5.7.0/lib/cloudera-scm-agent/</code>目录下所有文件，若问题仍旧没有修复则需要清空主节点Cloudera Manager的数据库。</p>
  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; scp -r <span class="regexp">/opt/</span>cm-<span class="number">5.7</span><span class="number">.0</span> root<span class="annotation">@bj</span>1-<span class="number">200</span>-<span class="string">centos12:</span><span class="regexp">/data/</span></span><br><span class="line">$&gt; ln -s <span class="regexp">/data/</span>cm-<span class="number">5.7</span><span class="number">.0</span> <span class="regexp">/opt/</span>cm-<span class="number">5.7</span><span class="number">.0</span></span><br><span class="line">$&gt; ln -s <span class="regexp">/data/</span>cloudera <span class="regexp">/opt/</span>cloudera</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动cloudera-scm-agent<br>  &emsp;cloudera-scm-agent有个bug，pid会放在<code>/opt/cm-5.7.0/run/cloudera-scm-agent/</code>目录下，但这个目录不会自动创建，于是启动时会报错，故需要手动创建该目录。</p>
  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">mkdir</span> -<span class="keyword">p</span> /<span class="keyword">opt</span>/<span class="keyword">cm</span>-<span class="number">5.7</span>.<span class="number">0</span>/run/cloudera-scm-agent/</span><br><span class="line">$&gt; /<span class="keyword">opt</span>/<span class="keyword">cm</span>-<span class="number">5.7</span>.<span class="number">0</span>/etc/init.<span class="keyword">d</span>/cloudera-scm-agent start</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="安装CDH5-7"><a href="#安装CDH5-7" class="headerlink" title="安装CDH5.7"></a><strong>安装CDH5.7</strong></h2><p>&emsp;当<code>cloudera-scm-server</code>和<code>cloudera-scm-agent</code>都成功启动后就可以通过Cloudera Manager的Web界面安装CDH5.7及相关服务。直接访问<strong><code>http://master-node:7180/cmf/login</code></strong>，默认初始用户及密码是：<code>admin/admin</code>。由于安装过程截图太多懒得一张张放上来了，只要安装提示一步步安装。<br>&emsp;选择安装其他服务时，若服务需要连接MySQL则可能需要将JDBC驱动文件放到相应服务的目录下。比如安装Hive，如果日志中提示连接MySQL错误则JDBC驱动文件放到<code>/opt/cloudera/parcels/CDH-5.7.0-1.cdh5.7.0.p0.45/lib/hive/lib/</code>目录下。<br>&emsp;如果安装Impala的话，需要在daemon节点安装perl：<code>yum install -y perl</code><br>&emsp;如果安装Hue的话，需要安装<code>python-lxml</code>：<code>yum install -y python-lxml</code><br>&emsp;如果启动某些服务提示<code>libxslt.so.1</code>错误，需要安装<code>yum install -y libxml2 libxslt</code><br>&emsp;在安装不同服务时可能会遇到各种各样的问题，需要到<code>/var/log/&lt;server_name&gt;</code>下查看日志逐个排查。</p>
<h2 id="Hadoop生态圈简介"><a href="#Hadoop生态圈简介" class="headerlink" title="Hadoop生态圈简介"></a><strong>Hadoop生态圈简介</strong></h2><p>&emsp;&emsp;围绕Hadoop有一系列的服务和组件简单记录一下它们的用途。我所使用的是Cloudera的CDH集群，基本都是Cloudera的生态，故Ambari涉及的都没怎么了解。</p>
<ul>
<li><p><strong>Hadoop</strong><br>  &emsp;Hadoop是Apache开发的一套分布式软件框架，目前是<code>2.x</code>版本，主要有以下三部分构成：</p>
<ul>
<li><strong>HDFS</strong><br>  &emsp;HDFS(Hadoop分布式文件系统)是Hadoop的分布式存储系统，HDFS主要又由以下三个部分组成：<ul>
<li><em>NameNode</em><br> &emsp;管理文件系统的元数据(metadata)，元数据(metadata)包括命名空间(namespace)、块信息等。</li>
<li><em>Secondary NameNode</em><br> &emsp;<strong>Secondary NameNode不是NameNode的备份</strong>。需要弄明白Secondary NameNode的作用先了解NameNode是如何保存元数据(metadata)的。<br> &emsp;NameNode会维护<strong>fsimage</strong>和<strong>edits</strong>两个文件，fsimage是NameNode启动时对整个文件系统的快照，edits是NameNode启动后文件系统改动的记录(类似MySQL的binlog)。当NameNode重启时才将edits里的内容合并到fsimage中得到整个文件系统最新的快照。这样就会有个问题，当NameNode长时间没有重启时，edits文件会变得非常大，要将edits中的内容合并到fsimage将会耗费很多时间。于是有了Secondary NameNode来解决此类问题。<br> &emsp;Secondary NameNode定期向NameNode获取edits文件的内容并更新到自己维护的fsimage中，合并完后再将最新的fsimage复制给NameNode。这样NameNode重启是用的fsimage就会是最新的。</li>
<li><em>DataNode</em><br>  &emsp;存储数据</li>
</ul>
</li>
<li><strong>MapReduce</strong><br>  &emsp;分布式计算框架</li>
<li><strong>Yarn</strong><br>  &emsp;新一代Hadoop引入的资源管理器，新一代的MapReduce(MRv2)。主要解决上一代Hadoop扩展性问题。</li>
</ul>
</li>
<li><p><strong>Spark</strong><br>  &emsp;Spark是另一个分布式计算框架，基于内存计算所以能提供更快的数据处理速度，由Scala语言编写提供更通用的API。其实Spark与MapReduce对应，都是计算框架。此外还有Flink和流计算框架Storm等等。不同的计算框架各有优缺点，根据不同场景选择不同的计算框架。</p>
</li>
<li><p><strong>Hive</strong><br>  &emsp;Hive是Hadoop的数据仓库系统。使用HQL(HiveQL，类似SQL)的查询语言，将SQL转化为MapReduce任务在Hadoop上执行。其实就是MapReduce程序写起来麻烦，于是为了简化和方便查询开发出能使用类似SQL进行查询的组件，这就是Hive。</p>
</li>
<li><p><strong>Pig</strong><br>  &emsp;Pig是基于Hadoop的数据分析平台。如果说Hive是SQL在Hadoop上的实现，那么Pig就是脚本方式的实现。Pig定义一种数据流语言——Pig Latin，将脚本语言转化为MapReduce任务在Hadoop上执行。</p>
</li>
<li><p><strong>Hbase</strong><br>  &emsp;分布式、可伸缩的面向列的数据库，支持随机、实时读写访问，来源与Google的BigTable。个人感觉如果应要和MySQL数据库对应的话，Hbase算是类似于NoSQL的KV数据库吧。Hbase提供Web UI：<code>http://Hbase_master:60010</code></p>
</li>
<li><p><strong>Phoenix</strong><br>  &emsp;Phoenix简单说就是SQL On Hbase，使SQL查询转换成Hbase的查询。</p>
</li>
<li><p><strong>Impala</strong><br>  &emsp;Impala是Cloudera公司开放，提供批量和实时查询的工具。Impala不需要使用到MapReduce计算模型，依赖Hive并可直接对HDFS和Hbase中的数据进行SQL(HiveSQL)查询，查询是速度是Hive的数倍。之所以会有Impala是因为Hive这种需要将SQL转成MapReduce的方式查询速度实在太慢，改用直接使用SQL(HiveSQL)在HDFS/Hbase中进行查询以提高速度。</p>
</li>
<li><p><strong>Oozie</strong><br>  &emsp;Oozie是一个工作流调度管理工具，协调数据接收、存储、转换和分析等工作。当需要将多个MapReduce任务连接在一起完成整个工作时，就需要使用到Oozie来协调多个MapReduce任务。</p>
</li>
<li><p><strong>Hue</strong><br>  &emsp;Hue是Cloudera开发的Web UI工具，用Pyhton的Django框架编写的。<code>Hue UI</code>、<code>Hue Server</code>和<code>Hue DB</code>三部分组成，<code>http://Hue_Server:8000</code></p>
</li>
<li><p><strong>Solr</strong><br>  &emsp;Solr是个企业级搜索引擎。</p>
</li>
<li><p><strong>Sqoop</strong><br>  &emsp;Sqoop是数据迁移工具，全称是Sql-To-Hadoop，主要用于传统关系型数据库(MySQL/Oracle/Postgres)和Hadoop之间的数据转换。</p>
</li>
<li><p><strong>Mahout</strong><br>  &emsp;Hadoop的机器学习库。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基础环境-amp-软件包"><a href="#基础环境-amp-软件包" class="headerlink" title="基础环境 &amp; 软件包"></a><strong>基础环境 &amp; 软件包</strong></h2><ul>
<li>Cen]]>
    </summary>
    
      <category term="CDH" scheme="http://yoursite.com/tags/CDH/"/>
    
      <category term="Bigdata" scheme="http://yoursite.com/categories/Bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python库札记]]></title>
    <link href="http://yoursite.com/2016/09/11/python-library-module/"/>
    <id>http://yoursite.com/2016/09/11/python-library-module/</id>
    <published>2016-09-11T10:28:14.000Z</published>
    <updated>2019-03-31T04:24:48.692Z</updated>
    <content type="html"><![CDATA[<p>&emsp;Python库非常多，为方便快速查询，将自己之前用到的库做个简单汇总记录，不定期持续更新。</p>
<p><span id="shutil"></span></p>
<h3 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a><strong>shutil</strong></h3><p>&emsp;<strong><a href="http://python.usyiyi.cn/python_278/library/shutil.html" target="_blank" rel="external">shutil</a></strong>模块提供目录和文件的高级操作</p>
<ul>
<li><p>复制操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment">#将文件src复制到文件或目录dest，保留文件权限</span></span><br><span class="line">shutil.copy(src, dest)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在shutil.copy的基础上加上copystat()，即将文件的访问/修改时间等信息也复制</span></span><br><span class="line">shutil.copy2(src, dest)</span><br><span class="line"></span><br><span class="line"><span class="comment">#复制文件src的内容（不包含元数据）到文件dest(不支持目录复制，dest中必须包含文件名)</span></span><br><span class="line">shutil.copyfile(src, dest)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将类文件对象src.log的内容复制到类文件对象dest.log</span></span><br><span class="line">shutil.copyfileobj(open(<span class="string">'src.log'</span>,<span class="string">'r'</span>), open(<span class="string">'dest.log'</span>, <span class="string">'w'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#递归拷贝src。symlinks=True则软链接文件也会被复制</span></span><br><span class="line">shutil.copytree(src, dest, symlinks=<span class="keyword">True</span>, ignore=shutil.ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'*.swap'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>移动&amp;删除操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归方式移动文件或目录</span></span><br><span class="line">shutil.move(src, dest)</span><br><span class="line"></span><br><span class="line"><span class="comment">#递归删除文件</span></span><br><span class="line">shutil.rmtree(folder1, folder2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩文件<br>&emsp;压缩文件。将目录”/usr/local/project”压缩到”/home/mogl/test.tar.gz”<br>&emsp;压缩包支持类型：zip/tar/gztar/bztar</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.make_archive(<span class="string">"/home/mogl/test"</span>, <span class="string">'gztar'</span>, root_dir=<span class="string">"/usr/local/project"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><span id="glob"></span></p>
<h3 id="glob"><a href="#glob" class="headerlink" title="glob"></a><strong>glob</strong></h3><p>&emsp;<strong><a href="http://python.usyiyi.cn/python_278/library/glob.html" target="_blank" rel="external">glob</a></strong>模块提供Unix Shell规则的文件匹配功能<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'*.png'</span>)</span><br><span class="line">glob.glob(<span class="string">'[0-9].*'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回迭代器</span></span><br><span class="line">files = glob.iglob(<span class="string">'*.log'</span>)</span><br><span class="line"><span class="keyword">for</span> each_file <span class="keyword">in</span> files:</span><br><span class="line">    <span class="keyword">print</span> each_file</span><br></pre></td></tr></table></figure></p>
<p><span id="shlex"></span></p>
<h3 id="shlex"><a href="#shlex" class="headerlink" title="shlex"></a><strong>shlex</strong></h3><p>&emsp;<a href="https://docs.python.org/2/library/shlex.html" target="_blank" rel="external">shlex</a>模块提供简单的Unix Shell命令参数词法分析功能，可结合<a href="#subprocess">subprocess</a>使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"></span><br><span class="line">shlex.split(<span class="string">"ls -lht /tmp"</span>)</span><br><span class="line"><span class="comment">#['ls', '-lht', '/tmp']</span></span><br></pre></td></tr></table></figure></p>
<p><span id="argparse"></span></p>
<h3 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a><strong>argparse</strong></h3><p>&emsp;<strong><a href="http://python.usyiyi.cn/python_278/library/argparse.html" target="_blank" rel="external">argparse</a></strong>是用于命令行参数解析的模块，功能非常强大，目前所用到的只是简单功能，直接上实例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'descritption'</span>, epilog=<span class="string">"author:mogl"</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-d'</span>, <span class="string">'--directory'</span>, action=<span class="string">'store_true'</span>, help=<span class="string">'Only search directory'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-i'</span>, <span class="string">'--ignore-case'</span>, action=<span class="string">'store_true'</span>, help=<span class="string">'Ignore case search'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-S'</span>, <span class="string">'--srcport'</span>, help=<span class="string">'sorce port'</span>, type=int, required=<span class="keyword">True</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-D'</span>, <span class="string">'--destport'</span>, help=<span class="string">'dest port'</span>, type=int, default=<span class="number">80</span>)</span><br><span class="line">parser.add_argument(<span class="string">'file_name'</span>, nargs=<span class="string">'+'</span>, help=<span class="string">'The file name'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取参数值</span></span><br><span class="line"><span class="keyword">print</span> args.ignore_case</span><br><span class="line"><span class="keyword">print</span> args.srcport</span><br><span class="line"><span class="keyword">print</span> args.destport</span><br><span class="line"></span><br><span class="line"><span class="comment">#python test.py -S 124 test mogl</span></span><br><span class="line"><span class="comment">#False</span></span><br><span class="line"><span class="comment">#124</span></span><br><span class="line"><span class="comment">#80</span></span><br><span class="line"><span class="comment">#['test', 'mogl']</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>参数</strong><br>  参数可分为两种：</p>
<ul>
<li>选项参数(optional)<br>  <code>parser.add_argument(&#39;-i&#39;, &#39;--ignore-case&#39;, action=&#39;store_true&#39;, help=&#39;Ignore case search&#39;)</code><br>  选项参数默认使用<code>-</code>做前缀标识</li>
<li>位置参数(positional)<br>  <code>parser.add_argument(&#39;file_name&#39;, nargs=&#39;+&#39;, help=&#39;The file name&#39;)</code></li>
</ul>
</li>
<li><p><strong>选项参数解析</strong><br>   &emsp;选项参数默认返回<strong><code>None</code></strong>，可用<code>default</code>参数指定默认值。如果该参数是必须的则使用<code>required=True</code><br>  <code>parser.add_argument(&#39;-i&#39;, &#39;--ignore-case&#39;, action=&#39;store_true&#39;, help=&#39;Ignore case search&#39;)</code><br>  <code>parser.add_argument(&#39;-S&#39;, &#39;--srcport&#39;, help=&#39;sorce port&#39;, type=int, required=True)</code></p>
<ul>
<li><code>&#39;-i&#39;, &#39;--ignore-case&#39;</code><br>  参数长短语法</li>
<li><code>action=&#39;store_true&#39;</code><br>  表明该参数不接受参数传递，即不接收诸如<code>-i test</code>、<code>--ignore-case=true</code></li>
<li><code>type=int</code><br>  若不使用<code>action=&#39;store_true&#39;</code>则可表明接受参数传递，使用<code>type</code>指定传入类型(<code>type=int|str|complax</code>)</li>
<li><code>help=&#39;sorce port&#39;</code><br>  该参数的说明</li>
</ul>
</li>
<li><p><strong>位置参数</strong><br>  &emsp;若指定了位置参数，则运行程序时必须传入该参数才能运行<br>  <code>parser.add_argument(&#39;file_name&#39;, nargs=&#39;+&#39;, help=&#39;The file name&#39;)</code></p>
<ul>
<li><code>nargs</code><br>  将多个参数关联在一起。<code>+</code>将多个参数存到一个列表里,至少要有一个参数否则报错</li>
</ul>
</li>
<li><p><strong>action</strong><br>  &emsp;argparse默认设置6个action：</p>
<ul>
<li>store<br>  保存参数值，可能会先将参数值转换成另一个数据类型。若没有显式指定动作，则默认为该动作。</li>
<li>store_const<br>  保存一个被定义为参数规格一部分的值，而不是一个来自参数解析而来的值。这通常用于实现非布尔值的命令行标记。</li>
<li>store_ture/store_false<br>  保存相应的布尔值。这两个动作被用于实现布尔开关。</li>
<li>append<br>  将值保存到一个列表中。若参数重复出现，则保存多个值。</li>
<li>append_const<br>  将一个定义在参数规格中的值保存到一个列表中。</li>
<li>version<br>  打印关于程序的版本信息，然后退出</li>
</ul>
</li>
</ul>
<p><span id="re"></span></p>
<h3 id="re"><a href="#re" class="headerlink" title="re"></a><strong>re</strong></h3><p>&emsp;<strong><a href="http://python.usyiyi.cn/python_278/library/re.html" target="_blank" rel="external">re</a></strong>提供正则表达式匹配操作，是处理字符串最常用的库。</p>
<h4 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a><strong>正则表达式语法</strong></h4><p>&emsp;使用re库前，先大致了解正则表达式的基本语法，正好顺便总结一下有关正则表达式的内容。</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th></th>
<th></th>
<th></th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>基本关键字</strong></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">常规模式下匹配除<code>\n</code>外的所有字符，DOTALL模式下<code>\n</code>也匹配</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">常规模式下匹配字符串开头，MULTILINE模式下匹配每行开头</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">常规模式下匹配字符串结尾，MULTILINE模式下匹配行尾</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配*前面内容零次或多次，贪婪匹配</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配+前面内容零次或多次，贪婪匹配</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配?前面内容零次或1次</td>
</tr>
<tr>
<td style="text-align:center">{m}</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配{m}前面内容m次</td>
</tr>
<tr>
<td style="text-align:center">{m,n}</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配{m,n}前面内容m~n次</td>
</tr>
<tr>
<td style="text-align:center">*? +? ?? {m,n}?</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">* + ? {m,n}都是贪婪匹配，后面加上?后为非贪婪匹配</td>
</tr>
<tr>
<td style="text-align:center">[]</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配[]内字符集的任一字符，<code>^</code>表示不匹配，<code>-</code>并用给出一段范围字符</td>
</tr>
<tr>
<td style="text-align:center">单竖线</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">或，只匹配其中一个</td>
</tr>
<tr>
<td style="text-align:center"><strong>分组关键字</strong></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">(…)</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配括号内任意正则表达式并形成一个分组</td>
</tr>
<tr>
<td style="text-align:center">(?P<code>&lt;name&gt;</code>…)</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">为符合匹配的分组命名</td>
</tr>
<tr>
<td style="text-align:center">(?#…)</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">注释，(?#..)里的内容会被忽略</td>
</tr>
<tr>
<td style="text-align:center">(?=…)</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配结果后面的字符串需要满足表达式<code>...</code>。<strong>python_re_test</strong>——<code>.*(?=_test)</code>则匹配到字符串<strong>python_re</strong></td>
</tr>
<tr>
<td style="text-align:center">(?!…)</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配结果后面的字符串必须不满足表达式<code>...</code></td>
</tr>
<tr>
<td style="text-align:center">(?&lt;=…)</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配结果前面的字符串需要满足表达式<code>...</code>。<strong>python_re_test</strong>——<code>(?&lt;=python_).*</code>则匹配字符串<strong>re_test</strong></td>
</tr>
<tr>
<td style="text-align:center">(?&lt;!…)</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配结果前面的字符串必须不满足表达式<code>...</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>特殊关键字</strong></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配数字，相当于[0-9]</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配非数字，相当于[^0-9]</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配空白字符，相当于[\t\r\n\f\v]</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配非空白字符，相当于[^\t\r\n\f\v]</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配字母或数字，相当于[0-9a-zA-Z]</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配非字母或数字，相当于[^0-9a-zA-Z]</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配字符串边界</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配非字符串边界</td>
</tr>
<tr>
<td style="text-align:center">\A</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配字符串开头</td>
</tr>
<tr>
<td style="text-align:center">\Z</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">匹配字符串结尾</td>
</tr>
</tbody>
</table>
<h4 id="re库flags参数"><a href="#re库flags参数" class="headerlink" title="re库flags参数"></a><strong>re库flags参数</strong></h4><p>&emsp;Python的re库API中可指定<strong>flags</strong>参数，通过这些flags参数指定正则表达式选项通常使用类似<code>re.I</code>这样的简写，比如<code>re.compile(pattern, [flags])</code>函数——<code>re.compile(pattern, re.I)</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th></th>
<th></th>
<th></th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">re.A</td>
<td></td>
<td>ASCII</td>
<td></td>
<td style="text-align:left">使\w\W\b\B\d\D匹配ASCII字符</td>
</tr>
<tr>
<td style="text-align:center">re.I</td>
<td></td>
<td>IGNORECASE</td>
<td></td>
<td style="text-align:left">忽略大小写</td>
</tr>
<tr>
<td style="text-align:center">re.L</td>
<td></td>
<td>LOCALE</td>
<td></td>
<td style="text-align:left">使\w\W\b\B匹配本地字符集</td>
</tr>
<tr>
<td style="text-align:center">re.M</td>
<td></td>
<td>MULTILINE</td>
<td></td>
<td style="text-align:left">多行模式，<code>^</code> 匹配每行开头，<code>$</code>匹配每行结尾</td>
</tr>
<tr>
<td style="text-align:center">re.X</td>
<td></td>
<td>VERBOSE</td>
<td></td>
<td style="text-align:left">详细模式，忽略空格和<code>#</code>后面的注释</td>
</tr>
<tr>
<td style="text-align:center">re.U</td>
<td></td>
<td>UNICODE</td>
<td></td>
<td style="text-align:left">使\w\W\b\B\d\D匹配unicode字符集</td>
</tr>
</tbody>
</table>
<h4 id="re库正则函数"><a href="#re库正则函数" class="headerlink" title="re库正则函数"></a><strong>re库正则函数</strong></h4><ul>
<li><p>re.compile(pattern[, flags])<br>  &emsp;将模式和标识编译成正则表达式对象，方便给<code>search()</code>、<code>match()</code>和<code>findall()</code>等函数使用。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">r'[0-9]+'</span>)</span><br><span class="line"><span class="keyword">print</span> pattern.findall(<span class="string">'abc123d'</span>)</span><br><span class="line"><span class="comment">#123</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>re.search(pattern, string[, flags])<br>  &emsp;在字符串<code>string</code>中查找匹配<code>pattern</code>表达式的串，成功则返回<strong>MatchObject</strong>对象，失败则返回<strong>None</strong></p>
<ul>
<li><p>re.search (string[, pos[, endpos]])<br>  &emsp;对于已编译的正则表达式对象，<code>search()</code>函数可指定搜索的起始结束位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用compile()</span></span><br><span class="line">pattern = re.compile(<span class="string">"a+"</span>)</span><br><span class="line"><span class="keyword">print</span> pattern.search(<span class="string">"aabcde"</span>).group(<span class="number">0</span>)		<span class="comment">#=&gt;aa</span></span><br><span class="line"><span class="keyword">print</span> pattern.search(<span class="string">"aabcde"</span>, <span class="number">1</span>).group(<span class="number">0</span>) 	<span class="comment">#=&gt;a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#不使用compile()</span></span><br><span class="line">regx = re.search(<span class="string">r'a+'</span>, <span class="string">'aabcde'</span>)</span><br><span class="line"><span class="keyword">print</span> regx.group(<span class="number">0</span>)		<span class="comment">#=&gt;aa</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>re.match(pattern, string[, flags])<br>  &emsp;在字符串<code>string</code><strong>开头位置</strong>查找匹配<code>pattern</code>表达式的串(必须是<strong>开头位置</strong>)</p>
<ul>
<li>re.match(string[, pos[, endpos]])<br>  &emsp;同样对于已编译的正则对象可指定位置<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">"a+"</span>)</span><br><span class="line"><span class="keyword">print</span> pattern.match(<span class="string">'aabcde'</span>).group(<span class="number">0</span>) 	<span class="comment">#=&gt;aa</span></span><br><span class="line"><span class="keyword">print</span> pattern.match(<span class="string">'xaabcde'</span>)			<span class="comment">#=&gt;None</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>re.findall(pattern, string[, flags])<br>  &emsp;在字符串<code>string</code>中查找<strong>所有</strong>匹配<code>pattern</code>的串，成功则返回列表，失败则返回空列表。<br>  &emsp;<code>re.search()</code>和<code>re.match()</code><strong>仅匹配一次</strong>。</p>
<ul>
<li>re.findall(string[, pos[, endpos]])<br>  &emsp;同样对于已编译的正则对象可指定位置<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">"\d+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> pattern.search(<span class="string">'ab12cd34'</span>).group(<span class="number">0</span>)		<span class="comment">#=&gt;12</span></span><br><span class="line"><span class="keyword">print</span> pattern.match(<span class="string">'ab12cd34'</span>)				<span class="comment">#=&gt;None</span></span><br><span class="line"><span class="keyword">print</span> pattern.findall(<span class="string">'ab12cd34'</span>)				<span class="comment">#=&gt;['12', '34']</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>re.finditer(pattern, string[, flags])<br>  &emsp;<code>re.finditer()</code>和<code>re.findall()</code>类似，只是<code>re.finditer()</code>返回一个迭代器对象。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">"\d+"</span>)</span><br><span class="line"><span class="keyword">for</span> each_iter <span class="keyword">in</span> piter:</span><br><span class="line">   	<span class="keyword">print</span> each_iter.group(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#=&gt;12</span></span><br><span class="line"><span class="comment">#=&gt;34</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>re.sub(pattern, rep_string, string[, count, flags])</p>
</li>
<li>re.subn(pattern, rep_string, string[, count, flags])<br>  &emsp;在字符串<code>string</code>中查找匹配<code>pattern</code>的字符串并用<code>rep_string</code>替换。<code>rep_string</code>可以是一个<strong>函数</strong>，成功则返回替换后的字符串，否则返回原字符串。<br>  &emsp;<code>re.subn()</code>和<code>re.sub()</code>类似，只是<code>re.subn()</code>返回替换后的字符串和<strong>替换次数</strong>。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r'(name|full_name)'</span>)</span><br><span class="line">pattern.sub(<span class="string">'mogl'</span>, <span class="string">'name test python re full_name'</span>)</span><br><span class="line"><span class="comment">#=&gt;'mogl test python re mogl'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="MatchObject对象"><a href="#MatchObject对象" class="headerlink" title="MatchObject对象"></a><strong>MatchObject对象</strong></h4><p>&emsp;<code>re.match()</code>、<code>re.search()</code>和<code>re.finditer()</code>若成功匹配的话都是返回一个<strong>MatchObject</strong>对象。(<code>re.findall()</code>返回列表)<br>&emsp;MatchObject对象可调用几个函数：</p>
<ul>
<li><code>group()</code>：返回匹配的完整字符串</li>
<li><code>groups()</code>：返回分组信息</li>
<li><code>groupdict()</code>：返回所有命名分组字典</li>
<li><code>start()</code>：返回匹配字符串的起始位置</li>
<li><code>end()</code>：返回匹配字符串的结束位置</li>
<li><code>span()</code>：返回起始位置和结束位置的元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">mystr = <span class="string">'12ab34cd'</span></span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">r'(\d+)(?P&lt;letter&gt;[a-zA-Z]+)'</span>)</span><br><span class="line"></span><br><span class="line">m = pattern.search(mystr)</span><br><span class="line"></span><br><span class="line">m.group()	<span class="comment">#=&gt;'12ab'</span></span><br><span class="line"></span><br><span class="line">m.start()	<span class="comment">#=&gt;0</span></span><br><span class="line"></span><br><span class="line">m.end()		<span class="comment">#=&gt;4</span></span><br><span class="line"></span><br><span class="line">m.span()	<span class="comment">#=&gt;(0, 4)</span></span><br><span class="line"></span><br><span class="line">m.groups()	<span class="comment">#=&gt;('12', 'ab')</span></span><br><span class="line"></span><br><span class="line">m.groupdict()	<span class="comment">#=&gt;&#123;'letter': 'ab'&#125;</span></span><br><span class="line"></span><br><span class="line">m.group(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)	<span class="comment">#=&gt;('12ab', '12', 'ab')</span></span><br></pre></td></tr></table></figure>
<p><span id="os"></span></p>
<h3 id="os"><a href="#os" class="headerlink" title="os"></a><strong>os</strong></h3><p>&emsp;<a href="http://python.usyiyi.cn/translate/python_278/library/os.html" target="_blank" rel="external">os</a>模块提供统一的操作系统功能。</p>
<ul>
<li><p><strong>os.getcwd()</strong><br>  获取当前工作目录</p>
</li>
<li><p><strong>os.chdir(path)</strong><br>  修改工作目录</p>
</li>
<li><p><strong>os.listdir(path)</strong><br>  列出path下所有文件/目录，不支持递归和通配符</p>
</li>
<li><p><strong>os.walk(path)</strong><br>  深度遍历path下所有文件/目录</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">'/tmp'</span>):</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"root=%s, dirs=%s, files=%s"</span> % (root, dirs, files)**</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>os.mkdir(path)</strong><br>  创建目录，若path已存在则抛出异常</p>
</li>
<li><p><strong>os.makedirs(‘/path/subpath’)</strong><br>  递归创建多级目录，相当于Linux命令<code>mkdir -p</code></p>
</li>
<li><p><strong>os.rmdir(path)</strong><br>  删除空目录</p>
</li>
<li><p><strong>os.removedirs(path)</strong><br>  递归删除path下的子目录，目录非空则异常</p>
</li>
<li><p><strong>os.remove(file)</strong><br>  删除文件，若file为目录则抛出异常</p>
</li>
<li><p><strong>os.rename(path1, path2)</strong><br>  重命名</p>
</li>
<li><p><strong>os.renames(path1, path2)</strong><br>  重命名，会创建path2目标路径</p>
</li>
<li><p><strong>os.chmod(path, mode)</strong><br>  修改权限</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.chmod(<span class="string">'/tmp/test'</span>, <span class="number">0777</span>)**</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>os.chown(path, uid, gid)</strong><br>  修改拥有者</p>
</li>
<li><p><strong>os.access(path, mode)</strong><br>  权限测试</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.access(<span class="string">'/tmp/test.txt'</span>, os.W_OK)**</span><br><span class="line">os.access(<span class="string">'/tmp/test.txt'</span>, os.R_OK)**</span><br><span class="line">os.access(<span class="string">'/tmp/test.txt'</span>, os.X_OK)**</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a><strong>os.path</strong></h4><p>&emsp;<a href="http://python.usyiyi.cn/translate/python_278/library/os.path.html" target="_blank" rel="external">os.path</a>提供操作路径的函数。</p>
<ul>
<li><p><strong>os.path.abspath(path)</strong><br>  获取绝对路径</p>
</li>
<li><p><strong>os.path.realpath(path)</strong><br>  软连接的真实路径</p>
</li>
<li><p><strong>os.path.basename(path)</strong><br>  获取文件名，以<code>/</code>结尾的路径返回空</p>
</li>
<li><p><strong>os.path.dirname(path)</strong><br>  获取目录名</p>
</li>
<li><p><strong>os.path.exists(path)</strong><br>  判断<code>path</code>路径是否存在</p>
</li>
<li><p><strong>os.path.isfile(path) / os.path.isdir(path) / os.path.islink(path) / os.path.ismount(path)</strong><br>  判断<code>path</code>是否为文件/目录/软连接/挂载点</p>
</li>
<li><p><strong>os.path.split(path)</strong><br>  将<code>path</code>切分为<code>(目录, 文件名)</code></p>
</li>
<li><p><strong>os.path.splitext(path)</strong><br>  将<code>path</code>切分为<code>(目录/主文件名, 后缀名)</code></p>
</li>
<li><p><strong>os.path.join(path1, path2)</strong><br>  拼接路径</p>
</li>
</ul>
<p><span id="sys"></span></p>
<h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a><strong>sys</strong></h3><p>&emsp;<a href="http://python.usyiyi.cn/translate/python_278/library/sys.html" target="_blank" rel="external">sys</a>模块，主要处理Python环境的变量使得程序与系统环境有交互。</p>
<ul>
<li><strong>sys.argv[x]</strong><br>  获取命令行参数列表。<code>0</code>表示程序名，<code>1</code>表示第一个命令行第一个参数，以此类推。</li>
<li><strong>sys.exit(num)</strong><br>  程序退出状态码，<code>sys.exit(0)</code>表示正常退出。</li>
<li><strong>sys.path</strong><br>  返回模块的搜索路径。</li>
<li><strong>sys.stdout / sys.stdin / sys.stderr</strong><br>  标准输出/输入/错误输出</li>
</ul>
<p><span id="time"></span></p>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a><strong>time</strong></h3><p>&emsp;<a href="http://python.usyiyi.cn/translate/python_278/library/time.html" target="_blank" rel="external">time</a>模块主要提供和时间相关的函数。</p>
<ul>
<li><strong>time.time()</strong><br>  返回距离纪元(1970-01-01 00:00:00)开始的秒数，返回值为浮点数。</li>
<li><strong>time.ctime()</strong><br>  返回字符串型易读的时间，诸如：<code>Wed Oct  1 20:18:59 2016</code></li>
<li><strong>time.clock()</strong><br>  返回当前进程消耗的CPU时间(秒)</li>
<li><p><strong>time.gmtime() / time.localtime()</strong><br>  <code>time.gmtime()</code>和<code>time.localtime()</code>的结果都是使用<strong>struct_time</strong>格式显示，可使用<strong><code>time.asctime()</code></strong>转变成<code>time.ctime()</code>的字符串格式显示。<br>  <code>time.gmtime()</code>获取的是UTC时间，<code>time.localtime()</code>获取的是当前时区的时间。在中国：<code>time.gmtime() = time.localtime() + 8hour</code></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">time.gmtime()</span><br><span class="line"><span class="comment">#time.struct_time(tm_year=2016, tm_mon=10, tm_mday=5, tm_hour=15, tm_min=29, tm_sec=14, tm_wday=2, tm_yday=279, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">time.localtime()</span><br><span class="line"><span class="comment">#time.struct_time(tm_year=2016, tm_mon=10, tm_mday=5, tm_hour=23, tm_min=30, tm_sec=4, tm_wday=2, tm_yday=279, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">time.asctime(time.localtime())</span><br><span class="line"><span class="comment">#'Wed Oct  5 23:30:35 2016'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>time.strptime()</strong><br>  将字符串格式时间转成struct_time格式时间</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.strptime(time.ctime())</span><br><span class="line"><span class="comment">#time.struct_time(tm_year=2016, tm_mon=10, tm_mday=5, tm_hour=23, tm_min=37, tm_sec=17, tm_wday=2, tm_yday=279, tm_isdst=-1)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>time.strftime()</strong><br>  将时间格式化输出</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())</span><br><span class="line"><span class="comment">#'2016-10-05 23:39:23'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>time.sleep(num)</strong><br>  进程sleep时间</p>
</li>
</ul>
<p><span id="datetime"></span></p>
<h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a><strong>datetime</strong></h3><p>&emsp;<a href="http://python.usyiyi.cn/documents/python_278/library/datetime.html" target="_blank" rel="external">datetime</a>模块提供操作日期和时间函数。<br>&emsp;<a href="http://python.usyiyi.cn/documents/python_278/library/datetime.html" target="_blank" rel="external">datetime</a>模块常用的有四个类别，这些对象都是<strong>不可变</strong>对象：</p>
<ul>
<li><code>datetime.date</code>：用于操作日期</li>
<li><code>datetime.time</code>：用于操作时分秒</li>
<li><code>datetime.datetime</code>：用于操作日期和时分秒</li>
<li><code>datetime.timedelta</code>：用于操作时间间隔</li>
</ul>
<h4 id="datetime-date"><a href="#datetime-date" class="headerlink" title="datetime.date"></a><strong>datetime.date</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> date.today()</span><br><span class="line"><span class="comment">#2016-10-05</span></span><br><span class="line"></span><br><span class="line">now = date.today()</span><br><span class="line"><span class="comment">#2016-10-05</span></span><br><span class="line">tomorrow = now.replace(day=<span class="number">06</span>)</span><br><span class="line"><span class="comment">#2016-10-06</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#date.weekday()，星期一返回0，以此类推</span></span><br><span class="line">now.weekday()</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#date.isoformat()，返回`YYYY-MM-DD`</span></span><br><span class="line">now.isoformat()</span><br><span class="line"><span class="comment">#'2016-10-06'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#date.strftime(format)，格式化时间输出</span></span><br><span class="line">now.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line"><span class="string">'2016-10-06 00:00:00'</span></span><br></pre></td></tr></table></figure>
<h4 id="datetime-time"><a href="#datetime-time" class="headerlink" title="datetime.time"></a><strong>datetime.time</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">mytime = datetime.time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> mytime</span><br><span class="line"><span class="comment">#23:59:10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"hour: %s, minute: %s, second: %s"</span> % (mytime.hour, mytime.minute, mytime.second)</span><br><span class="line"><span class="comment">#hour: 23, minute: 59, second: 10</span></span><br><span class="line"></span><br><span class="line">mytime2 = mytime.replace(hour=<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> mytime2</span><br><span class="line"><span class="comment">#22:59:10</span></span><br></pre></td></tr></table></figure>
<h4 id="datetime-datetime"><a href="#datetime-datetime" class="headerlink" title="datetime.datetime"></a><strong>datetime.datetime</strong></h4><p><code>datetime.datetime</code>和<code>datetime.time</code>差不多<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start = datetime.datetime.now()</span><br><span class="line"><span class="comment">#2016-10-06 23:47:29.105713</span></span><br><span class="line"></span><br><span class="line">end = datetime.datetime.now()</span><br><span class="line"><span class="comment">#2016-10-06 23:47:45.449751</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (end - start).seconds</span><br><span class="line"><span class="comment">#16</span></span><br></pre></td></tr></table></figure></p>
<h4 id="datetime-timedelta"><a href="#datetime-timedelta" class="headerlink" title="datetime.timedelta"></a><strong>datetime.timedelta</strong></h4><p>&emsp;主要用于做时间的加减操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">today = datetime.datetime.today()</span><br><span class="line"><span class="comment">#2016-10-06 23:41:46.170686</span></span><br><span class="line"></span><br><span class="line">delta = datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">yesterday = today - delta</span><br><span class="line"><span class="comment">#2016-10-05 23:41:46.170686</span></span><br></pre></td></tr></table></figure></p>
<p><span id="paramiko"></span></p>
<h3 id="paramiko"><a href="#paramiko" class="headerlink" title="paramiko"></a><strong>paramiko</strong></h3><p>&emsp;<a href="http://www.paramiko.org/" target="_blank" rel="external">paramiko</a>模块提供ssh远程登录等相关功能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ssh_command</span><span class="params">(ip, username, passwd, cmd, port=<span class="number">22</span>)</span>:</span></span><br><span class="line">    <span class="string">"""paramiko demo"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    	ssh = paramiko.SSHClient()</span><br><span class="line">    	<span class="comment">#允许连接不在know_hosts文件中的主机</span></span><br><span class="line">    	ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    	ssh.connect(ip, port, username, passwd, timeout=<span class="number">30</span>)</span><br><span class="line">    	stdin, stdout, stderr = ssh.exec_command(cmd)</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">    	<span class="keyword">raise</span> <span class="string">"%s ssh connect error: %s"</span> % (ip, e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">    	ssh.close()</span><br><span class="line">    std_result = &#123;<span class="string">'stdout'</span>: stdout.readlines(),</span><br><span class="line">    			<span class="string">'stderr'</span>: stderr.readlines()</span><br><span class="line">    			&#125;</span><br><span class="line">    <span class="keyword">return</span> std_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#paramiko模块还支持sftp传输功能</span></span><br><span class="line"></span><br><span class="line">scp=paramiko.Transport((host_ip, ssh_port))</span><br><span class="line">scp.connect(username=ssh_username, password=ssh_passowrd)</span><br><span class="line">sftp=paramiko.SFTPClient.from_transport(scp)</span><br><span class="line"><span class="comment">#如果之前已有一个建立连接的ssh对象，则可直接复用该ssh连接对象</span></span><br><span class="line"><span class="comment">#sftp = paramiko.SFTPClient.from_transport(ssh.get_transport())</span></span><br><span class="line"><span class="comment">#sftp = ssh.open_sftp()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下载文件</span></span><br><span class="line">sftp.get(<span class="string">'/tmp/remote_file'</span>,<span class="string">'/tmp/local_file'</span>)</span><br><span class="line"><span class="comment">#上传文件</span></span><br><span class="line">sftp.put(<span class="string">'/home/local_file'</span>,<span class="string">'/tmp/remote_file'</span>)</span><br><span class="line">scp.close()</span><br></pre></td></tr></table></figure></p>
<p><span id="subprocess"></span></p>
<h3 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a><strong>subprocess</strong></h3><p>&emsp;<a href="http://python.usyiyi.cn/python_278/library/subprocess.html" target="_blank" rel="external">subprocess</a>模块允许创建新进程并获取返回值/输出信息，常用来调用系统命令。<br>&emsp;常用已封装好的函数有三个：</p>
<ul>
<li><strong>subprocess.call()</strong><br>  返回<strong>exit code</strong>。不管<code>exit code</code>是什么都不会抛出异常。</li>
<li><strong>subprocess.check_call()</strong><br>  返回<strong>exit code</strong>并检查<strong>exit code</strong>。<code>exit code</code>为<code>0</code>则成功，否则抛出<code>subprocess.CalledProcessError</code>异常。</li>
<li><strong>subprocess.check_output()</strong><br>  返回输出信息且检查<strong>exit code</strong>。<code>exit code</code>不为0则抛出<code>subprocess.CalledProcessError</code>异常。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果相同，返回的是exit code</span></span><br><span class="line">subprocess.call([<span class="string">'echo'</span>, <span class="string">'test'</span>])</span><br><span class="line">subprocess.call(<span class="string">"echo test"</span>, shell=<span class="keyword">True</span>)</span><br><span class="line">subprocess.check_call([<span class="string">'echo'</span>, <span class="string">'test'</span>])</span><br><span class="line"><span class="comment">#test</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回的是输出信息</span></span><br><span class="line">subprocess.check_output([<span class="string">'echo'</span>, <span class="string">'test'</span>])</span><br><span class="line"><span class="comment">#'test\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可用shlex模块解析参数而不使用`shell=True`</span></span><br><span class="line">subprocess.call(shlex.split(<span class="string">"echo test"</span>))</span><br><span class="line"><span class="comment">#test</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#忽略输出，只获取exit code</span></span><br><span class="line"><span class="keyword">with</span> open(os.devnull, <span class="string">'w'</span>) <span class="keyword">as</span> devnull:</span><br><span class="line">    exit_code = subprocess.call([<span class="string">"echo"</span>, <span class="string">"test"</span>], stdout=devnull, stderr=devnull, shell=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="subprocess-Popen"><a href="#subprocess-Popen" class="headerlink" title="subprocess.Popen()"></a><strong>subprocess.Popen()</strong></h4><p>&emsp;<code>subprocess.call</code>、<code>subprocess.check_call</code>和<code>subprocess.check_output</code>都是基于<code>subprocess.Popen()</code>的封装。在创建了<code>Popen</code>对象后，父进程不会主动等待子进程需要调用<code>wait()</code>方法使其等待。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subprocess.Popen(<span class="string">'ps aux|grep ipython'</span>, shell=<span class="keyword">True</span>).wait()</span><br><span class="line"><span class="comment">#命令输出</span></span><br><span class="line"><span class="comment">#=&gt;mogl     28580  0.0  0.3  32568 15332 pts/26   Sl+  16:35   0:01 /usr/bin/python /usr/local/bin/ipython</span></span><br><span class="line"><span class="comment">#返回值</span></span><br><span class="line"><span class="comment">#=&gt;0</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;可使用<strong><code>subprocess.PIPE</code></strong>改变输入输出对象并获取子进程的更详细信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">child = subprocess.Popen(<span class="string">'ps aux|grep ipython'</span>, shell=<span class="keyword">True</span>, stdout=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line">child.pid</span><br><span class="line"><span class="comment">#25556</span></span><br><span class="line"></span><br><span class="line">child.stdout.readlines()</span><br><span class="line"><span class="comment">#mogl     28580  0.0  0.3  32568 15332 pts/26   Sl+  16:35   0:01 /usr/bin/python /usr/local/bin/ipython</span></span><br><span class="line"></span><br><span class="line">child.poll</span><br><span class="line"><span class="comment">#检查子进程是否已终止。没终止返回空，终止返回exit code</span></span><br><span class="line"></span><br><span class="line">child.wait()</span><br><span class="line"><span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">child.returncode</span><br><span class="line"><span class="comment">#0</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;<strong><code>subprocess.PIPE</code></strong>还可以将多个子进程的输入输出连接<br>&emsp;<code>communicate()</code>是Popen对象的方法，该方法会阻塞父进程，直到子进程完成。<code>child2</code>的输出也在PIPE中，需要调用<code>child2.communicate()</code>读取。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child1 = subprocess.Popen([<span class="string">"ls"</span>,<span class="string">"-l"</span>], stdout=subprocess.PIPE)</span><br><span class="line">child2 = subprocess.Popen([<span class="string">"wc"</span>], stdin=child1.stdout,stdout=subprocess.PIPE)</span><br><span class="line">out = child2.communicate()</span><br></pre></td></tr></table></figure></p>
<p><span id="functools"></span></p>
<h3 id="functools"><a href="#functools" class="headerlink" title="functools"></a><strong>functools</strong></h3><p>&emsp;<a href="http://python.usyiyi.cn/python_278/library/functools.html" target="_blank" rel="external">functools</a>提供高阶函数功能。主要包含<code>cmp_to_key</code>、<code>partial</code>、<code>reduce</code>、<code>total_ordering</code>、<code>update_wrapper</code>和<code>wraps</code>这几个函数。</p>
<ul>
<li><p><strong>functools.cmp_to_key(func)</strong><br>  <code>functools.cmp_to_key()</code>是Python2.7新增的函数，用于将比较函数转成key函数，需要在接受key函数作为参数的函数中才使用。其实是为了兼容Python3，拿<code>sorted()</code>函数为例：Python2版本的<code>sorted()</code>函数支持<code>cmp</code>参数来处理用户自定义的排序函数，但Python3后将<code>cmp</code>参数移除了，所以需要使用到<code>cmp_to_key</code>将自定义的排序函数转成key函数</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python2</span></span><br><span class="line">sorted([<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>], cmp=<span class="keyword">lambda</span> x, y: y-x)</span><br><span class="line"><span class="comment">#=&gt;[5, 4, 3, 2, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Python3</span></span><br><span class="line">sorted([<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>], key=cmp_to_key(<span class="keyword">lambda</span> x, y: y-x))</span><br><span class="line"><span class="comment">#=&gt;[5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>functools.total_ordering(cls)</strong><br>  <code>functools.total_ordering()</code>也是Python2.7新增的函数，主要用于简化比较函数的写法。当某个类定义了<strong><code>__eq__()</code></strong>方法，并且定义了<strong><code>__lt__()</code></strong>、<strong><code>__le__()</code></strong>、<strong><code>__gt__()</code></strong>或<strong><code>__ge__()</code></strong>方法中的<strong>其中一个</strong>，若使用<strong><code>@total_ordering()</code></strong>装饰器，则该类会自动生成其他的比较方法。<br>  官方例子：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> total_ordering</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@total_ordering</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> ((self.lastname.lower(), self.firstname.lower()) ==</span><br><span class="line">				(other.lastname.lower(), other.firstname.lower()))</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> ((self.lastname.lower(), self.firstname.lower()) &lt;</span><br><span class="line">				(other.lastname.lower(), other.firstname.lower()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> dir(Student)</span><br><span class="line"><span class="comment">#=&gt;['__doc__', '__eq__', '__ge__', '__gt__', '__le__', '__lt__', '__module__']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>functools.reduce(function, iterable)</strong><br>  <code>functools.reduce()</code>和内置的<code>reduce()</code>功能一样，使用<code>functools.reduce()</code>也是为了兼容Python3。</p>
</li>
<li><p><strong>functools.partial(func[,*args][, </strong>keywords])**<br>  <code>functools.partial()</code>简单的说就是实现<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="external">柯里化</a>的。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">add_y = partial(add, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> add_y(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#=&gt;2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>functools.wraps(wrapped[, assigned][, updated])</strong><br>  <code>functools.wraps()</code>主要的作用是消除Python中装饰器带来的一些副作用。Python中使用装饰器，被装饰函数的<code>__name__</code>属性会被改变，需要用<code>functools.wraps()</code>进行修正。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="comment">#@wraps(func)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">"In decorator wrapper func."</span></span><br><span class="line">		<span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="decorator">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"In test func."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> test.__name__</span><br><span class="line"><span class="comment">#=&gt;wrapper</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>functools.update_wrapper(wrapper, wrapped[, assigned][, updated])</strong><br>  <code>functools.wraps()</code>是<code>functools.update_wrapper()</code>的简化版本，<code>functools.update_wrapper()</code>功能更强大，默认会将被装饰函数的<code>functools.WRAPPER_ASSIGNMENTS</code>(<code>__module__</code>、<code>__name__</code>、<code>__doc__</code>)和<code>functools.WRAPPER_UPDATES</code>(<code>__dict__</code>)都复制给装饰函数。<br>  实际上面的装饰器代码可用<code>update_wrapper()</code>写：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> update_wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">"In decorator wrapper func."</span></span><br><span class="line">       <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> update_wrapper(wrapper, func)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><span id="smtplib"></span></p>
<h3 id="smtplib"><a href="#smtplib" class="headerlink" title="smtplib"></a><strong>smtplib</strong></h3><p>&emsp;<a href="http://python.usyiyi.cn/python_278/library/smtplib.html" target="_blank" rel="external">smtplib</a>模块用于发送邮件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(send_list, subject, content)</span>:</span></span><br><span class="line">	<span class="string">"""html/text邮件"""</span></span><br><span class="line">	mail_host = <span class="string">"your_smtp_server_address"</span></span><br><span class="line">	mail_user = <span class="string">'your_email_user(xxx@gmail.com)'</span></span><br><span class="line">	mail_passwd = <span class="string">'your_email_password'</span></span><br><span class="line">	mail_port = <span class="number">25</span></span><br><span class="line">	send_from = <span class="string">"your_send_from"</span> + <span class="string">"&lt;"</span> + mail_user + <span class="string">"&gt;"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">##TEXT邮件</span></span><br><span class="line">	<span class="comment">#msg = MIMEText(content, _subtype='plain', _charset='utf-8')</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">##HTML邮件</span></span><br><span class="line">	<span class="comment">#msg = MIMEText(content, _subtype='html', _charset='utf-8')</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">##带附件邮件</span></span><br><span class="line">    msg = MIMEMultipart()</span><br><span class="line">    <span class="comment">#邮件正文</span></span><br><span class="line">    msg.attach(MIMEText(content, _charset=<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="comment">#附件一</span></span><br><span class="line">    att_1 = MIMEText(open(<span class="string">'/tmp/attachment1.txt'</span>, <span class="string">'rb'</span>).read(), <span class="string">'base64'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    att_1[<span class="string">'Content-Type'</span>] = <span class="string">'application/octet-stream'</span></span><br><span class="line">    <span class="comment">#邮件中附件显示的文件名字</span></span><br><span class="line">    att_1[<span class="string">'Content-Disposition'</span>] = <span class="string">'attachment; filename=%s'</span> % <span class="string">"附件1"</span></span><br><span class="line">    msg.attach(att_1)</span><br><span class="line"></span><br><span class="line">	msg[<span class="string">'From'</span>] = send_from</span><br><span class="line">	msg[<span class="string">'Subject'</span>] = subject</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		mail_server = smtplib.SMTP()</span><br><span class="line">		mail_server.connect(mail_host, mail_port)</span><br><span class="line">		mail_server.login(mail_user, mail_passwd)</span><br><span class="line">		mail_server.sendmail(msg[<span class="string">'From'</span>], send_list, msg.as_string())</span><br><span class="line">		mail_server.close()</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">except</span> Exception, e:</span><br><span class="line">		<span class="keyword">print</span> str(e)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p><span id="requests"></span></p>
<h3 id="requests"><a href="#requests" class="headerlink" title="requests"></a><strong>requests</strong></h3><p>&emsp;<a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="external">requests</a>是第三方模块，相比Python内置的<code>urlib2</code>更人性化。<br>&emsp;由于<a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="external">requests</a>是第三方模块，需要使用<code>pip</code>进行安装，在一些版本中可能会在使用中出现<code>SNIMissingWarning</code>和<code>InsecurePlatformWarning</code>警告，可按以下方法安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum install -y openssl-devel python-devel libffi-devel</span><br><span class="line">pip install <span class="string">'requests[security]'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#若在使用中出现SNIMissingWarning和InsecurePlatformWarning警告可</span></span><br><span class="line">pip install pyopenssl ndg-httpsclient pyasn1</span><br><span class="line"></span><br><span class="line"><span class="comment">#若不想额外安装包可手动忽略警告</span></span><br><span class="line"><span class="comment">#关闭requests的https警告</span></span><br><span class="line">try:</span><br><span class="line">    from requests.packages.urllib3.exceptions import (</span><br><span class="line">        SNIMissingWarning,</span><br><span class="line">        InsecureRequestWarning,</span><br><span class="line">        InsecurePlatformWarning</span><br><span class="line">    )</span><br><span class="line">    requests.packages.urllib3.disable_warnings(SNIMissingWarning)</span><br><span class="line">    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class="line">    requests.packages.urllib3.disable_warnings(InsecurePlatformWarning)</span><br><span class="line">except ImportError:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>&emsp;<a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="external">requests</a>常用方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://github.com/timeline.json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#GET请求(10s超时)</span></span><br><span class="line">r = requests.get(url, timeout=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#文本方式显示</span></span><br><span class="line"><span class="keyword">print</span> r.text</span><br><span class="line"><span class="comment">#字节方式显示，中文显示为字符</span></span><br><span class="line"><span class="keyword">print</span> r.content</span><br><span class="line"><span class="comment">#显示编码 &amp; 设置编码</span></span><br><span class="line"><span class="keyword">print</span> r.encoding</span><br><span class="line">r.encoding = <span class="string">'utf-8'</span></span><br><span class="line"><span class="comment">#响应状态码</span></span><br><span class="line">r.status_code</span><br><span class="line"><span class="comment">#HTTP header</span></span><br><span class="line">r.headers</span><br><span class="line">r.headers[<span class="string">'Content-Type'</span>]</span><br><span class="line"><span class="comment">#JSON化，失败会抛出异常</span></span><br><span class="line">r.json()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#POST请求</span></span><br><span class="line">headers = &#123;</span><br><span class="line">	<span class="string">'content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">	<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">	<span class="string">"mobile"</span>: mobile,</span><br><span class="line">	<span class="string">"templateId"</span>: template_id,</span><br><span class="line">	<span class="string">"templateVariable"</span>: &#123;</span><br><span class="line">		self.mobile: &#123;</span><br><span class="line">			<span class="string">"secode"</span>: vcode</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"userName"</span>: user_name,</span><br><span class="line">	<span class="string">"randomKey"</span>: random_key,</span><br><span class="line">	<span class="string">"fingerprint"</span>: fingerprint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	r = requests.post(url, data=json.dumps(data), headers=headers)</span><br><span class="line">	result = r.json()</span><br><span class="line">	<span class="comment">#result = json.loads(r.content)</span></span><br><span class="line"><span class="keyword">except</span> Exception, err:</span><br><span class="line">	<span class="keyword">raise</span> err</span><br></pre></td></tr></table></figure></p>
<p><span id="hashlib"></span></p>
<h3 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a><strong>hashlib</strong></h3><p>&emsp;<a href="http://python.usyiyi.cn/python_278/library/hashlib.html" target="_blank" rel="external">hashlib</a>模块实现各种hash算法。<a href="http://python.usyiyi.cn/python_278/library/hashlib.html" target="_blank" rel="external">hashlib</a>基于OpenSSL，支持<code>md5</code>、<code>sha1</code>、<code>sha224</code>、<code>sha256</code>、<code>sha384</code>和<code>sha512</code>等算法。<br>&emsp;基本用法。<code>update()</code>可多次调用，每次都会根据新增文本更新结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">mystr = <span class="string">'mogl'</span></span><br><span class="line"></span><br><span class="line">mymd5 = hashlib.md5()</span><br><span class="line">mymd5.update(mystr)</span><br><span class="line"><span class="keyword">print</span> mymd5.hexdigest()</span><br><span class="line"><span class="comment">#=&gt;d2624edb33f3be2c461b1e95740b6b5c</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;用<code>new()</code>方法通过字符串形式指定算法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">hash_name = sys.argv[<span class="number">1</span>]</span><br><span class="line">myhash = hashlib.new(hash_name)</span><br><span class="line">myhash.update(mystr)</span><br><span class="line"><span class="keyword">print</span> myhash.hexdigest()</span><br></pre></td></tr></table></figure></p>
<p><span id="multiprocessing"></span></p>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a><strong>multiprocessing</strong></h3><p>&emsp;<a href="http://python.usyiyi.cn/python_278/library/multiprocessing.html" target="_blank" rel="external">multiprocessing</a>模块提供多进程编程。</p>
<ul>
<li><p><strong>multiprocessing.Process</strong><br>  &emsp;<code>Process</code>类的原型<code>multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={})</code>。每个<code>Process</code>类会生成一个<code>process</code>对象并在新的进程中运行。<br>  &emsp;每个<code>process</code>对象<strong>最多只能调用一次<code>start()</code>方法</strong>，<code>join([timeout])</code>方法会阻塞调用<code>process</code>对象的进程等待子进程执行完毕。</p>
<ul>
<li><code>group</code>：仅为兼容<code>threading.Thread</code>，通常为<code>None</code></li>
<li><code>target</code>：子进程要执行的函数</li>
<li><code>name</code>：进程名，默认为<code>Process-1</code>、<code>Process-2...</code></li>
<li><code>args</code>：<code>target</code>函数调用的参数</li>
<li><p><code>kwargs</code>：<code>target</code>函数调用的字典参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child_run</span><span class="params">(name)</span>:</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">"Run in child process name: %s, pid: %s"</span> % (name, os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"Parent process pid: %s"</span> % os.getpid()</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"Creating child process..."</span></span><br><span class="line">       <span class="comment">#注意args参数中必须有,</span></span><br><span class="line">       multi_proc = Process(target=child_run, args=(<span class="string">'child_test'</span>,))</span><br><span class="line">	<span class="comment">#设置daemon属性</span></span><br><span class="line">	<span class="comment">#multi_proc.daemon = True</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">"Starting child process..."</span></span><br><span class="line">       multi_proc.start()</span><br><span class="line">       multi_proc.join()</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"Process end."</span></span><br><span class="line"><span class="comment">#Parent process pid: 12198</span></span><br><span class="line"><span class="comment">#Creating child process...</span></span><br><span class="line"><span class="comment">#Starting child process...</span></span><br><span class="line"><span class="comment">#Run in child process name: child_test, pid: 12199</span></span><br><span class="line"><span class="comment">#Process end.</span></span><br></pre></td></tr></table></figure>
<p>&emsp;多进程并行运行。每个子进程都是先<code>start()</code>，最后在一起<code>join()</code>。若对每个<code>process</code>对象都一起执行<code>start()</code>和<code>join()</code>则变成顺序执行而非并发执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line">   <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">child_run</span><span class="params">(name)</span>:</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">"Run in child process name: %s, pid: %s"</span> % (name, os.getpid())</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">       names = [<span class="string">'mo'</span>, <span class="string">'guo'</span>, <span class="string">'liang'</span>, <span class="string">'mogl'</span>]</span><br><span class="line">       proc_list = []</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"Parent process pid: %s"</span> % os.getpid()</span><br><span class="line">       <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">           multi_proc = Process(target=child_run, args=(name,))</span><br><span class="line">           proc_list.append(multi_proc)</span><br><span class="line">           multi_proc.start()</span><br><span class="line">       <span class="keyword">for</span> each_child_proc <span class="keyword">in</span> proc_list:</span><br><span class="line">           each_child_proc.join()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Parent process pid: 14516</span></span><br><span class="line"><span class="comment">#Run in child process name: mo, pid: 14517</span></span><br><span class="line"><span class="comment">#Run in child process name: guo, pid: 14518</span></span><br><span class="line"><span class="comment">#Run in child process name: liang, pid: 14519</span></span><br><span class="line"><span class="comment">#Run in child process name: mogl, pid: 14520</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>multiprocessing.Lock</strong><br>  &emsp;<code>multiprocessing.Lock</code>提供锁功能，当多进程需要访问共享资源时，可用锁来避免冲突。使用锁的话多进程并行则会受到锁的限制。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line">   <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">(string)</span>:</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">"In printer, string: %s, pid: %s"</span> % (string, os.getpid())</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">printer_lock</span><span class="params">(string, lock)</span>:</span></span><br><span class="line">       lock.acquire()</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"In printer, string: %s, pid: %s"</span> % (string, os.getpid())</span><br><span class="line">       lock.release()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">       proc_list = []</span><br><span class="line">       names = [<span class="string">'mo'</span>, <span class="string">'guo'</span>, <span class="string">'liang'</span>, <span class="string">'mogl'</span>]</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"Parent pid: %s"</span> % os.getpid()</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> each_name <span class="keyword">in</span> names:</span><br><span class="line">           multi_proc = Process(target=printer, args=(each_name,))</span><br><span class="line">           proc_list.append(multi_proc)</span><br><span class="line">           multi_proc.start()</span><br><span class="line"></span><br><span class="line">       lock = Lock()</span><br><span class="line">       <span class="keyword">for</span> each_name <span class="keyword">in</span> names:</span><br><span class="line">           multi_proc_lock = Process(target=printer_lock, args=(each_name, lock))</span><br><span class="line">           proc_list.append(multi_proc_lock)</span><br><span class="line">           multi_proc_lock.start()</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> each_proc <span class="keyword">in</span> proc_list:</span><br><span class="line">           each_proc.join()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Parent pid: 9313</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#In printer, string: mo, pid: 9314</span></span><br><span class="line"><span class="comment">#In printer, string: liang, pid: 9316</span></span><br><span class="line"><span class="comment">#In printer, string: guo, pid: 9315</span></span><br><span class="line"><span class="comment">#In printer, string: mogl, pid: 9317</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#In printer, string: mo, pid: 9318</span></span><br><span class="line"><span class="comment">#In printer, string: guo, pid: 9319</span></span><br><span class="line"><span class="comment">#In printer, string: liang, pid: 9320</span></span><br><span class="line"><span class="comment">#In printer, string: mogl, pid: 9321</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>multiprocessing.Queue &amp; multiprocessing.Pipe</strong><br>  &emsp;<code>multiprocessing</code>支持两种进程间通信方式：<strong><code>Queue</code></strong>、<strong><code>PIPE</code></strong>，<code>Queue</code>是进程安全的。</p>
<ul>
<li><p><strong>multiprocessing.Queue</strong><br>  &emsp;使用<code>Queue</code>实现进程间通信，进程A使用<code>put()</code>方法将数据存入<code>Queue</code>，进程B使用<code>get()</code>方法从<code>Queue</code>中读取数据。<br>  &emsp;<code>put()</code>、<code>get()</code>方法都有两个参数：<strong><code>block</code></strong>、<strong><code>timeout</code></strong>，若<code>block=False</code>，Queue为<code>full</code>/<code>empty</code>则抛出异常，若设置了<code>timeout</code>则阻塞等待再一次<code>put</code>/<code>get</code>。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line">      <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">write_queue</span><span class="params">(queue)</span>:</span></span><br><span class="line">          <span class="keyword">print</span> <span class="string">"In write_queue pid: %s"</span> % os.getpid()</span><br><span class="line">          queue.put([<span class="string">'mogl'</span>], block=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">read_queue</span><span class="params">(queue)</span>:</span></span><br><span class="line">          <span class="keyword">print</span> <span class="string">"In read_queue pid: %s"</span> % os.getpid()</span><br><span class="line">          <span class="keyword">print</span> queue.get(block=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">          <span class="keyword">print</span> <span class="string">"Parent pid: %s"</span> % os.getpid()</span><br><span class="line">          queue = Queue()</span><br><span class="line"></span><br><span class="line">          write_proc = Process(target=write_queue, args=(queue,))</span><br><span class="line">          write_proc.start()</span><br><span class="line"></span><br><span class="line">          read_proc = Process(target=read_queue, args=(queue,))</span><br><span class="line">          read_proc.start()</span><br><span class="line"></span><br><span class="line">          write_proc.join()</span><br><span class="line">          read_proc.join()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Parent pid: 18383</span></span><br><span class="line"><span class="comment">#In write_queue pid: 18384</span></span><br><span class="line"><span class="comment">#In read_queue pid: 18385</span></span><br><span class="line"><span class="comment">#['mogl']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>multiprocessing.Pipe</strong><br>  &emsp;<code>Pipe()</code>方法会返回<code>(c1, c2)</code>代表一个管道的两端，默认<code>Pipe()</code>的<code>duplex=True</code>表示全双工管道，即管道的任意一端都可发送和接收信息。若<code>duplex=False</code>则<code>c1</code>只负责接收，<code>c2</code>只负责发送。当调用<code>recv()</code>方法从管道读取消息时候，若管道一端无消息，<code>recv()</code>则会<strong>一直阻塞</strong>。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line">      <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">process_one</span><span class="params">(pipe)</span>:</span></span><br><span class="line">          pipe.send(<span class="string">'hello, process_one send message.'</span>)</span><br><span class="line">          <span class="keyword">print</span> <span class="string">'process_one receive message:'</span>, pipe.recv()</span><br><span class="line">          <span class="keyword">print</span> <span class="string">"process_one pid:"</span>, os.getpid()</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">process_two</span><span class="params">(pipe)</span>:</span></span><br><span class="line">          <span class="keyword">print</span> <span class="string">'process_two receive message:'</span>, pipe.recv()</span><br><span class="line">          pipe.send(<span class="string">'hello, process_two send message.'</span>)</span><br><span class="line">          <span class="keyword">print</span> <span class="string">"process_two pid:"</span>, os.getpid()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">          pipe = Pipe()</span><br><span class="line"></span><br><span class="line">          <span class="keyword">print</span> <span class="string">"main pid:"</span>, os.getpid()</span><br><span class="line">          pro1 = Process(target=process_one, args=(pipe[<span class="number">0</span>],))</span><br><span class="line">          pro2 = Process(target=process_two, args=(pipe[<span class="number">1</span>],))</span><br><span class="line"></span><br><span class="line">          pro1.start()</span><br><span class="line">          pro2.start()</span><br><span class="line">          pro1.join()</span><br><span class="line">          pro2.join()</span><br><span class="line"></span><br><span class="line"><span class="comment">#process_one发送消息后recv，由于管道一端无消息而阻塞，故先打印process_two的内容</span></span><br><span class="line"><span class="comment">#main pid: 14215</span></span><br><span class="line"><span class="comment">#process_two receive message: hello, process_one send message.</span></span><br><span class="line"><span class="comment">#process_two pid: 14217</span></span><br><span class="line"><span class="comment">#process_one receive message: hello, process_two send message.</span></span><br><span class="line"><span class="comment">#process_one pid: 14216</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>multiprocessing.Pool</strong><br>  &emsp;Python多进程支持进程池，使用<code>multiprocessing.Pool</code>能创建一个进程池可指定进程数量，当请求提交给pool后，若pool没满则可创建新进程处理该请求，若已满则等待空闲后再处理。<br>  &emsp;进程池中进程的创建可通过<code>apply_async(func[, args[, kwds[, callback]]])</code>或<code>apply(func[, args[, kwds]])</code>方法。<code>apply_async()</code>是<strong>非阻塞</strong>，<code>apply()</code>是<strong>阻塞</strong>(进程池中一个进程执行完才会执行下一个)。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line">  <span class="keyword">import</span> os</span><br><span class="line">  <span class="keyword">import</span> time</span><br><span class="line">  <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">child_process_task</span><span class="params">(name)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> <span class="string">"Running task %s, pid %s"</span> % (name, os.getpid())</span><br><span class="line">      start_time = time.time()</span><br><span class="line">      time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">      end_time = time.time()</span><br><span class="line">      <span class="keyword">print</span> <span class="string">"Task %s is over and runs %0.2f seconds."</span> % (name, (end_time - start_time))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">      <span class="keyword">print</span> <span class="string">"Parrent process pid %s"</span> % os.getpid()</span><br><span class="line">      <span class="comment">#创建进场池。限制并发数量：child_pool = Pool(processes=4)</span></span><br><span class="line">      child_pool = Pool()</span><br><span class="line">      <span class="keyword">for</span> eachpid <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">          <span class="comment">#批量创建子进场(指定执行函数及其参数)</span></span><br><span class="line">          child_pool.apply_async(child_process_task, args=(eachpid,))</span><br><span class="line">      <span class="keyword">print</span> <span class="string">"Waitting for all child process done..."</span></span><br><span class="line"><span class="comment">#调用join()前必须先调用close()。close()关闭pool不在接受新请求。join()等待所有子进程结束</span></span><br><span class="line">      child_pool.close()</span><br><span class="line">      child_pool.join()</span><br><span class="line">      <span class="keyword">print</span> <span class="string">"All process is done."</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><span id="MySQLdb"></span></p>
<h3 id="MySQLdb"><a href="#MySQLdb" class="headerlink" title="MySQLdb"></a><strong>MySQLdb</strong></h3><p>&emsp;<a href="http://mysql-python.sourceforge.net/MySQLdb.html" target="_blank" rel="external">MySQLdb</a>是第三方模块，用于连接及操作MySQL。<br>&emsp;一般先使用<code>MySQLdb.connect()</code>方法创建连接对象，该连接对象支持事务操作，即允许<code>commit()</code>和<code>rollback()</code>。然后使用<code>cursor()</code>方法获取游标对象，该对象做两类操作——<strong>执行sql</strong>和<strong>获取查询结果</strong>。最后操作完数据库后需要调用<code>close()</code>方法关闭相关对象。</p>
<h4 id="执行sql"><a href="#执行sql" class="headerlink" title="执行sql"></a><strong>执行sql</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line">create_sql = <span class="string">"""CREATE TABLE STUDENT (</span><br><span class="line">        NAME  CHAR(20) NOT NULL,</span><br><span class="line">        AGE INT,</span><br><span class="line">        GENDER CHAR(10))"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    db_conn = MySQLdb.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'fate'</span>, db=<span class="string">'test'</span>, port=<span class="number">3306</span>)</span><br><span class="line">    db_cur = db_conn.cursor()</span><br><span class="line">    db_cur.execute(create_sql)</span><br><span class="line"><span class="keyword">except</span> Exception, e:</span><br><span class="line">    <span class="keyword">raise</span> e</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    db_cur.close()</span><br><span class="line">    db_conn.close()</span><br></pre></td></tr></table></figure>
<p>&emsp;更新(update)、删除(delete)和插入(insert)等支持事务操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">insert_sql = <span class="string">'INSERT INTO STUDENT(NAME, AGE, GENDER)\</span><br><span class="line">    VALUES ("%s", "%s", "%s")'</span> % (<span class="string">'mogl'</span>, <span class="number">10</span>, <span class="string">'male'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    db_conn = MySQLdb.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'fate'</span>, db=<span class="string">'test'</span>, port=<span class="number">3306</span>)</span><br><span class="line">    db_cur = db_conn.cursor()</span><br><span class="line">    db_cur.execute(insert_sql)</span><br><span class="line">    db_conn.commit()</span><br><span class="line"><span class="keyword">except</span> Exception, e:</span><br><span class="line">    db_conn.rollback()</span><br><span class="line">    <span class="keyword">raise</span> e</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    db_cur.close()</span><br><span class="line">    db_conn.close()</span><br></pre></td></tr></table></figure></p>
<h4 id="获取查询结果"><a href="#获取查询结果" class="headerlink" title="获取查询结果"></a><strong>获取查询结果</strong></h4><p>&emsp;使用<code>fetchall()</code>返回<code>select</code>查询的所有结果，默认每行结果以<strong>元组</strong>形式返回，可使用<strong><code>cursorclass=MySQLdb.cursors.DictCursor</code></strong>返回<strong>字典</strong>形式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select_sql = <span class="string">"select * from STUDENT"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    db_conn = MySQLdb.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'fate'</span>, db=<span class="string">'test'</span>, port=<span class="number">3306</span>)</span><br><span class="line">    db_cur = db_conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)</span><br><span class="line">    db_cur.execute(select_sql)</span><br><span class="line">    select_result = db_cur.fetchall()</span><br><span class="line"><span class="keyword">except</span> Exception, e:</span><br><span class="line">    <span class="keyword">raise</span> e</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    db_cur.close()</span><br><span class="line">    db_conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> select_result:</span><br><span class="line">    <span class="keyword">print</span> row[<span class="string">'NAME'</span>], row[<span class="string">'AGE'</span>], row[<span class="string">'GENDER'</span>]</span><br></pre></td></tr></table></figure></p>
<p><span id="ConfigParser"></span></p>
<h3 id="ConfigParser"><a href="#ConfigParser" class="headerlink" title="ConfigParser"></a><strong>ConfigParser</strong></h3><p>&emsp;<a href="http://python.usyiyi.cn/python_278/library/configparser.html" target="_blank" rel="external">ConfigParser</a>模块用来解析类似ini格式的配置文件。<br>&emsp;ini格式配置文件大致如下：</p>
<ul>
<li><code>section</code>：<code>[test1]</code>、<code>[test2]</code></li>
<li><code>option</code>：<code>section</code>下所有的键</li>
<li><code>items</code>：<code>section</code>下所有的键值对<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test.cfg</span></span><br><span class="line"></span><br><span class="line">[test1]</span><br><span class="line">name = mogl</span><br><span class="line">passwd = <span class="number">1234</span></span><br><span class="line"></span><br><span class="line">[test2]</span><br><span class="line">name = moguoliang</span><br><span class="line">passwd = <span class="number">4321</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ConfigParser</span><br><span class="line"></span><br><span class="line">config_file = <span class="string">'test.cfg'</span></span><br><span class="line">parser = ConfigParser.SafeConfigParser()</span><br><span class="line"><span class="comment">#parser.read(config_file)</span></span><br><span class="line"><span class="keyword">with</span> open(config_file, <span class="string">'r'</span>) <span class="keyword">as</span> cfg:</span><br><span class="line">    parser.readfp(cfg)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读操作</span></span><br><span class="line"><span class="keyword">print</span> parser.sections()</span><br><span class="line"><span class="comment">#['test1', 'test2', 'test3']</span></span><br><span class="line"><span class="keyword">print</span> parser.options(<span class="string">'test1'</span>)</span><br><span class="line"><span class="comment">#['name', 'passwd']</span></span><br><span class="line"><span class="keyword">print</span> parser.items(<span class="string">'test1'</span>)</span><br><span class="line"><span class="comment">#[('name', 'mogl'), ('passwd', '1234')]</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> parser.items(<span class="string">'test1'</span>):</span><br><span class="line">    <span class="keyword">print</span> key, value</span><br><span class="line"><span class="keyword">print</span> parser.get(<span class="string">'test1'</span>, <span class="string">'name'</span>)</span><br><span class="line"><span class="comment">#mogl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写操作</span></span><br><span class="line">parser.set(<span class="string">'test2'</span>, <span class="string">'passwd'</span>, <span class="string">'1234'</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'test3'</span> <span class="keyword">not</span> <span class="keyword">in</span> parser.sections():</span><br><span class="line">    parser.add_section(<span class="string">'test3'</span>)</span><br><span class="line">    parser.set(<span class="string">'test3'</span>, <span class="string">'name'</span>, <span class="string">'mogltest'</span>)</span><br><span class="line"><span class="keyword">with</span> open(config_file, <span class="string">'w'</span>) <span class="keyword">as</span> cfg:</span><br><span class="line">    parser.write(cfg)</span><br></pre></td></tr></table></figure>
<p><span id="lxml"></span></p>
<h3 id="lxml"><a href="#lxml" class="headerlink" title="lxml"></a><strong>lxml</strong></h3><p>&emsp;<a href="">lxml</a>用于解析xml或html，用法比较复杂，这里只记录自己用到的简单功能。</p>
<ul>
<li><p><strong>cssselect()</strong></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例一</span></span><br><span class="line">page = <span class="string">'&lt;img class="BDE_Image" src="http://test.com/test.jpg" width="560" height="323"&gt;'</span></span><br><span class="line">doc = html.fromstring(page)</span><br><span class="line"><span class="keyword">for</span> index, content <span class="keyword">in</span> enumerate(doc.cssselect(<span class="string">'img.BDE_Image'</span>)):</span><br><span class="line">	img_src = content.attrib[<span class="string">'src'</span>]</span><br><span class="line">	<span class="keyword">print</span> index, img_src</span><br><span class="line"><span class="comment">#0 http://test.com/test.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实例二</span></span><br><span class="line"></span><br><span class="line">page = <span class="string">"""</span><br><span class="line">	&lt;div class="buyer-name"&gt;mogl&lt;/div&gt;</span><br><span class="line">	&lt;span class="item-price" src='http://test.com/test.html'&gt;$2.9&lt;/span&gt;</span><br><span class="line">	&lt;span class="item-price" src='http://test.com/test2.html'&gt;$3.0&lt;/span&gt;</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line">htmlDoc = html.fromstring(page)</span><br><span class="line"></span><br><span class="line">buyers = htmlDoc.cssselect(<span class="string">'div.buyer-name'</span>)</span><br><span class="line">prices = htmlDoc.cssselect(<span class="string">'span.item-price'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> eachBuyer <span class="keyword">in</span> htmlDoc.cssselect(<span class="string">'div.buyer-name'</span>):</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"buyer:"</span>, eachBuyer.text_content()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> eachPrice <span class="keyword">in</span> htmlDoc.cssselect(<span class="string">'span.item-price'</span>):</span><br><span class="line">	<span class="keyword">print</span> eachPrice.text_content()</span><br><span class="line">	<span class="keyword">print</span> eachPrice.attrib[<span class="string">'src'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#buyer: mogl</span></span><br><span class="line"><span class="comment">#$2.9</span></span><br><span class="line"><span class="comment">#http://test.com/test.html</span></span><br><span class="line"><span class="comment">#$3.0</span></span><br><span class="line"><span class="comment">#http://test.com/test2.html</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>xpath</strong><br>  &emsp;先简单记录<code>xpath</code>的路径表达式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th></th>
<th></th>
<th style="text-align:center">实例</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/</td>
<td></td>
<td></td>
<td style="text-align:center">xpath(‘/div’)</td>
<td style="text-align:left">从根节点选取<code>div</code>节点</td>
</tr>
<tr>
<td style="text-align:center">//</td>
<td></td>
<td></td>
<td style="text-align:center">xpath(‘//div’)</td>
<td style="text-align:left">选取所有<code>div</code>节点</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td></td>
<td></td>
<td style="text-align:center">xpath(‘./div’)</td>
<td style="text-align:left">选取当前节点下的<code>div</code>节点</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td></td>
<td></td>
<td style="text-align:center">xpath(‘..’)</td>
<td style="text-align:left">选取父节点</td>
</tr>
<tr>
<td style="text-align:center">@</td>
<td></td>
<td></td>
<td style="text-align:center">xpath(‘//@class’)</td>
<td style="text-align:left">选取属性</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line">page = <span class="string">"""</span><br><span class="line">    &lt;div title="buyer-name"&gt;mogl&lt;/div&gt;</span><br><span class="line">    &lt;span class="item-price" src='http://test.com/test.html'&gt;$2.9&lt;/span&gt;</span><br><span class="line">    &lt;span class="item-price" src='http://test2.com/test2.html'&gt;$2.7&lt;/span&gt;</span><br><span class="line">    """</span></span><br><span class="line">htmlDoc = html.fromstring(page)</span><br><span class="line"></span><br><span class="line">buyers = htmlDoc.xpath(<span class="string">'//div[@title="buyer-name"]/text()'</span>)</span><br><span class="line">prices = htmlDoc.xpath(<span class="string">'//span[@class="item-price"]/text()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"buyers:"</span>, buyers</span><br><span class="line"><span class="keyword">print</span> <span class="string">"prices:"</span>, prices</span><br><span class="line"><span class="comment">#buyers: ['mogl']</span></span><br><span class="line"><span class="comment">#prices: ['$2.9', '$2.7']</span></span><br><span class="line"></span><br><span class="line">prices2 = htmlDoc.xpath(<span class="string">'//span[@class="item-price"]/@src'</span>)</span><br><span class="line"><span class="keyword">print</span> prices2</span><br><span class="line"><span class="comment">#['http://test.com/test.html', 'http://test2.com/test2.html']</span></span><br></pre></td></tr></table></figure>
<p><span id="BeautifulSoup"></span></p>
<h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a><strong>BeautifulSoup</strong></h3><p>&emsp;<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="external">BeautifulSoup</a>模块和<code>lxml</code>类似都是用来解析HTML/XML的。该模块是是第三方模块需要安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; pip install beautifulsoup4</span><br></pre></td></tr></table></figure></p>
<p>&emsp;为了方便记录，就以以下的HTML代码为解析例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">"""</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;The BeautifulSoup test&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;a class="mnav" href="http://news.mogl.com" name="news"&gt;新闻&lt;/a&gt;</span><br><span class="line">&lt;img src=http://www.mogl.com/img/test.png width=270 height=129&gt;</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;默认Python会使用内置的解析器进行解析，但速度较慢，这里使用<code>lxml</code>来进行解析(需要先装<code>lxml</code>)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建BeautifulSoup对象</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="comment">#格式化输出</span></span><br><span class="line"><span class="keyword">print</span> soup.prettify(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="Tag——标签"><a href="#Tag——标签" class="headerlink" title="Tag——标签"></a><strong>Tag——标签</strong></h4><p>&emsp;<strong><code>Tag</code></strong>是HTML中的标签，诸如<code>title</code>和<code>a</code>等。BeautifulSoup对<code>Tag</code>的处理主要包含三种：</p>
<ul>
<li><strong>name</strong></li>
<li><strong>string</strong></li>
<li><strong>attrs</strong></li>
</ul>
<p>&emsp;获取整个<code>Tag</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> soup.title</span><br><span class="line"><span class="keyword">print</span> soup.head</span><br><span class="line"><span class="keyword">print</span> soup.a</span><br><span class="line"><span class="keyword">print</span> soup.img</span><br><span class="line"><span class="comment">#&lt;title&gt;The BeautifulSoup test&lt;/title&gt;</span></span><br><span class="line"><span class="comment">#&lt;head&gt;&lt;title&gt;The BeautifulSoup test&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="comment">#&lt;a class="mnav" href="http://news.mogl.com" name="news"&gt;新闻&lt;/a&gt;</span></span><br><span class="line"><span class="comment">#&lt;img height="129" src="http://www.mogl.com/img/test.png" width="270"/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;<code>name</code>是获取<code>Tag</code>的类型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> soup.title.name</span><br><span class="line"><span class="keyword">print</span> soup.a.name</span><br><span class="line"><span class="comment">#title</span></span><br><span class="line"><span class="comment">#a</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;<code>string</code>是获取<code>Tag</code>标签中的文本内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> soup.title.string</span><br><span class="line"><span class="keyword">print</span> soup.a.string</span><br><span class="line"><span class="comment">#The BeautifulSoup test</span></span><br><span class="line"><span class="comment">#新闻</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;<code>attrs</code>是获取<code>Tag</code>标签中的属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> soup.a.attrs</span><br><span class="line"><span class="comment">#&#123;'href': 'http://news.mogl.com', 'class': ['mnav'], 'name': 'news'&#125;</span></span><br><span class="line"><span class="keyword">print</span> soup.a[<span class="string">'href'</span>]</span><br><span class="line"><span class="comment">#http://www.mogl.com/img/test.png</span></span><br><span class="line"><span class="keyword">print</span> soup.img.get(<span class="string">'src'</span>)</span><br><span class="line"><span class="comment">#http://www.mogl.com/img/test.png</span></span><br></pre></td></tr></table></figure></p>
<h4 id="find-all——搜索"><a href="#find-all——搜索" class="headerlink" title="find_all——搜索"></a><strong>find_all——搜索</strong></h4><p>&emsp;<code>find_all()</code>是搜索当前<code>tag</code>的所有节点，返回<strong>符合条件</strong>的<code>tag</code>对象<strong>list</strong>。<br>&emsp;<code>find_all()</code>可对<code>tag.name</code>和<code>tag.attrs</code>进行搜索，还支持对使用<code>re</code>的正则匹配。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> soup.find_all(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">#[&lt;a class="mnav" href="http://news.mogl.com" name="news"&gt;新闻&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> soup.find_all([<span class="string">'a'</span>, <span class="string">'img'</span>])</span><br><span class="line"><span class="comment">#[&lt;a class="mnav" href="http://news.mogl.com" name="news"&gt;新闻&lt;/a&gt;, &lt;img height="129" src="http://www.mogl.com/img/test.png" width="270"/&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> soup.find_all(re.compile(<span class="string">r'^a|^i'</span>))</span><br><span class="line"><span class="comment">#[&lt;a class="mnav" href="http://news.mogl.com" name="news"&gt;新闻&lt;/a&gt;, &lt;img height="129" src="http://www.mogl.com/img/test.png" width="270"/&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;对<code>tag.attrs</code>进行搜索。当对HTML的<code>class</code>属性搜索时，为避免与Python内置的<code>class</code>关键字冲突，使用<strong><code>class_</code></strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> soup.find_all(<span class="string">'a'</span>, class_=<span class="string">"mnav"</span>)</span><br><span class="line"><span class="comment">#[&lt;a class="mnav" href="http://news.mogl.com" name="news"&gt;新闻&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> soup.find_all(href=re.compile(<span class="string">'mogl.com'</span>), class_=<span class="string">"mnav"</span>)</span><br><span class="line"><span class="comment">#[&lt;a class="mnav" href="http://news.mogl.com" name="news"&gt;新闻&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num, each_tag <span class="keyword">in</span> enumerate(soup.find_all(<span class="string">'img'</span>)):</span><br><span class="line">    <span class="keyword">print</span> num, each_tag[<span class="string">'width'</span>]</span><br><span class="line"><span class="comment">#0 270</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;Python库非常多，为方便快速查询，将自己之前用到的库做个简单汇总记录，不定期持续更新。</p>
<p><span id="shutil"></span></p>
<h3 id="shutil"><a href="#shutil" class="headerl]]>
    </summary>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Celery浅记]]></title>
    <link href="http://yoursite.com/2016/08/15/celery/"/>
    <id>http://yoursite.com/2016/08/15/celery/</id>
    <published>2016-08-15T14:00:37.000Z</published>
    <updated>2019-03-31T04:24:48.664Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>&emsp;最近工作要异步执行任务，需要用到<a href="http://docs.celeryproject.org/en/latest/" target="_blank" rel="external">Celery</a>故简单记录一下使用过程。<br>&emsp;Celery常用于实时处理任务队列或任务调度，Celery适用于以下场景：</p>
<ul>
<li>异步执行任务：当需要发送邮件或执行耗时操作时，程序需要等待执行结果才能继续。若将这些任务交给Celery异步执行，可大大提高效率。</li>
<li>定时任务：Celery支持定时任务调度，可用于实现crontab之类的功能。</li>
</ul>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a><strong>基础概念</strong></h2><p>&emsp;Celery一般的工作流程如下所示：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> Producer (Python) </span>|<span class="string"> ---&gt; </span>|<span class="string"> Broker (Redis/RabbitMQ) </span>|<span class="string"> ---&gt; </span>|<span class="string"> Celery Worker (1..N) </span>|<span class="string"> ---&gt; </span>|<span class="string"> Backend (Redis/RabbitMQ) </span>|</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong><code>Producer</code></strong>：<strong>任务生产者</strong>。这里使用的是Python，通过Python调用Celery的API生产任务。</li>
<li><strong><code>Broker</code></strong>：<strong>消息代理</strong>。接收Producer生产的任务，存入任务队列后依序将任务分派给Celery Worker。目前Celery支持的Broker有：<a href="http://docs.celeryproject.org/en/latest/getting-started/brokers/index.html" target="_blank" rel="external">Celery Broker</a>。最常用的就是RabbitMQ和Redis</li>
<li><strong><code>Celery Worker</code></strong>：<strong>任务消费者</strong>。用于执行任务，通常需要使用<code>celery -A [celery.task] worker -l INFO</code>命令运行Celery Worker。</li>
<li><strong><code>Backend</code></strong>：<strong>任务结果存储</strong>。存储任务执行的结果以便查询，默认支持和Broker差不多，常用的也是RabbitMQ和Redis。是否存储结果是可选的，若不设置Backend则不存储任务结果。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><p>&emsp;安装使用pip即可，这里使用的Broker为Redis所以在安装Celery时一起将相关依赖给装上<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redis</span></span><br><span class="line">pip <span class="keyword">install</span> celery[redis]</span><br><span class="line"></span><br><span class="line"><span class="comment">#RabbitMQ</span></span><br><span class="line">pip <span class="keyword">install</span> celery[librabbitmq,msgpack]</span><br></pre></td></tr></table></figure></p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a><strong>应用实例</strong></h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h3><p>&emsp;要使用Celery先要告知Celery使用什么Broker、Backend等一系列信息，故需要进行相关配置。配置大致可分两种形式，一种是直接将Broker等信息写到代码中，一种是将信息先写入配置文件，然后在代码中加载配置。为了方便管理配置，我习惯使用后者。</p>
<ul>
<li>配置文件——<strong><code>celeryconfig.py</code></strong><br>  &emsp;配置文件中有些涉及到定时任务调度，后面会提到可先忽略。  <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from celery.schedules import crontab</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#Redis作为Broker</span></span><br><span class="line">BROKER_URL = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line"><span class="preprocessor">#Redis作为Backend</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://localhost:6379/1'</span></span><br><span class="line"><span class="preprocessor">#任务结果过期时间(seconds)</span></span><br><span class="line">CELERY_TASK_RESULT_EXPIRES = <span class="number">60</span> * <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#BROKER_TRANSPORT_OPTIONS = &#123;'visibility_timeout': 144000&#125;</span></span><br><span class="line"><span class="preprocessor">#CELERY_IGNORE_RESULT = True</span></span><br><span class="line"><span class="preprocessor">#CELERYD_MAX_TASKS_PER_CHILD = 100</span></span><br><span class="line"></span><br><span class="line">CELERY_TASK_SERIALIZER = <span class="string">'json'</span></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'json'</span></span><br><span class="line">CELERY_ACCEPT_CONTENT = [<span class="string">'json'</span>]</span><br><span class="line"><span class="preprocessor">#CELERY_TASK_SERIALIZER = 'msgpack'</span></span><br><span class="line"><span class="preprocessor">#CELERY_ACCEPT_CONTENT = ['json', 'msgpack']</span></span><br><span class="line">CELERY_TIMEZONE = <span class="string">'Asia/Shanghai'</span></span><br><span class="line">CELERY_ENABLE_UTC = False</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="创建任务-task"><a href="#创建任务-task" class="headerlink" title="创建任务(task)"></a><strong>创建任务(task)</strong></h3><p>&emsp;使用Celery的API创建任务非常简单，两步即可完成：</p>
<ol>
<li>实例化Celery对象，命名为<code>celery</code></li>
<li>使用<a href="mailto:**`@celery.task" target="_blank" rel="external">**`@celery.task</a>`**装饰器装饰任务函数</li>
</ol>
<ul>
<li><p>任务程序——<strong><code>tasks.py</code></strong><br>  &emsp;默认Celery Worker是不允许以root用户启动，若需要以root用户启动则需配置<code>platforms.C_FORCE_ROOT = True</code></p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from celery import Celery, platforms</span><br><span class="line">import paramiko</span><br><span class="line"></span><br><span class="line">#实例化Celery对象</span><br><span class="line">celery = <span class="function"><span class="title">Celery</span><span class="params">(__name__)</span></span></span><br><span class="line">#从配置文件加载配置</span><br><span class="line">celery.<span class="function"><span class="title">config_from_object</span><span class="params">(<span class="string">'celeryconfig'</span>)</span></span></span><br><span class="line">#允许root启动</span><br><span class="line"><span class="id">#platforms</span><span class="class">.C_FORCE_ROOT</span> = True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@celery<span class="class">.task</span></span><br><span class="line">def <span class="function"><span class="title">add</span><span class="params">(x, y)</span></span>:</span><br><span class="line">	return x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#设置重试</span><br><span class="line">@celery.<span class="function"><span class="title">task</span><span class="params">(bind=True, default_retry_delay=<span class="number">300</span>, max_retries=<span class="number">5</span>)</span></span></span><br><span class="line">def <span class="function"><span class="title">add_retry</span><span class="params">(x, y)</span></span></span><br><span class="line">	return x + y</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用任务——<strong><code>test.py</code></strong><br>  &emsp;调用已写好的任务程序产生任务<br>  &emsp;<code>add.delay(1, 1)</code>其实是<code>add.apply_async(1, 1)</code>的简写。</p>
  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">from</span> tasks <span class="preprocessor">import</span> <span class="keyword">add</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">add.delay(1, </span><span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行Celery Worker<br>  &emsp;需要运行Celery Worker去执行任务，可结合Supervisor</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your_project_dir</span><br><span class="line">celery -A tasks worker <span class="operator">-l</span> INFO</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a><strong>定时任务</strong></h3><p>&emsp;Celery支持任务调度，使用Celery Beat执行定时任务</p>
<ul>
<li><p>配置文件——<strong><code>crontab_celeryconfig.py</code></strong></p>
  <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"><span class="constant"></span><br><span class="line">BROKER_URL</span> = 'redis:<span class="comment">//localhost:6379/2'</span></span><br><span class="line"><span class="constant">CELERY_RESULT_BACKEND</span> = 'redis:<span class="comment">//localhost:6379/3'</span></span><br><span class="line"><span class="constant"></span><br><span class="line">CELERY_TASK_SERIALIZER</span> = 'json'</span><br><span class="line"><span class="constant">CELERY_RESULT_SERIALIZER</span> = 'json'</span><br><span class="line"><span class="constant">CELERY_ACCEPT_CONTENT</span> = ['json']</span><br><span class="line"><span class="constant">CELERY_TIMEZONE</span> = 'Asia/Shanghai'</span><br><span class="line"><span class="constant">CELERY_ENABLE_UTC</span> = False</span><br><span class="line"><span class="constant"></span><br><span class="line">CELERYBEAT_SCHEDULE</span> = &#123;</span><br><span class="line">	<span class="string">"add"</span>: &#123;</span><br><span class="line">		<span class="string">"task"</span>: <span class="string">"crontab_tasks.sendmail"</span>,</span><br><span class="line">		<span class="string">"schedule"</span>: crontab(minute='*/<span class="number">1</span>')</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>任务程序——<strong>crontab_tasks.py</strong></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">crontab_celery = Celery(__name__)</span><br><span class="line">crontab_celery.config_from_object(<span class="string">'crontab_celeryconfig'</span>)</span><br><span class="line"></span><br><span class="line"><span class="decorator">@crontab_celery.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendmail</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"Celery Crontab Tast Test"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Celery Worker &amp; Beat<br>  &emsp;启动Celery的Worker和Beat，每分钟定时执行<code>sendmail()</code>函数</p>
  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">celery</span> -A crontab_tasks worker -<span class="keyword">B </span>-l <span class="preprocessor">INFO</span> -s /tmp/celerybeat-schedule</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a><strong>后续</strong></h2><p>&emsp;目前只是简单的使用了Celery的基础功能，更多高级功能以后用到再继续补上</p>
<ul>
<li><p>手动指定路由(Route)和队列(Queue)<br>  当使用RabbitMQ作为Broker时，可手动指定任务的队列和路由。Celery默认所有任务都到<code>celery</code>的队列中。详细参考以下文章：</p>
<ul>
<li><a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#manual-routing" target="_blank" rel="external">Celery官方Routing文档</a></li>
<li><a href="http://lsq.me/2013/12/20/python/celery-manual-routing/" target="_blank" rel="external">Celery 如何手动路由任务</a></li>
<li><a href="http://linpingta.cn/blog/2016/03/19/celery-2/" target="_blank" rel="external">Celery 概念：分布式、路由队列与工作流</a></li>
</ul>
</li>
<li><p>flower<br>  &emsp;flower提供Web界面对Celery进行监控</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>&emsp;最近工作要异步执行任务，需要用到<a href="http://docs.celeryproj]]>
    </summary>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
  </entry>
  
</feed>
