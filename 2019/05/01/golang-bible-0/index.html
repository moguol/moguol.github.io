<!DOCTYPE html>
<html lang="zh-Hant-TW">

	

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title> 墨 痕 </title>
	<meta property="og:title" content=" Go语言圣经笔记-上 | Hexo " />
	<meta name="twitter:title" content=" Go语言圣经笔记-上 | Hexo ">

	<meta property="og:type" content="article">
	<meta name="twitter:card" content="summary">

	<meta name="description" content=" Go语言圣经笔记-上 | Hexo ">
	<meta property="og:description" content=" Go语言圣经笔记-上 | Hexo " />
	<meta name="twitter:description" content=" Go语言圣经笔记-上 | Hexo " />

	<link rel="icon" type="image/x-icon" href="http://yoursite.com/asset/img/favicon.png">

	<link rel="image_src" href="http://yoursite.com/asset/img/logo.png" >
	<meta property="og:image" content="http://yoursite.com/asset/img/logo.png" />

	
	<link href="http://yoursite.com/atom.xml" title="Hexo" type="application/atom+xml" rel="alternative">
	

	<link rel="canonical" href="/2019/05/01/golang-bible-0/index.html">

	<link rel="stylesheet" href="/asset/css/main.css">

</head>


<body>

	
	<header class="site-header">

		
		<nav class="nav-page">

			<div class="row">

				<ul>

					

					<li><a href="/">Home</a></li>

					

					<li><a href="/archives">Sitemap</a></li>

					

					<li><a href="/atom.xml">Rss</a></li>

					

				</ul>

			</div>

		</nav>


		<div class="site-header-main">

			<div class="row">

				<h1><a href="/">墨 痕</a></h1>
				<h6><a href="/">fatesai#gmail.com</a></h6>

				

			</div>

		</div>

		


		<nav class="nav-cat">

			<div class="row">

				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Bigdata/">Bigdata</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPS/">OPS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/">TCP/IP</a></li></ul>

			</div>

		</nav>




	</header>


	<div id="content" class="site-content">

		
		<div class="row content-post">
			<article itemscope itemtype="http://schema.org/Article">

				

				

				<p class="content-meta">
					<span class="meta-date" itemprop="datePublished" content="2019-05-01">2019-05-01</span>

					
					  <span class="meta-cat">
						<a class="category-link" href="/categories/Golang/">Golang</a>
					  </span>
					
				</p>

				

					<h2 class="content-title">
						<a href="/2019/05/01/golang-bible-0/" itemprop="url"><span itemprop="name">Go语言圣经笔记-上</span></a>
					</h2>

				


				<div class="content" itemprop="articleBody">
                    <!-- Table of Contents -->
                    
                    <div id="toc" class="toc-article">
                        <strong class="toc-title">目录</strong>
                        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#程序结构"><span class="toc-number">1.</span> <span class="toc-text">程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#命名"><span class="toc-number">1.1.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明"><span class="toc-number">1.2.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-number">1.3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简短变量声明"><span class="toc-number">1.3.1.</span> <span class="toc-text">简短变量声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针"><span class="toc-number">1.3.2.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new函数"><span class="toc-number">1.3.3.</span> <span class="toc-text">new函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值"><span class="toc-number">1.4.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型"><span class="toc-number">1.5.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包和文件"><span class="toc-number">1.6.</span> <span class="toc-text">包和文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#导入包"><span class="toc-number">1.6.1.</span> <span class="toc-text">导入包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#包初始化"><span class="toc-number">1.6.2.</span> <span class="toc-text">包初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域"><span class="toc-number">1.7.</span> <span class="toc-text">作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础类型"><span class="toc-number">2.1.</span> <span class="toc-text">基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Integer"><span class="toc-number">2.1.1.</span> <span class="toc-text">Integer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Float"><span class="toc-number">2.1.2.</span> <span class="toc-text">Float</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Complex"><span class="toc-number">2.1.3.</span> <span class="toc-text">Complex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bool"><span class="toc-number">2.1.4.</span> <span class="toc-text">Bool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">2.1.5.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Const"><span class="toc-number">2.1.6.</span> <span class="toc-text">Const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合类型"><span class="toc-number">2.2.</span> <span class="toc-text">复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array"><span class="toc-number">2.2.1.</span> <span class="toc-text">Array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Slice"><span class="toc-number">2.2.2.</span> <span class="toc-text">Slice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map"><span class="toc-number">2.2.3.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Struct"><span class="toc-number">2.2.4.</span> <span class="toc-text">Struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Json"><span class="toc-number">2.2.5.</span> <span class="toc-text">Json</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#struct-to-json"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">struct to json</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#json-to-struct"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">json to struct</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#map-to-json"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">map to json</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#json-to-map"><span class="toc-number">2.2.5.4.</span> <span class="toc-text">json to map</span></a></li></ol></li></ol></li></ol></li></ol>
                    </div>
                    

					<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a><strong>程序结构</strong></h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a><strong>命名</strong></h3><ul>
<li><p>命名规则:</p>
<ul>
<li>以字母或下划线开头，接任意字母、数字或下划线(<strong>区分大小写</strong>)。保留关键字及预定义名不可用</li>
<li>名字<strong>首字母大小写</strong>决定该名在包外可见性</li>
</ul>
</li>
<li><p>保留关键字</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>      <span class="keyword">default</span>       <span class="keyword">func</span>     <span class="keyword">interface</span>   <span class="keyword">select</span></span><br><span class="line"><span class="keyword">case</span>       <span class="keyword">defer</span>         <span class="keyword">go</span>       <span class="keyword">map</span>         <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>       <span class="keyword">else</span>          <span class="keyword">goto</span>     <span class="keyword">package</span>     <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>      <span class="keyword">fallthrough</span>   <span class="keyword">if</span>       <span class="keyword">range</span>       <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>   <span class="keyword">for</span>           <span class="keyword">import</span>   <span class="keyword">return</span>      <span class="keyword">var</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>预定义名</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内建常量: <span class="constant">true</span> <span class="constant">false</span> <span class="constant">iota</span> <span class="constant">nil</span></span><br><span class="line"></span><br><span class="line">内建类型: <span class="typename">int</span> <span class="typename">int8</span> <span class="typename">int16</span> <span class="typename">int32</span> <span class="typename">int64</span></span><br><span class="line">         <span class="typename">uint</span> <span class="typename">uint8</span> <span class="typename">uint16</span> <span class="typename">uint32</span> <span class="typename">uint64</span> <span class="typename">uintptr</span></span><br><span class="line">         <span class="typename">float32</span> <span class="typename">float64</span> <span class="typename">complex128</span> <span class="typename">complex64</span></span><br><span class="line">         <span class="typename">bool</span> <span class="typename">byte</span> <span class="typename">rune</span> <span class="typename">string</span> error</span><br><span class="line"></span><br><span class="line">内建函数: <span class="built_in">make</span> <span class="built_in">len</span> <span class="built_in">cap</span> <span class="built_in">new</span> <span class="built_in">append</span> <span class="built_in">copy</span> <span class="built_in">close</span> <span class="built_in">delete</span></span><br><span class="line">         <span class="built_in">complex</span> <span class="built_in">real</span> <span class="built_in">imag</span></span><br><span class="line">         <span class="built_in">panic</span> <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命名规范</p>
<ul>
<li><p>使用<strong>驼峰式</strong>方式</p>
</li>
<li><p>包(package)名用<strong>小写</strong>，使用短命名</p>
</li>
<li><p>接口(interface)名，单方法接口以函数名+<code>er</code>后缀，两个方法接口综合两个函数名+<code>er</code>后缀，三个以上取能精准描述接口目的的名字</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriteFlusher <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write([]<span class="typename">byte</span>) (<span class="typename">int</span>, error)</span><br><span class="line">    Flush() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部变量/函数参数，使用小写字母，尽量短小</p>
</li>
<li><p>方法接收者(receiver)应该缩写，一般使用一个或者两个字符作为receiver的名称</p>
</li>
<li><p>包(package)级别导出名不要把包名的意义再写一遍，<code>bytes.Buffer</code>，<del><code>bytes.ByteBuffer</code></del></p>
</li>
</ul>
</li>
</ul>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a><strong>声明</strong></h3><p>声明语句，包(package)级声明语句顺序无关紧要</p>
<ul>
<li><strong><code>var</code></strong>: 变量</li>
<li><strong><code>const</code></strong>: 常量</li>
<li><strong><code>type</code></strong>: 类型</li>
<li><strong><code>func</code></strong>: 函数</li>
</ul>
<p>声明示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="typename">int</span></span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="typename">int</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    name <span class="typename">string</span></span><br><span class="line">    age <span class="typename">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> mapper <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">string</span>  <span class="comment">// mapper = make(map[int]string) map是声明后必须使用make初始化才能使用</span></span><br><span class="line"><span class="keyword">var</span> names []<span class="typename">string</span>	<span class="comment">// 声明并初始化: var sliceName []type = make([]type, len, capacity)，简写slice1 := make([]type, len, capacity)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi <span class="typename">float32</span> = <span class="number">3.14159</span> <span class="comment">// const Pi = 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	id      <span class="typename">int</span></span><br><span class="line">	name    <span class="typename">string</span></span><br><span class="line">	age     <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> WriteFlusher <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write([]<span class="typename">byte</span>) (<span class="typename">int</span>, error)</span><br><span class="line">    Flush() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> add(a, b <span class="typename">int</span>) <span class="typename">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><p>变量声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span> = expression	<span class="comment">// var age int = 18</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span>	<span class="comment">// var age int	// 自动赋予零值</span></span><br><span class="line"><span class="keyword">var</span> name = expression	<span class="comment">// var age = 18</span></span><br></pre></td></tr></table></figure>
<p><code>type</code> 和 <code>= expression</code>可二选一，省略<code>type</code>会根据<code>expression</code>推导变量类型(<code>var name = expression</code>)，省略<code>expression</code>会用<strong>零值</strong>初始化变量(<code>var name type</code>)，各类型零值:</p>
<ul>
<li>number: <code>0</code></li>
<li>bool: <code>false</code></li>
<li>string: <code>“”</code> (空字符串)</li>
<li>slice/pointer/map/chan/func/interface: <code>nil</code></li>
<li>array/struct: 每个元素/字段对于类型的零值</li>
</ul>
<h4 id="简短变量声明"><a href="#简短变量声明" class="headerlink" title="简短变量声明"></a><strong>简短变量声明</strong></h4><p><strong>函数内部</strong>可用简短变量声明语句<strong>声明</strong>和<strong>初始化</strong>局部变量(只能用于函数内部)，变量类型根据表达式自动推导</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := expression	<span class="comment">// age := 18</span></span><br></pre></td></tr></table></figure>
<p>相同词法域中，简短变量声明过的变量<strong>只能赋值</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">out, err := os.Create(outfile)	<span class="comment">// err变量已简短声明过，此处是对err变量进行了赋值</span></span><br></pre></td></tr></table></figure>
<p>简短变量声明语句中<strong>必须至少要声明一个新变量</strong>，否则编译不通过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">f, err := os.Create(outfile) 	<span class="comment">// 编译报错，f和err都已声明过，只能赋值		// f, err = os.Create(outfile)</span></span><br></pre></td></tr></table></figure>
<p>简短变量声明只对同级词法域声明过的变量进行赋值操作，变量在外部词法域则是重新声明一个新的变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    test := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="constant">true</span> &#123;</span><br><span class="line">        test := <span class="number">1</span>	<span class="comment">// 此test变量是一个新变量, 无论怎么修改都不会影响if外的test变量</span></span><br><span class="line">        fmt.Println(<span class="string">"main if"</span>, test)    <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"main"</span>, test)       <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a><strong>指针</strong></h4><p>一个指针类型变量的值是另一个变量的地址(指针存储变量在内存中的位置)，通过指针可<strong>直接</strong>读或更新对应变量的值，不需要知道变量名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x		<span class="comment">// p为指向x变量的指针，p的类型为 *int	// &amp; 为取地址操作</span></span><br><span class="line">fmt.Println(*p)		<span class="comment">// 1	// *p表示读取指针指向变量的值</span></span><br><span class="line">*p = <span class="number">2</span>		<span class="comment">// 等价于 x = 2	// 通过指针修改变量值</span></span><br><span class="line">fmt.Println(x)	<span class="comment">// 2</span></span><br><span class="line">*p++	<span class="comment">// 只是增加p指向的变量的值，并不改变p指针！！！</span></span><br><span class="line">fmt.Println(x)	<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><strong>任何类型的指针的零值都是<code>nil</code></strong></p>
<p>p指向某个有效变量，那么<code>p != nil</code>测试为<code>true</code></p>
<p>指针可进行相等测试，只有当它们指向同一个变量或全部是nil时才相等</p>
<h4 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a><strong>new函数</strong></h4><p><strong><code>new(T)</code></strong></p>
<ol>
<li>创建一个T类型匿名变量</li>
<li>初始化匿名变量为T类型零值</li>
<li>返回匿名变量地址，返回的指针类型为<strong><code>*T</code></strong></li>
</ol>
<p><code>new(T)</code>得到的是一个<code>*T</code>类型，值为T类型零值的匿名变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="typename">int</span>)	<span class="comment">// p 类型为*int，值为0</span></span><br><span class="line">fmt.Println(*p)	<span class="comment">// 0</span></span><br><span class="line">*p = <span class="number">2</span></span><br><span class="line">fmt.Println(*p)	<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a><strong>赋值</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>                       <span class="comment">// 命名变量的赋值</span></span><br><span class="line">*p = <span class="constant">true</span>                   <span class="comment">// 通过指针间接赋值</span></span><br><span class="line">person.name = <span class="string">"bob"</span>         <span class="comment">// struct结构体字段赋值</span></span><br><span class="line">count[x] = count[x] * scale <span class="comment">// array、slice或map的元素赋值</span></span><br><span class="line">count[x] *= scale			<span class="comment">// 二元算术运算符和赋值语句的复合操作</span></span><br><span class="line">v++;v--						<span class="comment">// 数值变量支持递增/递减语句，自增/自减是语句，非表达式，x = v++ 是错误的!!!</span></span><br></pre></td></tr></table></figure>
<p>元组赋值，允许同时更新多个变量的值</p>
<p>当函数调用出现在元组赋值右边的表达式中时，左边变量的数目必须和右边一致</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x					<span class="comment">// 交换两个变量</span></span><br><span class="line">i, j, k = <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>			<span class="comment">// 多变量同时赋值</span></span><br><span class="line">f, err = os.Open(<span class="string">"foo.txt"</span>)	<span class="comment">// os.Open()返回2个值，进行元组赋值时左边也必须有2个变量</span></span><br></pre></td></tr></table></figure>
<p>如果map查找、类型断言或channel接收出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v, ok = m[key]             <span class="comment">// map查找</span></span><br><span class="line">v, ok = x.(T)              <span class="comment">// 类型断言</span></span><br><span class="line">v, ok = &lt;-ch               <span class="comment">// channel接收</span></span><br><span class="line">_, ok = m[key]             <span class="comment">// 可使用_丢弃不需要的值</span></span><br></pre></td></tr></table></figure>
<p>隐式赋值行为：</p>
<ul>
<li>函数调用隐式地将调用参数的值赋值给函数的参数变量</li>
<li>返回语句会隐式地将返回操作的值赋值给结果变量</li>
<li>复合类型的字面量所产生的赋值行为 <code>medals := []string{&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;}</code>，赋值行为：<code>medals[0] = &quot;gold&quot;</code></li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a><strong>类型</strong></h3><p>类型声明语句一般在包级，&lt;类型名&gt;首字母大写则包外可见。类型声明语句如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;类型名&gt; &lt;底层类型&gt;	<span class="comment">// type Celsius float64</span></span><br></pre></td></tr></table></figure>
<p><strong>类型转换</strong>操作，每一类型<code>T</code>，都有对应的类型转换操作<code>T(x)</code>，用于将x转为T类型。<strong>只有当两个类型的底层基础类型相同时，才允许这种转型操作</strong>。</p>
<p>命名类型可为该类型的值定义新行为，行为表现为一组关联到该类型的函数集合，称之为<strong>类型方法集</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="typename">float64</span>	<span class="comment">// 创建命令类型</span></span><br><span class="line"><span class="keyword">func</span> (c Celsius) String() <span class="typename">string</span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%g°C"</span>, c) &#125;	<span class="comment">// 为命名类型创建String()方法</span></span><br><span class="line"><span class="keyword">var</span> c Celsius</span><br><span class="line">c = <span class="number">100.0</span></span><br><span class="line">fmt.Println(c.String())		<span class="comment">// 调用String()方法</span></span><br></pre></td></tr></table></figure>
<h3 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a><strong>包和文件</strong></h3><p>Go语言中的包(package)，目的是为了支持模块化、封装、单独编译和代码重用</p>
<p>一个包中保存在一个或多个以.go为文件后缀名的源文件，包级别的名字在同一个包的其他源文件可以直接访问，逻辑上所有代码都在一个文件一样</p>
<p>包所在目录路径是包的导入路径，e.g., 包导入路径: <code>gopl.io/ch1/helloworld</code>，目录路径: <code>$GOPATH/src/gopl.io/ch1/helloworld</code></p>
<p>每个包对应一个独立的名字空间，通过<strong>首字母大小写</strong>控制包外可见性</p>
<h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a><strong>导入包</strong></h4><p>每个包都有一个全局唯一的导入路径</p>
<p>每个包还有一个包名，包名命名以短小原则为主。一般而言，包名和包的导入路径的最后一个字段相同。e.g., <code>gopl.io/ch2/tempconv</code>，包名为<code>tempconv</code></p>
<p>包被导入却没有使用会引发编译错误</p>
<h4 id="包初始化"><a href="#包初始化" class="headerlink" title="包初始化"></a><strong>包初始化</strong></h4><p>包的变量初始化：按变量<strong>声明顺序</strong>初始化，但变量间有依赖<strong>优先初始化被依赖变量</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b + c <span class="comment">// a 第三个初始化, 为 3</span></span><br><span class="line"><span class="keyword">var</span> b = f()   <span class="comment">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>     <span class="comment">// c 第一个初始化, 为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> f() <span class="typename">int</span> &#123; <span class="keyword">return</span> c + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>包内有多个<code>.go</code>源文件，按照发给编译器顺序初始化，Go语言构建工具首先按<code>.go</code>文件的文件名字典顺序排序，然后依次传给编译器</p>
<p>初始化工作可交由<code>init()</code>初始化函数完成，<code>init()</code>初始化函数有以下特点：</p>
<ul>
<li><p>每个<code>.go</code>文件可包含<strong>多个</strong><code>init()</code>初始化函数</p>
</li>
<li><p><code>init()</code>初始化函数<strong>不能被调用</strong>，<strong>无传参</strong></p>
</li>
<li>多个<code>init()</code>初始化函数，在程序执行时，<strong>按声明顺序</strong>被自动调用</li>
</ul>
<p>包的初始化顺序如下图所示：</p>
<p><img src="https://beego.me/docs/images/init.png" alt="Go 包初始化"></p>
<p><a href="https://beego.me/docs/quickstart/router.md" target="_blank" rel="external">图片出处</a></p>
<ol>
<li><strong>初始化依赖包</strong>：初始化一个包前，必须完全初始化其所依赖的包，按包<strong>出现顺序</strong>初始化并且每个包<strong>只会初始化一次</strong>(即使多次引用也一次)</li>
<li><strong>初始化const常量</strong>：初始化完依赖包后，以下的都属于<strong>包内初始化</strong>。首先是<code>const</code>常量的初始化</li>
<li><strong>初始化var全局变量</strong>：按全局变量<strong>声明顺序</strong>初始化，但全局变量间有依赖<strong>优先初始化被依赖变量</strong></li>
<li><strong>初始化init()函数</strong>：按<strong>声明顺序</strong>初始化<code>init()</code>函数，若包内有多个<code>.go</code>文件，按<strong>文件名字典顺序</strong>初始化<code>.go</code>文件</li>
<li><strong>main()函数</strong></li>
</ol>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h3><ul>
<li><p>包级作用域：包内函数外定义，必须以<code>var</code>方式声明(不能简短声明)，包内多个文件皆可使用，包外可见性以首字母大小写决定。包级作用域的变量，声明顺序不影响作用域范围</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="typename">int</span>	<span class="comment">// 包级作用域</span></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数作用域：传入参数(非外部引用型)、返回值声明参数、函数内部声明参数，以上都只能在函数内部使用。若外部有同名变量则内部覆盖外部</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str/name/age 都是函数作用域</span></span><br><span class="line"><span class="keyword">func</span> test(str <span class="typename">string</span>) (name <span class="typename">string</span>) &#123;</span><br><span class="line">    age := <span class="number">18</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="typename">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> init() &#123;</span><br><span class="line">    cwd, err := os.Getwd() <span class="comment">// 此处cwd为重新声明定义的变量，与包级cwd无丝毫关系，为init()函数作用域变量</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"os.Getwd failed: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for/if/switch局部作用域</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f, err := os.Open(fname); err != <span class="constant">nil</span> &#123; <span class="comment">// if局部作用域，只在if词法域中有效</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">f.ReadByte() <span class="comment">// f 为if局部作用域变量，if外无法使用，f未定义</span></span><br><span class="line">f.Close()    <span class="comment">// compile error: undefined f</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>Go语言中数据类型分为4类：</p>
<ul>
<li><strong>基础类型</strong>：numeric、string、bool</li>
<li><strong>复合类型</strong>：array、struct</li>
<li><strong>引用类型</strong>：point、<strong>slice</strong>、<strong>map</strong>、<strong>channal</strong>、function</li>
<li><strong>接口类型</strong>：interface</li>
</ul>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a><strong>基础类型</strong></h3><h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a><strong>Integer</strong></h4><ul>
<li>有符号整型：<code>int8</code>、<code>int16</code>、<code>int32</code>(<code>rune</code>)、<code>int64</code>    (<code>-2^(N-1)</code> ~ <code>2^(N-1)-1</code>)</li>
<li>无符号整型：<code>uint8</code>(<code>byte</code>)、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>    (<code>0</code> ~ <code>2^N - 1</code>)</li>
<li>依赖系统类型：<code>int</code>、<code>uint</code>    (32位系统为<code>int32</code>、<code>uint32</code>，64位系统为<code>int64</code>、<code>uint64</code>)</li>
</ul>
<p>二元运算优先级：上 &gt; 下、左 &gt; 右、可使用<code>()</code>提升优先级、<code>%</code>的符号和被取模数符号一致、<code>/</code>结果精度根据操作数定</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*      /      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^</span><br><span class="line">+      -      |      ^</span><br><span class="line">==     !=     &lt;      &lt;=       &gt;      &gt;=</span><br><span class="line">&amp;&amp;</span><br><span class="line">||</span><br></pre></td></tr></table></figure>
<h4 id="Float"><a href="#Float" class="headerlink" title="Float"></a><strong>Float</strong></h4><ul>
<li>单精度浮点型：<code>float32</code></li>
<li>双精度浮点型：<code>float64</code></li>
</ul>
<h4 id="Complex"><a href="#Complex" class="headerlink" title="Complex"></a><strong>Complex</strong></h4><ul>
<li><code>complex64</code>：对应<code>float32</code></li>
<li><code>complex128</code>：对应<code>float64</code></li>
</ul>
<h4 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a><strong>Bool</strong></h4><ul>
<li><code>true</code></li>
<li><code>false</code></li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h4><p>字符串是数个8位字节(8-bit bytes)的集合，通常是UTF-8编码的文本(可为其他编码)</p>
<p>字符串是<strong>不可改变</strong>的字节序列 (意味若两个字符串共享相同的底层数据是安全的)，由于字符串不可改变，所以每次更改字符串需要重新分配一块新内存空间<br>Go的字符串有2种形式：</p>
<ul>
<li><p>解析性字符串：带<code>“”</code>的字节序列</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello world"</span></span><br><span class="line">fmt.Println(s)	<span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原生字符串：带反引号的字符序列</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">`hello world\n`</span></span><br><span class="line">fmt.Println(s)	<span class="comment">// hello world\n	// \n会被原样输出</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>len()</code>函数返回字符串中的字节数；<code>str[i]</code>索引操作返回第<code>i</code>个字节值(<code>0&lt;= i &lt;len(str)</code>)，超出索引范围会引发panic</p>
<p><code>str[i:j]</code>子字符串操作返回第<code>i</code>个字节到第<strong><code>j-1</code></strong>个字节(并非第<code>j</code>个字节)</p>
<p><code>+</code>操作拼接两个字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello, world"</span>		<span class="comment">// len(s) == 12</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>:<span class="number">5</span>])		<span class="comment">// "hello"</span></span><br><span class="line">fmt.Println(s[:])		<span class="comment">// "hello, world"</span></span><br><span class="line">fmt.Println(<span class="string">"goodbye"</span> + <span class="string">" "</span> + s[<span class="number">7</span>:])	<span class="comment">// "goodbye world"</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">"H"</span>		<span class="comment">// cannot assign to s[0]	字符串不可改变</span></span><br><span class="line">Usage := <span class="string">`test	// `</span><span class="string">`表示原生字符串字面值</span><br><span class="line"></span><br><span class="line">Uage: xxx`</span></span><br></pre></td></tr></table></figure>
<p>由于字符串不可改变，所以若想单独修改字符串中的字符，则需要将<code>string</code>转换为<code>[]byte</code>，修改完后再转换回<code>string</code> (<code>[]byte</code>既是<code>[]uint8</code>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello world"</span></span><br><span class="line">b := []<span class="typename">byte</span>(s)</span><br><span class="line">b[<span class="number">0</span>] = <span class="string">'H'</span>	<span class="comment">// 是''而非""</span></span><br><span class="line">fmt.Println(<span class="typename">string</span>(b))</span><br></pre></td></tr></table></figure>
<p><code>string</code>转为<code>rune</code>，<code>rune</code>是<code>int32</code>别名(<code>byte</code>是<code>uint8</code>别名)，代表字符的Unicode编码，使用4个字节存储，将<code>string</code>转成<code>rune</code>就意味着任何一个字符都用<code>4</code>个字节来存储其Unicode值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s2 := <span class="string">"Go语言"</span></span><br><span class="line">fmt.Pringln(<span class="built_in">len</span>(s2))	<span class="comment">// 8 	// len()输出字节个数而非字符个数，一个UTF-8编码的中文等于3字节</span></span><br><span class="line"></span><br><span class="line">r := []<span class="typename">rune</span>(s2)</span><br><span class="line">fmt.Println(r)			<span class="comment">// [71 111 35821 35328]		// 输出的是4个Unicode值</span></span><br><span class="line">fmt.Pringln(<span class="built_in">len</span>(r))		<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p><code>string</code>转为<code>numeric</code>需要使用到<code>strconv</code>包：</p>
<ul>
<li><p><code>strconv.Itoa</code>：<code>int</code> to <code>string</code></p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">123</span></span><br><span class="line">s := strconf.Itoa(i)		<span class="comment">// s 为 string类型，值为"123"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>strconv.Atoi</code>：<code>string</code> to <code>int</code></p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s3 := <span class="string">"123"</span></span><br><span class="line">i, err := strconv.Atoi(s3)		<span class="comment">// i 为 int类型，值为123</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Const"><a href="#Const" class="headerlink" title="Const"></a><strong>Const</strong></h4><p>常量的值在编译阶段确定而非运行时，常量的底层类型都是基础类型(<code>bool</code>/<code>numeric</code>/<code>string</code>)，常量的值不可修改，常量的二元运算结果也是常量</p>
<p>批量声明常量，除第一个必须有初始化表达式外，其余的可省略，省略则默认使用前面的初始化表达式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi <span class="typename">float64</span> = <span class="number">3.14</span>		<span class="comment">// const pi = 3.14 省略type也可，自动根据表达式确认type</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">    b		<span class="comment">// 省略初始化表达式，默认使用前一个变量声明的初始化表达式</span></span><br><span class="line">    c = <span class="number">2</span></span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d)		<span class="comment">// 1 1 2 2</span></span><br></pre></td></tr></table></figure>
<p>iota常量生成器，用于以相似规则生成常量。<code>const</code>声明语句中，第一个变量声明所在行<code>iota</code>将置<code>0</code>，然后每个有常量声明的行都<code>+1</code>，<code>iota</code>按行递增</p>
<p>若<code>iota</code>生成器被打断后，需要显示用<code>iota</code>恢复</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="constant">iota</span></span><br><span class="line">    b				<span class="comment">// iota + 1</span></span><br><span class="line">    c = <span class="string">"test"</span></span><br><span class="line">    d				<span class="comment">// iota被打断，d 省略初始化表达式，默认使用前一个初始化表达式</span></span><br><span class="line">    e				<span class="comment">// 同 d</span></span><br><span class="line">    f = <span class="constant">iota</span>		<span class="comment">// 显示使用iota恢复，iota后每有一行变量声明都会+1，不管是否被打断</span></span><br><span class="line">)</span><br><span class="line">fmt.Pringln(a, b, c, d, e, f)	<span class="comment">// 0 1 test test test 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a, b = <span class="constant">iota</span>, <span class="constant">iota</span> + <span class="number">1</span>		<span class="comment">// iota == 0</span></span><br><span class="line">    _, _						<span class="comment">// iota == 1</span></span><br><span class="line">    c, d						<span class="comment">// iota == 2</span></span><br><span class="line">    e = <span class="constant">iota</span> + <span class="number">10</span>				<span class="comment">// iota == 3</span></span><br><span class="line">)</span><br><span class="line">fmt.Pringln(a, b, c, d, e)		<span class="comment">// 0 1 2 3 13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _ = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="constant">iota</span>)</span><br><span class="line">    KiB <span class="comment">// 1024</span></span><br><span class="line">    MiB <span class="comment">// 1048576</span></span><br><span class="line">    GiB <span class="comment">// 1073741824</span></span><br><span class="line">    TiB <span class="comment">// 1099511627776             (exceeds 1 &lt;&lt; 32)</span></span><br><span class="line">    PiB <span class="comment">// 1125899906842624</span></span><br><span class="line">    EiB <span class="comment">// 1152921504606846976</span></span><br><span class="line">    ZiB <span class="comment">// 1180591620717411303424    (exceeds 1 &lt;&lt; 64)</span></span><br><span class="line">    YiB <span class="comment">// 1208925819614629174706176</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a><strong>复合类型</strong></h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a><strong>Array</strong></h4><p>数组是由特定元素组成的<strong>固定长度</strong>序列(<code>[length]type</code>)，通过索引下标访问元素(<code>0</code> ~ <code>len(array) - 1</code>)</p>
<p>数组长度是数组类型的组成部分，数组长度在编译阶段确定，故<code>[3]int</code>和<code>[4]int</code>是两个不同的数组类型</p>
<p>若<code>[length]type</code>中length用<code>...</code>代替，表示数组长度根据初始化值的个数决定</p>
<p>相同类型的数组(<code>length</code>和<code>type</code>都相同)可进行比较，不同类型的数组进行比较会编译出错panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">3</span>]<span class="typename">int</span></span><br><span class="line">array[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(array[<span class="number">0</span>])	<span class="comment">// 0	// 无初始化值赋值则默认为对应类型的零值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var array1 [3]string = [3]string&#123;"one", "two", "three"&#125;</span></span><br><span class="line">array1 := [<span class="number">3</span>]<span class="typename">string</span>&#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;	<span class="comment">// 声明并初始化赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> array1 &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array2 := [...]<span class="typename">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;		<span class="comment">// [3]int</span></span><br><span class="line"></span><br><span class="line">r := [...]<span class="typename">int</span>&#123;<span class="number">99</span>: -<span class="number">1</span>&#125;			<span class="comment">// 含有100个元素，最后一个元素初始化为-1</span></span><br></pre></td></tr></table></figure>
<h4 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a><strong>Slice</strong></h4><p>切片是由特定元素组成的<strong>可变长</strong>序列(<code>[]type</code>)，通过索引下标访问元素(<code>0</code> ~ <code>cap(slice)</code>)</p>
<p>slice和array不同，slice间不能进行比较，slice唯一能进行比较操作的是和<code>nil</code>，零值slice等于<code>nil</code>(<code>nil</code>值的slice无底层array)，但判断slice是否为空不能用<code>s == nil</code>，使用<code>len(s) == 0</code></p>
<p>slice由3部分组成：</p>
<ul>
<li>指针<code>pointer</code>：指向第一个slice元素对应的底层array元素的地址 (slice的第一个元素不一定就是array的第一个元素)</li>
<li>长度<code>length</code>：slice的元素个数 (length &lt;= capacity)，可使用<code>len(slice)</code>获得</li>
<li>容量<code>capacity</code>：slice元素的最大个数，可使用<code>cap(slice)</code>获得</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/sort.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer	<span class="comment">// 指向所引用的数组指针	// unsafe.Pointer 表示任何可寻址的值的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="typename">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="typename">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice切片操作<code>s[i:j]</code>(<code>0&lt;=i&lt;=j&lt;=cap(s)</code>)，获取第<code>i</code>个元素到第<strong><code>j-1</code></strong>个元素，<code>len(s[i:j])</code>为<code>j-i</code>，<code>cap(s[i:j])</code>为<strong><code>cap(s)-i</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    s := []<span class="typename">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))		<span class="comment">// [1 2 3 4 5] 5 5</span></span><br><span class="line"></span><br><span class="line">    s1 := s[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))	<span class="comment">// [1 2 3] 3 5</span></span><br><span class="line"></span><br><span class="line">    s2 := s[<span class="number">2</span>:]</span><br><span class="line">    fmt.Println(s2, <span class="built_in">len</span>(s2)， <span class="built_in">cap</span>(s2))	<span class="comment">// [3 4 5] 3 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        fmt.Println(i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可使用内置的<code>make()</code>函数创建slice，<code>make()</code>创建一个匿名的数组变量并<strong>初始化赋值对应类型的零值</strong>，然后返回一个slice</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make([]T, len)</span></span><br><span class="line"><span class="comment">// make([]T, len, cap)</span></span><br><span class="line"></span><br><span class="line">s4 := <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="number">3</span>)</span><br><span class="line">s4[<span class="number">1</span>] = <span class="number">222</span></span><br><span class="line">fmt.Println(s4)		<span class="comment">// [0 222 0]</span></span><br></pre></td></tr></table></figure>
<p>使用<strong><code>append()</code></strong>函数向slice追加元素，使用<code>append()</code>函数必须注意一点：调用<code>append()</code>函数是，会先检测slice是否有足够的<strong>capacity</strong>保存新元素，如果有足够容量则直接扩展slice，<strong>保持底层数组不变</strong>；如果没有足够容量会先分配一个<strong><code>capacity * 2</code></strong>的新slice，然后将原slice内容复制到新slice，最后再添加新元素，由于新分配了内存空间，所以<strong>底层数组改变</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="typename">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(s)				<span class="comment">// [1 2 3]</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">fmt.Println(s)				<span class="comment">// [1 2 3 4]</span></span><br><span class="line"></span><br><span class="line">s1 := []<span class="typename">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, s1...)	<span class="comment">// 将一个slice追加到另一个slice</span></span><br><span class="line">fmt.Println(s)				<span class="comment">// [1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="number">0</span>, <span class="number">10</span>)		<span class="comment">// a ---&gt; 0x1234  无(data)  0(length)  10(capacity)</span></span><br><span class="line">b := <span class="built_in">append</span>(a, <span class="number">1</span>)					<span class="comment">// b ---&gt; 0x1234  1(data)   1(length)  10(capacity)		// a和b指向的底层数组是一致的，但a长度为0，b长度为1</span></span><br><span class="line">_ = <span class="built_in">append</span>(a, <span class="number">2</span>)					<span class="comment">// a和b指向的底层数组是相同的，此行修改了底层数组，a长度为0，append 2直接将array[0] = 2 (之前array[0] == 1 被覆盖)</span></span><br><span class="line"><span class="built_in">println</span>(b[<span class="number">0</span>])			<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="typename">int</span>&#123;<span class="number">5</span>&#125;					<span class="comment">// 0x1234(array add)  5(data)      1(length)  1(capacity)</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">7</span>)			<span class="comment">// 0x5678(array add)  5,7(data)    2(length)  2(capacity)		// 由于容量不够，capacity*2生成新slice(地址改变)</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">9</span>)			<span class="comment">// 0x9abc(array add)  5,7,9,[0](data)  3(length)  4(capacity)		// 由于容量不够，capacity*2生成新slice(地址改变)</span></span><br><span class="line">x := <span class="built_in">append</span>(s, <span class="number">11</span>)		<span class="comment">// 0x9abc(array add)  5,7,9,11(data)  4(length)  4(capacity)		// 由于上次的扩容，容量足够，无生成新slice</span></span><br><span class="line">y := <span class="built_in">append</span>(s, <span class="number">12</span>)		<span class="comment">// 0x9abc(array add)  5,7,9,12(data)  4(length)  4(capacity)		// 由于上次的扩容，容量足够，无生成新slice导致数据覆盖</span></span><br><span class="line">fmt.Println(s, x, y)	<span class="comment">// [5 7 9] [5 7 9 12] [5 7 9 12]</span></span><br></pre></td></tr></table></figure>
<p>slice小技巧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个slice</span></span><br><span class="line">a = <span class="built_in">append</span>(a, b...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除[i, j)之间的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[j:]...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除位置i的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置i扩展长度为j的slice</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>(<span class="built_in">make</span>([]T, j), a[i:]...)...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在位置i插入元素j</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]T&#123;j&#125;, a[i:]...)...)</span><br></pre></td></tr></table></figure>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h4><p>map是<strong>无序</strong>的key/value对集合，<strong><code>map[K]V</code></strong>。map中所有key为同一类似，所有value为同一类型</p>
<p>map的key类型必须为支持比较操作<code>==</code>的数据类型，所以<code>slice</code>、<code>map</code> 和 <code>function</code>类型无法做为map的key。map的key类型无任何限制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> echo() <span class="typename">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"testMap"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  ages := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>&#123;<span class="string">"alice"</span>: <span class="number">31</span>&#125;</span><br><span class="line">  ages[echo()]++			<span class="comment">// 使用echo()返回的string作为key</span></span><br><span class="line">  fmt.Println(ages)		<span class="comment">// map[alice:31 testMap:1]</span></span><br><span class="line">  ages[echo]++				<span class="comment">// panic!!!	cannot use echo (type func() string) as type string in map index  echo为函数类型，不能作为key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建map可直接使用内置<code>make()</code>函数，也可用map字面值初始化方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)		<span class="comment">// make()方式创建</span></span><br><span class="line">ages[alice] = <span class="number">31</span></span><br><span class="line"></span><br><span class="line">ages := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span> &#123;			<span class="comment">// map字面值初始化方式创建</span></span><br><span class="line">  <span class="string">"alice"</span>: <span class="number">31</span>,</span><br><span class="line">  <span class="string">"charlie"</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ages := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>&#123;&#125;		<span class="comment">// map字面值创建空map</span></span><br></pre></td></tr></table></figure>
<p>map通过key下标访问value；通过<code>delete()</code>删除元素；通过<code>for/range</code>遍历map，遍历输出的<strong>顺序是随机的</strong>；通过<code>if/ok</code>判断是否存在value</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(ages[<span class="string">'alice'</span>])		<span class="comment">// 31</span></span><br><span class="line"><span class="built_in">delete</span>(ages, <span class="string">"alice"</span>)					<span class="comment">// 删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> ages &#123;	<span class="comment">// map遍历，随机输出</span></span><br><span class="line">  fmt.Println(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过sort.Strings实现顺序输出</span></span><br><span class="line">names := []stirng</span><br><span class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</span><br><span class="line">  names = <span class="built_in">append</span>(names, name)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(names)</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">  fmt.Println(name, ages[name])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在key/value</span></span><br><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">"bob"</span>]; !ok &#123;</span><br><span class="line">  <span class="comment">// not exists</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明map后必须要创建map后才可进行赋值操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testMap <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span></span><br><span class="line">testMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)		<span class="comment">// 声明后必须使用make()创建才可使用</span></span><br><span class="line">testMap[<span class="string">"alice"</span>] = <span class="number">31</span></span><br></pre></td></tr></table></figure>
<p>map中的value是<strong>不可寻址</strong>的，对map的value进行取地址操作或让value出现在赋值语句<code>=</code>左边都会引起panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ := &amp;ages[<span class="string">"alice"</span>]		<span class="comment">// panic!!! cannot take the address of ages["alice"]  map中value不可寻址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  m := <span class="keyword">map</span>[<span class="typename">string</span>]Student&#123;<span class="string">"people"</span>: &#123;<span class="string">"test"</span>&#125;&#125;</span><br><span class="line">  <span class="comment">//m := map[string]*Student&#123;"people": &#123;"test"&#125;&#125;		// 解决办法</span></span><br><span class="line">  m[<span class="string">"people"</span>].name = <span class="string">"test1"</span>				<span class="comment">// panic!!!	赋值语句=的左边对象必须是可寻址的,或者是map的index操作，或者是_，m["people"].name 是不可寻址的，不能在赋值语句左边</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(m[<span class="string">"people"</span>].name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a><strong>Struct</strong></h4><p>struct结构体是由零个或多个任意类型的值组合而成，值称为结构体的成员，成员通过<code>.</code>点操作符访问，如：<code>struct.member</code>，不包含任何成员的结构体为空结构体<code>struct{}</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;		<span class="comment">// 声明struct</span></span><br><span class="line">    ID        <span class="typename">int</span></span><br><span class="line">    Name      <span class="typename">string</span></span><br><span class="line">    Address   <span class="typename">string</span></span><br><span class="line">    DoB       time.Time</span><br><span class="line">    Position  <span class="typename">string</span></span><br><span class="line">    Salary    <span class="typename">int</span></span><br><span class="line">    ManagerID <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dilbert Employee		<span class="comment">// 声明Employee类型变量</span></span><br><span class="line">dilbert.Salary += <span class="number">500</span>		<span class="comment">// 通过点符号操作成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构体字面值构建结构体</span></span><br><span class="line">albert := Empolyee&#123;<span class="number">1</span>, <span class="string">"albert"</span>&#125;			<span class="comment">// 不指定成员名，但顺序比较和声明struct的成员顺序一致</span></span><br><span class="line">lily := Empolyee&#123;ID: <span class="number">2</span>, Name: <span class="string">"lily"</span>, Position: <span class="string">"china"</span>&#125;		<span class="comment">// 使用成员名构建struct，被忽略的其他成员使用对应类型的零值</span></span><br></pre></td></tr></table></figure>
<p>相同类型的结构体是可以进行比较的，结构体是否是相同类型，取决于以下2点：</p>
<ol>
<li>成员类型、成员个数相同</li>
<li>成员<strong>顺序</strong>相同</li>
</ol>
<p>成员名<strong>首字母是否大小写</strong>决定其能否导出，首字母大写的成员可导出(包外可访问)</p>
<p>复合类型(<code>array</code>、<code>struct</code>)的值不能包含其自身，即S结构体类型将不能再有S类型的成员，但可有<code>*S</code>指针类型的成员</p>
<p>struct允许嵌套，即一个struct中嵌入另一个struct</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Center Point</span><br><span class="line">    Radius <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle Circle</span><br><span class="line">    Spokes <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.Circle.Center.X = <span class="number">8</span></span><br><span class="line">w.Circle.Center.Y = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>struct还支持<strong>匿名成员</strong>，即只声明成员的类型，而不指名成员的名称，但<strong>匿名成员的类型必须是命名类型或指向命名类型的指针</strong>。其实匿名成员的名称既是其命名类型的名称(隐式名称)，由于此，所以不能有两个类型相同的匿名成员，否则会导致成员名称冲突</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point						<span class="comment">// 匿名成员</span></span><br><span class="line">    Radius <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle					<span class="comment">// 匿名成员</span></span><br><span class="line">    Spokes <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span>			<span class="comment">// 相当于w.Circle.Point.X</span></span><br><span class="line">w.Y = <span class="number">8</span>     <span class="comment">// 相当于w.Circle.Point.Y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名类型的字面值初始化</span></span><br><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle: Circle&#123;		<span class="comment">// 此处可看出匿名成员的名称既是其命名类型的名称</span></span><br><span class="line">        Point:  Point&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>&#125;,</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Json"><a href="#Json" class="headerlink" title="Json"></a><strong>Json</strong></h4><p>在需要对struct结构体成员添加额外元信息时，会使用到<strong>成员tag</strong>。通常以<strong>key:“value”</strong>形式存在，key为<code>encoding/&lt;key&gt;</code>包的名称，表示添加哪种格式的信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title  <span class="typename">string</span></span><br><span class="line">    Year   <span class="typename">int</span>  <span class="string">`json:"released"`</span>				<span class="comment">// 因为需要被enconding/json包使用，成员名首字母必须大写</span></span><br><span class="line">    Color  <span class="typename">bool</span> <span class="string">`json:"color,omitempty"`</span>	<span class="comment">// omitempty选项，表示当Go语言结构体成员为空或零值时不生成JSON对象</span></span><br><span class="line">    Actors []<span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> movies = []Movie&#123;</span><br><span class="line">    &#123;Title: <span class="string">"Casablanca"</span>, Year: <span class="number">1942</span>, Color: <span class="constant">false</span>,</span><br><span class="line">        Actors: []<span class="typename">string</span>&#123;<span class="string">"Humphrey Bogart"</span>, <span class="string">"Ingrid Bergman"</span>&#125;&#125;,</span><br><span class="line">    &#123;Title: <span class="string">"Cool Hand Luke"</span>, Year: <span class="number">1967</span>, Color: <span class="constant">true</span>,</span><br><span class="line">        Actors: []<span class="typename">string</span>&#123;<span class="string">"Paul Newman"</span>&#125;&#125;,</span><br><span class="line">    &#123;Title: <span class="string">"Bullitt"</span>, Year: <span class="number">1968</span>, Color: <span class="constant">true</span>,</span><br><span class="line">        Actors: []<span class="typename">string</span>&#123;<span class="string">"Steve McQueen"</span>, <span class="string">"Jacqueline Bisset"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="struct-to-json"><a href="#struct-to-json" class="headerlink" title="struct to json"></a><strong>struct to json</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jsonBytes, err := json.Marshal(movies)</span><br><span class="line"><span class="comment">// jsonBytes, err := json.MarshalIndent(movies, "", "    ")				// 格式化输出</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="typename">string</span>(jsonBytes))</span><br></pre></td></tr></table></figure>
<h5 id="json-to-struct"><a href="#json-to-struct" class="headerlink" title="json to struct"></a><strong>json to struct</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := <span class="string">`&#123;</span><br><span class="line">        "title": "Casablanca",</span><br><span class="line">        "released": 1942,</span><br><span class="line">        "actors": ["Humphrey Bogart","Ingrid Bergman"]</span><br><span class="line">        &#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> movie Movie</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="typename">byte</span>(jsonStr), &amp;movie); err != <span class="constant">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(movie)</span><br></pre></td></tr></table></figure>
<h5 id="map-to-json"><a href="#map-to-json" class="headerlink" title="map to json"></a><strong>map to json</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mapJson := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">"title"</span>:    <span class="string">"Casablanca"</span>,</span><br><span class="line">  <span class="string">"released"</span>: <span class="number">1942</span>,</span><br><span class="line">  <span class="string">"actors"</span>:   <span class="string">`["Humphrey Bogart","Ingrid Bergman"]`</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jsonBytes, err := json.Marshal(mapJson)</span></span><br><span class="line">jsonBytes, err := json.MarshalIndent(mapJson, <span class="string">""</span>, <span class="string">"    "</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="typename">string</span>(jsonBytes))</span><br></pre></td></tr></table></figure>
<h5 id="json-to-map"><a href="#json-to-map" class="headerlink" title="json to map"></a><strong>json to map</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := <span class="string">`&#123;</span><br><span class="line">        "title": "Casablanca",</span><br><span class="line">        "released": 1942,</span><br><span class="line">        "actors": ["Humphrey Bogart","Ingrid Bergman"]</span><br><span class="line">    &#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> movieMap <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="typename">byte</span>(jsonStr), &amp;movieMap); err != <span class="constant">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(movieMap)</span><br></pre></td></tr></table></figure>

				</div>

				

					<div class="content-tag">

						 <a class="tag-link" href="/tags/GO/">GO</a>

					</div>

				

			</article>

			<div class="content-nav">

				
					<a href="/2019/05/15/golang-bible-1/" title="Go语言圣经笔记-下">&larr; Prev</a>
				

				
					<a href="/2019/04/05/jaeger/" title="OpenTracing & Jaeger">Next &rarr;</a>
				

			</div>

		</div>


	</div>

	<div class="row">
	<p class="theme">Powered: <a href="http://hexo.io/"  target="_blank">Hexo</a>, Theme: <a href="https://github.com/samwhelp/hexo-theme-nadya" target="_blank">Nadya</a> remastered from <a href="https://github.com/nadymain/hexo-theme-nadymain" target="_blank">NadyMain</a></p>
</div>

	<!-- <div class="row">
	<p class="theme">Powered: <a href="http://hexo.io/"  target="_blank">Hexo</a>, Theme: <a href="https://github.com/samwhelp/hexo-theme-nadya" target="_blank">Nadya</a> remastered from <a href="https://github.com/nadymain/hexo-theme-nadymain" target="_blank">NadyMain</a></p>
</div>
 -->

</body>
</html>
