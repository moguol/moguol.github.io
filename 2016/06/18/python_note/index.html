<!DOCTYPE html>
<html lang="zh-Hant-TW">

	

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title> 墨 痕 </title>
	<meta property="og:title" content=" Python回炉记 | Hexo " />
	<meta name="twitter:title" content=" Python回炉记 | Hexo ">

	<meta property="og:type" content="article">
	<meta name="twitter:card" content="summary">

	<meta name="description" content=" Python回炉记 | Hexo ">
	<meta property="og:description" content=" Python回炉记 | Hexo " />
	<meta name="twitter:description" content=" Python回炉记 | Hexo " />

	<link rel="icon" type="image/x-icon" href="http://yoursite.com/asset/img/favicon.png">

	<link rel="image_src" href="http://yoursite.com/asset/img/logo.png" >
	<meta property="og:image" content="http://yoursite.com/asset/img/logo.png" />

	
	<link href="http://yoursite.com/atom.xml" title="Hexo" type="application/atom+xml" rel="alternative">
	

	<link rel="canonical" href="/2016/06/18/python_note/index.html">

	<link rel="stylesheet" href="/asset/css/main.css">

</head>


<body>

	
	<header class="site-header">

		
		<nav class="nav-page">

			<div class="row">

				<ul>

					

					<li><a href="/">Home</a></li>

					

					<li><a href="/archives">Sitemap</a></li>

					

					<li><a href="/atom.xml">Rss</a></li>

					

				</ul>

			</div>

		</nav>


		<div class="site-header-main">

			<div class="row">

				<h1><a href="/">墨 痕</a></h1>
				<h6><a href="/">fatesai#gmail.com</a></h6>

				

			</div>

		</div>

		


		<nav class="nav-cat">

			<div class="row">

				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/OPS/">OPS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/">TCP/IP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li></ul>

			</div>

		</nav>




	</header>


	<div id="content" class="site-content">

		
		<div class="row content-post">
			<article itemscope itemtype="http://schema.org/Article">

				

				

				<p class="content-meta">
					<span class="meta-date" itemprop="datePublished" content="2016-06-18">2016-06-18</span>

					
					  <span class="meta-cat">
						<a class="category-link" href="/categories/Python/">Python</a>
					  </span>
					
				</p>

				

					<h2 class="content-title">
						<a href="/2016/06/18/python_note/" itemprop="url"><span itemprop="name">Python回炉记</span></a>
					</h2>

				


				<div class="content" itemprop="articleBody">
					<p>&emsp;所谓回炉，即回炉重练。以前学Python只是抱着玩玩的心态学，但现在下定决心要好好认真学习。于是决定完全重头开始学起，主要是根据Python2.7的官方文档和网上诸多的资料来学。由于资料繁多且杂乱无法一一列举，仅将回炉所学记录以便日后翻阅。</p>
<h2 id="一、计算"><strong>一、计算</strong></h2><ul>
<li><strong><code>/</code></strong>——除法：返回的类型取决于它的操作数。如果两个操作数都是int，将采用<strong>floor</strong>除法并返回一个int。如果两个操作数中有一个是float，将采用传统的除法并返回一个float。</li>
<li><strong><code>//</code></strong>——floor除法：无论操作数是什么类型，都将采用floor除法并返回一个int。</li>
<li><strong><code>%</code></strong>——求余：求取余数</li>
<li><strong>**</strong>——乘方：幂运算。<code>**</code>的优先级高于<code>-</code>，<code>-3**2</code>解析为<code>-(3**2)</code>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">17</span> / <span class="number">3</span>  <span class="comment"># int / int -&gt; int</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">17</span> / <span class="number">3.0</span>  <span class="comment"># int / float -&gt; float</span></span><br><span class="line"><span class="number">5.666666666666667</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">17</span> // <span class="number">3.0</span>  <span class="comment"># explicit floor division discards the fractional part</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span>  <span class="comment"># the % operator returns the remainder of the division</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">5</span> * <span class="number">3</span> + <span class="number">2</span>  <span class="comment"># result * divisor + remainder</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">5</span> ** <span class="number">2</span>  <span class="comment"># 5 squared</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、字符串"><strong>二、字符串</strong></h2><ul>
<li>字符串用单引号或双引号括起，可用<code>\\</code>转义引号。</li>
<li>使用<strong>原始字符串</strong>，在引号前加上<strong><code>r</code></strong>：<code>print r&#39;C:\some\name&#39;</code>(<code>\n</code>则不会被当成换行符)</li>
<li><p>字符串可用<strong><code>+</code></strong>实现连接，用<strong><code>*</code></strong>实现重复</p>
  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="number">3</span> * <span class="string">'un'</span> + <span class="string">'ium'</span></span><br><span class="line"><span class="string">'unununium'</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; prefix = <span class="string">'Py'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; prefix + <span class="string">'thon'</span></span><br><span class="line"><span class="string">'Python'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>索引</strong><br>  字符串可<strong>索引</strong>，第一个字符的索引值为0。Python<strong>没有单独的字符类型</strong>；<strong>一个字符就是一个简单的长度为1的字符串</strong>。</p>
  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word = <span class="string">'Python'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">0</span>]  <span class="comment"># character in position 0</span></span><br><span class="line"><span class="string">'P'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">5</span>]  <span class="comment"># character in position 5</span></span><br><span class="line"><span class="string">'n'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[-<span class="number">1</span>]  <span class="comment"># last character</span></span><br><span class="line"><span class="string">'n'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[-<span class="number">2</span>]  <span class="comment"># second-last character</span></span><br><span class="line"><span class="string">'o'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[-<span class="number">6</span>]</span><br><span class="line"><span class="string">'P'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>切片</strong><br>  字符串还支持<strong>切片</strong>操作。切片的索引有默认值——省略的第一个索引默认为零，省略的第二个索引默认为切片的字符串的大小。</p>
  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">0</span><span class="symbol">:</span><span class="number">2</span>]  <span class="comment"># characters from position 0 (included) to 2 (excluded)</span></span><br><span class="line"><span class="string">'Py'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">2</span><span class="symbol">:</span><span class="number">5</span>]  <span class="comment"># characters from position 2 (included) to 5 (excluded)</span></span><br><span class="line"><span class="string">'tho'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#试图使用太大的索引会导致错误</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">42</span>]  <span class="comment"># the word only has 7 characters</span></span><br><span class="line"><span class="constant">Traceback</span> (most recent call last)<span class="symbol">:</span></span><br><span class="line">  <span class="constant">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="constant">IndexError</span><span class="symbol">:</span> string index out of range</span><br><span class="line"></span><br><span class="line"><span class="comment">#当用于切片时，超出范围的切片索引则不会导致错误而是会被优雅处理</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">4</span><span class="symbol">:</span><span class="number">42</span>]</span><br><span class="line"><span class="string">'on'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">42</span><span class="symbol">:</span>]</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不可变性</strong><br>  Python中字符串(string)是<strong>不可变的</strong>，若赋值给字符串索引的位置会导致错误</p>
</li>
<li><strong>长度</strong><br>  内置函数<strong><code>len()</code></strong>可返回字符串长度  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; s = <span class="string">'supercalifragilisticexpialidocious'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; len(s)</span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、列表"><strong>三、列表</strong></h2><ul>
<li><p><strong>索引</strong> &amp; <strong>分片</strong> &amp; <strong>连接</strong><br>  列表(list)和字符串一样支持索引、分片和连接操作</p>
  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; squares[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; squares[-<span class="number">3</span><span class="symbol">:</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; squares + [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可变性</strong><br>  与字符串的不可变性不同，列表是<strong>可变</strong>的类型，可改变列表的内容且常常使用<strong>append()</strong>方法在列表末尾添加新元素，用<strong>len()</strong>方法获取列表长度</p>
  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; squares</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; squares[<span class="number">3</span>] = <span class="number">64</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; squares</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">64</span>, <span class="number">25</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; squares.append(<span class="number">100</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; squares</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">64</span>, <span class="number">25</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四、控制流"><strong>四、控制流</strong></h2><h3 id="if语句"><strong>if语句</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"x &lt; 0"</span></span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"x == 0"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"x &gt; 0"</span></span><br></pre></td></tr></table></figure>
<h3 id="for语句"><strong>for语句</strong></h3><p>&emsp;Python的for语句按照元素出现的顺序迭代任何序列（列表或字符串）<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">words</span> = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="keyword">for</span> each_word <span class="operator">in</span> <span class="keyword">words</span>:</span><br><span class="line">    print each_word, <span class="built_in">len</span>(each_word)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;迭代序列不会隐式地创建副本，若要修改正在循环的序列则需要使用分片创建副本<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each_word <span class="keyword">in</span> words[:]:</span><br><span class="line">    <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(each_word)</span></span> &gt; <span class="number">4</span>:</span><br><span class="line">        words.<span class="function"><span class="title">insert</span><span class="params">(<span class="number">0</span>, each_word)</span></span></span><br><span class="line">print words</span><br></pre></td></tr></table></figure></p>
<h3 id="range()"><strong>range()</strong></h3><p>&emsp;产生数字序列。给定的终点永远不会在生成的列表中，可以指定一个不同的步进值默认为1<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">range</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">range</span><span class="params">(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>)</span></span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="定义函数"><strong>定义函数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for myfunc"""</span></span><br><span class="line">    <span class="keyword">print</span> n</span><br><span class="line"></span><br><span class="line">myfunc(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>def</code></strong>：引入函数的<strong>定义</strong></li>
<li><strong><code>myfunc(n)</code></strong>：函数名及以括号标明的形式参数列表</li>
<li><strong><code>&quot;&quot;&quot;docstring for myfunc&quot;&quot;&quot;</code></strong>(可选)：文档字符串，可通过<code>myfunc.__doc__</code>获取</li>
<li><strong><code>print n</code></strong>：函数体，必须<strong>缩进</strong><br>&emsp;执行一个函数时会使用到函数的局部变量符号表，函数的所有赋值都将值存储在局部符号表中。变量引用的优先查找顺序：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">局部符号表——&gt;上层函数的局部符号表——&gt;全局符号表——&gt;内置名字表</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;若函数中没有<strong><code>return</code></strong>或存在不带表达式参数的<strong><code>return</code></strong>，函数会直接返回<strong><code>None</code></strong></p>
<h4 id="默认参数值"><strong>默认参数值</strong></h4><p>&emsp;函数的接收参数可提供默认值。如下函数<code>myfunc(name, age=10)</code>中，<code>age</code>参数的默认值即为<code>10</code>，在调用函数<code>myfunc()</code>是若不传递<code>age</code>的值则使用默认值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(name, age=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for myfunc"""</span></span><br><span class="line">    <span class="keyword">print</span> name, age</span><br><span class="line"></span><br><span class="line">myfunc(<span class="string">'mogl'</span>)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;关于默认参数值有个非常需要注意的地方：默认参数值是在<strong>函数定义时就已经确定</strong>。定义后的所有函数调用，若参数不是<strong>显示</strong>的给予赋值的话，那么该默认参数一直都是引用函数定义时所确定的对象。<br>&emsp;如果默认参数是一个<strong>不可变</strong>的对象(string/num/tuple)，那么在函数体内修改该参数，该参数会会重新引用新的不可变对象的内存地址。<br>&emsp;如果默认参数是一个<strong>可变</strong>的对象(list/dict)，那么在函数体内修改该参数，实际上是对函数定义时就已确定的对象的修改。</p>
<ul>
<li><p>默认参数值为不可变对象</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(arg=i)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for f"""</span></span><br><span class="line">	<span class="keyword">print</span> arg</span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">f()		<span class="comment">#结果是5</span></span><br></pre></td></tr></table></figure>
<p>  &emsp;参数<code>arg</code>在函数定义时被确定，在函数定义时<code>i=5</code>，故<code>arg=5</code>。在后续调用函数时<code>fu()</code>并没有<strong>显示</strong>的对<code>arg</code>进行赋值，故<code>arg</code>使用的是函数定义时确定的对象引用的内存地址。</p>
</li>
<li><p>默认参数值为可变对象</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(a, L=[])</span>:</span></span><br><span class="line">    <span class="string">"""docstring for myfunc"""</span></span><br><span class="line">	L.append(a)</span><br><span class="line">	<span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> myfunc(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> myfunc(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> myfunc(<span class="number">3</span>)</span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">print</span> myfunc(<span class="number">4</span>, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果为</span></span><br><span class="line"><span class="comment">#[1]</span></span><br><span class="line"><span class="comment">#[1, 2]</span></span><br><span class="line"><span class="comment">#[1, 2, 3]</span></span><br><span class="line"><span class="comment">#[4]</span></span><br></pre></td></tr></table></figure>
<p>  &emsp;由于默认参数在函数定义时确定，当<code>myfunc(1)</code>、<code>myfunc(2)</code>和<code>myfunc(3)</code>调用函数是并没有<strong>显示</strong>的对默认参数<code>L</code>进行赋值，故三个函数调用使用的都是在函数定义时确定的对象，所以在函数体内进行修改也是对函数定义时就确定的对象进行修改，故三个函数调用共享使用函数定义时确定的对象<code>L</code>。</p>
</li>
</ul>
<h4 id="任意位置参数、关键字参数"><strong>任意位置参数、关键字参数</strong></h4><ul>
<li><p><strong><code>任意位置参数——*args</code></strong><br>  &emsp;函数可使用<code>*args</code>接受任意长度的位置参数，这些参数会被放入一个<strong>元组(tuple)</strong>中。但当<code>*args</code>接收的就是是一个列表或元组时，则会对接收的列表/元组进行<font color="red"><strong>拆分</strong></font>。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(*args)</span>:</span></span><br><span class="line">   <span class="string">"""docstring for myfunc"""</span></span><br><span class="line">   <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"In myfunc(*args)："</span>, arg</span><br><span class="line">   <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> myfunc(<span class="string">'one'</span>, <span class="string">'two'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#In myfunc(*args)： one</span></span><br><span class="line"><span class="comment">#In myfunc(*args)： two</span></span><br><span class="line"><span class="comment">#('one', 'two')		#返回的是一个元组(tuple)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>任意关键字参数——\*\*kwargs</code></strong><br>  &emsp;函数可使用<code>**kwargs</code>接受任意长度的关键字参数，这些参数会被存入一个<strong>字典(dict)</strong>中</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">   <span class="string">"""docstring for myfunc"""</span></span><br><span class="line">   <span class="keyword">for</span> kw <span class="keyword">in</span> kwargs.keys():</span><br><span class="line">       <span class="keyword">print</span> kw, kwargs[kw]</span><br><span class="line">   <span class="keyword">return</span> kwargs</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> myfunc(name=<span class="string">"mogl"</span>, age=<span class="number">10</span>, gender=<span class="string">'man'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gender man</span></span><br><span class="line"><span class="comment">#age 10</span></span><br><span class="line"><span class="comment">#name mogl</span></span><br><span class="line"><span class="comment">#&#123;'gender': 'man', 'age': 10, 'name': 'mogl'&#125;	#返回的是一个字典(dict)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>混合参数<br>  &emsp;混合参数按照此次序定义：<strong>必选参数——&gt;可选参数——&gt;任意位置参数——&gt;任意关键字参数</strong></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(name, test=None, *args, **kwargs)</span>:</span></span><br><span class="line">   <span class="string">"""docstring for myfunc"""</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"name: "</span>, name</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"args: "</span>, args</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"kwargs: "</span>, kwargs</span><br><span class="line"></span><br><span class="line">myfunc(<span class="string">'mogl'</span>, <span class="string">'moguoliang'</span>, <span class="string">'mogl'</span>, age=<span class="number">10</span>, gender=<span class="string">'man'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#name:  mogl</span></span><br><span class="line"><span class="comment">#args:  ('moguoliang', 'mogl')</span></span><br><span class="line"><span class="comment">#kwargs:  &#123;'gender': 'man', 'age': 10&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="lambda表达式"><strong>lambda表达式</strong></h3><p>&emsp;Lambda 函数可以用于任何需要函数对象的地方，用于构造匿名函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_incrementor</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for make_incrementor"""</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line"></span><br><span class="line">func = make_incrementor(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">print</span> func(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> func(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#42</span></span><br><span class="line"><span class="comment">#43</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#单参数</span></span><br><span class="line">mylambda = <span class="keyword">lambda</span> x: x * <span class="number">2</span></span><br><span class="line"><span class="keyword">print</span> mylambda(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多参数</span></span><br><span class="line">mylambda = <span class="keyword">lambda</span> x, y, z: (x - y) * z</span><br><span class="line"><span class="keyword">print</span> mylambda(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结合map()函数</span></span><br><span class="line">mylist = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">print</span> map(<span class="keyword">lambda</span> x: x * <span class="number">2</span> + <span class="number">10</span>, mylist)</span><br><span class="line"><span class="comment">#[14, 18, 22, 26, 30]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="五、数据结构"><strong>五、数据结构</strong></h2><h3 id="列表"><strong>列表</strong></h3><h4 id="列表常用方法"><strong>列表常用方法</strong></h4><ul>
<li><strong><code>list.append(x)</code></strong>：添加一个元素到列表的末尾</li>
<li><strong><code>list.extend(list2)</code></strong>：将指定列表中的所有元素附加到另一个列表的末尾</li>
<li><strong><code>list.insert(i, x)</code></strong>：在给定位置插入一个元素。第一个参数是插入的元素的索引，所以 a.insert(0, x) 在列表的最前面插入，a.insert(len(a), x) 相当于 a.append(x)</li>
<li><strong><code>list.remove(x)</code></strong>：删除列表中第一个值为 x 的元素。如果没有这样的元素将会报错</li>
<li><strong><code>list.pop()/list.pop(i)</code></strong>：删除列表中指定位置的元素并返回它。如果未指定索引，a.pop()将删除并返回列表中的最后一个元素</li>
<li><strong><code>list.index(x)</code></strong>：返回列表中第一个值为 x 的元素的索引。如果没有这样的元素将会报错</li>
<li><strong><code>list.count(x)</code></strong>：返回列表中 x 出现的次数</li>
<li><strong><code>list.sort(cmp=None, key=None, reverse=False)</code></strong>：原地排序列表中的元素</li>
<li><strong><code>list.reverse()</code></strong>：反转列表中的元素</li>
</ul>
<h4 id="栈"><strong>栈</strong></h4><p>&emsp;把列表(List)作为栈使用(后进先出)，使用<strong><code>append()</code></strong>在栈顶添加元素，使用<strong><code>pop()</code></strong>将栈顶元素取出。</p>
<h4 id="队列"><strong>队列</strong></h4><p>&emsp;把列表(List)作为队列使用(先进先出)，为了能快速在列表开头添加/弹出元素使用<strong><code>collections.deque</code></strong>快速在列表两端快速添加/弹出元素。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line">mylist = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line">queue = <span class="function"><span class="title">deque</span><span class="params">(mylist)</span></span></span><br><span class="line">queue.<span class="function"><span class="title">append</span><span class="params">(<span class="string">'four'</span>)</span></span></span><br><span class="line">print queue</span><br><span class="line">queue.<span class="function"><span class="title">popleft</span><span class="params">()</span></span></span><br><span class="line">print queue</span><br><span class="line"></span><br><span class="line">#<span class="function"><span class="title">deque</span><span class="params">([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</span></span></span><br><span class="line">#<span class="function"><span class="title">deque</span><span class="params">([<span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="filter()、map()、reduce()"><strong>filter()、map()、reduce()</strong></h4><ul>
<li><p><strong>filter()</strong><br>  &emsp;<strong><code>filter(function, sequence)</code></strong>，返回<code>function(item)</code>结果为真的元素组成序列。如果<code>sequence</code>是一个<strong>字符串</strong>或<strong>元组</strong>，结果将是相同的类型；否则，结果将始终是一个列表。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回不能被2和3整除的序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(x)</span>:</span></span><br><span class="line">   	<span class="keyword">return</span> x % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">and</span> x % <span class="number">3</span> != <span class="number">0</span></span><br><span class="line"><span class="keyword">print</span> filter(myfunc, range(<span class="number">2</span>, <span class="number">25</span>))</span><br><span class="line"><span class="comment">#[5, 7, 11, 13, 17, 19, 23]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>map()</strong><br>  &emsp;<strong><code>map(function, sequence)</code></strong>序列中的每一个元素调用<code>function(item)</code>函数并返回结果的列表</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cube</span><span class="params">(x)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x ** <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> map(cube, range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line"><span class="comment">#[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]</span></span><br></pre></td></tr></table></figure>
<p>  &emsp;可传多个序列，但传入的函数必须有和序列数目一致的参数，执行时会依次用各序列上对应元素调用函数(若某个序列比另外一个短，就用 None 代替)。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">   	<span class="keyword">return</span> x + y</span><br><span class="line"><span class="keyword">print</span> map(add, range(<span class="number">0</span>, <span class="number">5</span>), range(<span class="number">10</span>, <span class="number">15</span>))</span><br><span class="line"><span class="comment">#[10, 12, 14, 16, 18]</span></span><br></pre></td></tr></table></figure>
<p>  &emsp;<code>map()</code>函数甚至可用于一<strong>列表的函数</strong></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(x)</span>:</span></span><br><span class="line">   	<span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x + x</span><br><span class="line"></span><br><span class="line">funcs = [multiply, add]</span><br><span class="line"><span class="keyword">for</span> each_num <span class="keyword">in</span> xrange(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">print</span> map(<span class="keyword">lambda</span> x: x(each_num), funcs)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>reduce()</strong><br>  &emsp;<strong><code>reduce(function, sequence)</code></strong>只返回一个值，首先以序列的<strong>前两个元素</strong>调用函数<code>function</code>，然后再以<strong>返回的结果</strong>和<strong>下一个元素</strong>继续调用<code>function</code>，如此循环。如果序列中只有一个元素，将返回这个元素的值；如果<strong>序列为空</strong>，则<strong>引发异常</strong>。为防止序列为空引发异常，可传入蛋三个参数作为初始值，初始值与序列第一个元素调用<code>function</code>(<code>reduce(function, sequence, 0)</code>)。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line"><span class="keyword">print</span> reduce(add, range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line"><span class="comment">#55</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="列表推导式"><strong>列表推导式</strong></h4><p>&emsp;<strong>列表推导式</strong>主要用于快速简洁生成列表。列表推导式由括号括起来，括号里面包含一个表达式，表达式后面跟着一个for语句，后面还可以接零个或更多的for或if语句。结果是一个新的列表，由表达式依据其后面的for和if子句上下文计算而来的结果构成(<code>[ 表达式 for var in sequence if condition]</code>)。<br>&emsp;以下三种方式输出结果都相同<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方式一</span></span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="type">range</span>(<span class="number">10</span>):</span><br><span class="line">    squares.append(x ** <span class="number">2</span>)</span><br><span class="line">print squares</span><br><span class="line"><span class="comment">#[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方式二</span></span><br><span class="line">squares = map(lambda x: x ** <span class="number">2</span>, <span class="type">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#方式三</span></span><br><span class="line">squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="type">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#列表推导式可带if语句</span></span><br><span class="line">squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="type">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x &gt; <span class="number">3</span>]</span><br><span class="line"><span class="comment">#[16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="嵌套列表推导式"><strong>嵌套列表推导式</strong></h4><p>&emsp;列表推导式中的表达式可以是任何表达式，当然包括表达式是一个列表推导式。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#行列置换</span><br><span class="line">matrix = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">]</span><br><span class="line">print [[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(<span class="number">4</span>)</span></span>]</span><br><span class="line">#[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br><span class="line"></span><br><span class="line">#拆分</span><br><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(<span class="number">4</span>)</span></span>:</span><br><span class="line">	transposed_row = []</span><br><span class="line">	<span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">		transposed_row.<span class="function"><span class="title">append</span><span class="params">(row[i])</span></span></span><br><span class="line">	transposed.<span class="function"><span class="title">append</span><span class="params">(transposed_row)</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>zip()</strong><br>  &emsp;其实Python有内置函数<strong>zip()</strong>可实现上面的功能。先说明<code>zip()</code>函数<br>  &emsp;<code>zip()</code>接收多个可迭代对象(list/dict/tuple)作为参数，将这些对象中<strong>对应</strong>的元素打包成若干个元组(tuple)，最后返回这些元组(tuple)为元素所组成的列表(List)，若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list_b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">list_c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">print <span class="function"><span class="title">zip</span><span class="params">(list_a, list_b)</span></span></span><br><span class="line">print <span class="function"><span class="title">zip</span><span class="params">(list_a, list_c)</span></span></span><br><span class="line">#[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line">#[(<span class="number">1</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">9</span>)]</span><br></pre></td></tr></table></figure>
<p>  &emsp;使用<code>zip()</code>函数实现行列置换</p>
  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">matrix</span> = [</span><br><span class="line">	[1, 2, 3, 4],</span><br><span class="line">	[5, 6, 7, 8],</span><br><span class="line">	[9, 10, 11, 12]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">print</span> <span class="keyword">zip</span>(*<span class="keyword">matrix</span>)</span><br><span class="line"><span class="keyword">print</span> map(<span class="keyword">list</span>, <span class="keyword">zip</span>(*<span class="keyword">matrix</span>))</span><br><span class="line">#[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]</span><br><span class="line">#[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span><br></pre></td></tr></table></figure>
<p>  &emsp;参数加上星号表明为此参数为<strong>列表参数</strong>，即接收多个参数并将这些参数组成一个列表。但当此<strong>列表参数</strong>接收的是一个列表或元组时，则会对接收的列表进行<strong>拆分</strong>。<br>  &emsp;<code>*matrix</code>参数会被拆分成<code>[1, 2, 3, 4]</code>、<code>[5, 6, 7, 8]</code>、<code>[9, 10, 11, 12]</code>三个参数传递给<code>zip()</code>函数(<strong><code>zip([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12])</code></strong>)</p>
</li>
</ul>
<h3 id="字典"><strong>字典</strong></h3><p>&emsp;字典(dict)可看做是无序的<strong>键:值(key:value)</strong>对集合，同一字典内<strong>键</strong>必须唯一。一个花括号将创建一个空字典<code>{}</code>，花括号里用<code>,</code>分隔各个<strong>键:值</strong>。字典的主要操作都是通过<strong>键(key)</strong>来进行。<br>&emsp;字典有<strong>键(key)</strong>做索引(序列由数字做索引)，<code>键(key)</code>可是任意<strong>不可变</strong>类型。若元组只包含字符串、 数字或元组，此元组可以用作key；若元组直接或间接地包含任何可变对象，那么它不能用作key。不能用列表(list)作为key。</p>
<h4 id="key()方法"><strong>key()方法</strong></h4><p>&emsp;<strong><code>key()</code></strong>方法返回字典中所有<strong>键(key)</strong>组成的列表，列表中<strong>键(key)</strong>的顺序是随机的。可通过<strong><code>in</code></strong>关键字检查<strong>键(key)</strong>是否存在于字典中。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tel = &#123;<span class="string">'jack'</span>: <span class="number">4098</span>,</span><br><span class="line">       <span class="string">'sape'</span>: <span class="number">4139</span></span><br><span class="line">       &#125;</span><br><span class="line">tel[<span class="string">'guido'</span>] = <span class="number">4127</span></span><br><span class="line"><span class="built_in">print</span> tel</span><br><span class="line">#&#123;<span class="string">'sape'</span>: <span class="number">4139</span>, <span class="string">'jack'</span>: <span class="number">4098</span>, <span class="string">'guido'</span>: <span class="number">4127</span>&#125;</span><br><span class="line"><span class="built_in">print</span> tel[<span class="string">'jack'</span>]</span><br><span class="line">#<span class="number">4098</span></span><br><span class="line"><span class="built_in">print</span> tel.keys()</span><br><span class="line">#[<span class="string">'sape'</span>, <span class="string">'jack'</span>, <span class="string">'guido'</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">'guido'</span> <span class="keyword">in</span> tel.keys()</span><br><span class="line">#True</span><br></pre></td></tr></table></figure></p>
<h4 id="dict()方法"><strong>dict()方法</strong></h4><p>&emsp;<code>dict()</code>构造函数可直接从键值对序列创建字典。同时字典和列表一样都有<strong>推导式</strong>。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> dict([(<span class="string">'sape'</span>, <span class="number">4139</span>), (<span class="string">'guido'</span>, <span class="number">4127</span>), (<span class="string">'jack'</span>, <span class="number">4098</span>)])</span><br><span class="line">#&#123;<span class="string">'sape'</span>: <span class="number">4139</span>, <span class="string">'jack'</span>: <span class="number">4098</span>, <span class="string">'guido'</span>: <span class="number">4127</span>&#125;</span><br><span class="line"><span class="built_in">print</span> dict(sape=<span class="number">4139</span>, guido=<span class="number">4127</span>, jack=<span class="number">4098</span>)</span><br><span class="line">#&#123;<span class="string">'sape'</span>: <span class="number">4139</span>, <span class="string">'jack'</span>: <span class="number">4098</span>, <span class="string">'guido'</span>: <span class="number">4127</span>&#125;</span><br><span class="line"><span class="built_in">print</span> &#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">#&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历技巧"><strong>遍历技巧</strong></h3><ul>
<li><p><strong><code>enumerate()</code></strong><br>  &emsp;遍历序列时，<code>enumerate()</code>可同时获得索引和值</p>
  <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="string">'tic'</span>, <span class="string">'tac'</span>, <span class="string">'toe'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">index</span>, value <span class="keyword">in</span> enumerate(mylist):</span><br><span class="line">	print <span class="keyword">index</span>, value</span><br><span class="line"><span class="string">#0</span> tic</span><br><span class="line"><span class="string">#1</span> tac</span><br><span class="line"><span class="string">#2</span> toe</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>zip()</strong><br>  &emsp;同时遍历多个序列时，<code>zip()</code>可<strong>成对</strong>读取元素</p>
  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">questions = [<span class="string">'name'</span>, <span class="string">'quest'</span>, <span class="string">'favorite color'</span>]</span><br><span class="line">answers = [<span class="string">'lancelot'</span>, <span class="string">'the holy grail'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">for</span> q, a <span class="keyword">in</span> zip(questions, answers):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'What is your &#123;0&#125;?  It is &#123;1&#125;.'</span>.format(q, a)</span><br><span class="line"></span><br><span class="line">#What <span class="keyword">is</span> your name?  It <span class="keyword">is</span> lancelot.</span><br><span class="line">#What <span class="keyword">is</span> your quest?  It <span class="keyword">is</span> the holy grail.</span><br><span class="line">#What <span class="keyword">is</span> your favorite color?  It <span class="keyword">is</span> blue.</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>reversed()</strong><br>  &emsp;反向遍历序列</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">reversed</span><span class="params">(xrange(<span class="number">1</span>, <span class="number">6</span>)</span></span>):</span><br><span class="line">	print <span class="tag">i</span>,</span><br><span class="line">#<span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sorted()</strong><br>  &emsp;排序序列</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basket = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> <span class="function"><span class="title">sorted</span><span class="params">(set(basket)</span></span>):</span><br><span class="line">	print f,</span><br><span class="line"><span class="id">#apple</span> banana orange pear</span><br><span class="line">#<span class="function"><span class="title">set</span><span class="params">(basket)</span></span>去除重复元素</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>iteritems()</strong><br>  &emsp;遍历字典时，<code>iteritems()</code>方法可同时获得键和值</p>
  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">knights = &#123;<span class="string">'gallahad'</span>: <span class="string">'the pure'</span>, <span class="string">'robin'</span>: <span class="string">'the brave'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, <span class="built_in">value</span> <span class="operator">in</span> knights.iteritems():</span><br><span class="line">	print key, <span class="built_in">value</span></span><br><span class="line"><span class="comment">#gallahad the pure</span></span><br><span class="line"><span class="comment">#robin the brave</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改遍历中的序列</strong><br>  &emsp;若要修改正在遍历中的序列，则需先创建副本(序列循环不会隐式创建副本)。</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words[:]:</span><br><span class="line">    <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(w)</span></span> &gt; <span class="number">6</span>:</span><br><span class="line">        words.<span class="function"><span class="title">insert</span><span class="params">(<span class="number">0</span>, w)</span></span></span><br><span class="line">#[<span class="string">'defenestrate'</span>, <span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="六、模块"><strong>六、模块</strong></h2><p>&emsp;模块是包含Python定义和声明的文件。模块中的定义可<strong>导入(import)</strong>到其他模块中。模块名可通过全局变量<strong><code>__name__</code></strong>获得。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#fibo</span><span class="class">.py</span></span><br><span class="line">def <span class="function"><span class="title">fib</span><span class="params">(n)</span></span>:</span><br><span class="line">    <span class="tag">a</span>, <span class="tag">b</span> = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    while <span class="tag">b</span> &lt; n:</span><br><span class="line">        print <span class="tag">b</span>,</span><br><span class="line">        <span class="tag">a</span>, <span class="tag">b</span> = <span class="tag">b</span>, a+<span class="tag">b</span></span><br><span class="line">def <span class="function"><span class="title">fib2</span><span class="params">(n)</span></span>:</span><br><span class="line">    result = []</span><br><span class="line">    <span class="tag">a</span>, <span class="tag">b</span> = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    while <span class="tag">b</span> &lt; n:</span><br><span class="line">        result.<span class="function"><span class="title">append</span><span class="params">(b)</span></span></span><br><span class="line">        <span class="tag">a</span>, <span class="tag">b</span> = <span class="tag">b</span>, a+<span class="tag">b</span></span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"><span class="id">#main</span><span class="class">.py</span></span><br><span class="line">import fibo</span><br><span class="line"></span><br><span class="line">fibo.<span class="function"><span class="title">fib</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line">print fibo.<span class="function"><span class="title">fib2</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line">print fibo.__name__</span><br><span class="line">#<span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></span><br><span class="line">#[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br><span class="line">#fibo</span><br></pre></td></tr></table></figure></p>
<p>&emsp;<strong><code>import fibo</code></strong>只会把模块名<code>fibo</code>导入<strong>符号表</strong>中，不会将<code>fibo.py</code>中定义的函数名导入到符号表，故需要通过模块名访问<code>fibo.py</code>定义的函数。</p>
<h3 id="深入模块"><strong>深入模块</strong></h3><p>&emsp;模块可包含<strong>可执行语句</strong>和<strong>函数的定义</strong>，它们只在<strong>第一次</strong>导入时执行。<br>&emsp;每个模块拥有自己的<strong>私有符号表</strong>，模块内定义的所有函数用该<strong>私有符号表</strong>作为<strong>全局符号表</strong>。</p>
<h4 id="执行模块"><strong>执行模块</strong></h4><p>&emsp;若用以下方式执行<code>fibo</code>模块，模块中的代码会被执行，但此时模块的<strong><code>__name__</code></strong>不在是<code>fibo</code>而是<strong><code>__main__</code></strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python fibo<span class="class">.py</span> &lt;arguments&gt;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;若在<code>fibo.py</code>模块最后添加以下代码，则<code>fibo.py</code>只有在作为可执行脚本调用是才执行以下代码，作为模块被导入时不会执行(因为作为模块被导入时<code>__name__</code>==<code>fibo</code>)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#fibo</span><span class="class">.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    import sys</span><br><span class="line">    <span class="function"><span class="title">fib</span><span class="params">(int(sys.argv[<span class="number">1</span>])</span></span>)</span><br><span class="line"></span><br><span class="line">$&gt; python fibo<span class="class">.py</span> <span class="number">100</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></span><br></pre></td></tr></table></figure></p>
<h4 id="模块搜索路径"><strong>模块搜索路径</strong></h4><p>&emsp;若要导入(import)<code>spam</code>模块，首先会搜索<strong>内置模块</strong>，然后在<code>sys.path</code>变量中所给出的目录搜索<code>spam.py</code>。<br>&emsp;<code>sys.path</code>变量初始值来自以下三个地方(注意<strong>优先级</strong>)</p>
<ul>
<li>脚本所在的<strong>当前目录</strong></li>
<li><strong>PYTHONPATH</strong></li>
<li>与安装相关的默认值</li>
</ul>
<h3 id="包"><strong>包</strong></h3><p>&emsp;包是一种管理 Python 模块命名空间的方式，采用<strong>点分模块名称</strong>。<code>A.B</code>表示包<code>A</code>中名为<code>B</code>的子模块<br>&emsp;若存在一个目录结构如下所示的包<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sound/                          Top-level package</span><br><span class="line">      __init__.py               Initialize the sound package</span><br><span class="line">      formats/                  Subpackage <span class="keyword">for</span> file format conversions</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              <span class="keyword">...</span></span><br><span class="line">      effects/                  Subpackage <span class="keyword">for</span> sound effects</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              <span class="keyword">...</span></span><br><span class="line">      filters/                  Subpackage <span class="keyword">for</span> filters</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br></pre></td></tr></table></figure></p>
<p>&emsp;为了Python能将目录当做包，目录下必须存在<strong><code>__init__.py</code></strong>文件。<strong><code>__init__</code></strong>文件可以是一个空文件，也可以为包执行初始化代码或设置<code>__all__</code>变量。<br>&emsp;对于不同的导入方式，如何使用模块中的内容也不同<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#假设echo.py模块中定义了函数<span class="function"><span class="title">echofilter</span><span class="params">(input, output)</span></span></span><br><span class="line"></span><br><span class="line">#单独导入</span><br><span class="line">import sound<span class="class">.effects</span><span class="class">.echo</span></span><br><span class="line">#调用时必须使用完整名称</span><br><span class="line">import sound<span class="class">.effects</span><span class="class">.echo</span><span class="class">.echofilter</span>(<span class="tag">input</span>, output)</span><br><span class="line"></span><br><span class="line">#导入子模块</span><br><span class="line">from sound<span class="class">.effects</span> import echo</span><br><span class="line">#直接使用子模块</span><br><span class="line">echo.<span class="function"><span class="title">echofilter</span><span class="params">(input, output)</span></span></span><br><span class="line"></span><br><span class="line">#直接导入子模块函数/变量</span><br><span class="line">from sound<span class="class">.effects</span><span class="class">.echo</span> import echofilter</span><br><span class="line">#直接使用函数/变量</span><br><span class="line"><span class="function"><span class="title">echofilter</span><span class="params">(input, output)</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="七、输入输出"><strong>七、输入输出</strong></h2><h3 id="格式化输出"><strong>格式化输出</strong></h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#str.format() 格式化输出</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0:3d&#125;'</span>.<span class="keyword">format</span>(<span class="number">2</span> * <span class="number">3</span>)</span><br><span class="line"><span class="comment">#  6</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0:.3f&#125;'</span>.<span class="keyword">format</span>(<span class="number">2</span> * <span class="number">3</span>)</span><br><span class="line"><span class="comment">#6.000</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0&#125;, &#123;1&#125; and &#123;other&#125;'</span>.<span class="keyword">format</span>(<span class="string">'First'</span>, <span class="string">'Second'</span>, other=<span class="string">'All the rest'</span>)</span><br><span class="line"><span class="comment">#First, Second and All the rest</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'12'</span>.zfill(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#0012</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> str(<span class="number">3</span> ** <span class="number">2</span>).rjust(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#   9</span></span><br><span class="line"><span class="keyword">print</span> str(<span class="number">3</span> ** <span class="number">2</span>).ljust(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#9___	_表示空格</span></span><br><span class="line"><span class="keyword">print</span> str(<span class="number">3</span> ** <span class="number">2</span>).center(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#_9__	_表示空格</span></span><br><span class="line"></span><br><span class="line">import math</span><br><span class="line"><span class="keyword">print</span> <span class="string">'%5.3f'</span> % math.pi</span><br><span class="line"><span class="comment">#3.142</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'%8.3f'</span> % math.pi</span><br><span class="line"><span class="comment">#   3.142</span></span><br></pre></td></tr></table></figure>
<h3 id="读写文件"><strong>读写文件</strong></h3><p>&emsp;一般Python读写文件是先调用<strong><code>open(filename, mode)</code></strong>函数创建一个文件对象，其中<strong><code>mode</code></strong>有如下选项：</p>
<ul>
<li><code>r</code>: 以读方式打开文件，可读取文件信息.<strong>文件必须已存在</strong></li>
<li><code>w</code>: 以写方式打开文件，可向文件写入信息。<strong>存在则清空，不存在创建</strong></li>
<li><code>a</code>: 以追加方式打开文件，文件指针自动移到文件尾。追加</li>
<li><code>r+</code>: 以读写方式打开文件，可对文件进行读和写操作。</li>
<li><code>w+</code>: 消除文件内容，然后以读写方式打开文件。</li>
<li><code>a+</code>: 以读写方式打开文件，并把文件指针移到文件尾。</li>
<li><code>b</code>: 以二进制模式打开文件，而不是以文本模式。该模式只对Windows或Dos有效，类Unix的文件是用二进制模式进行操作的</li>
<li><code>U</code>: 通用换行符支持，任何系统下的文件, 不管换行符是什么, 使用U模式打开时, 换行符都会被替换为NEWLINE(\n)</li>
<li><code>+</code>: 代表同时作为输入和输出文件，可以对相同文件进行读写</li>
<li><code>b</code>: 代表二进制数据处理 和 r/w/a组合.r+ 使用读写方式打开， rb二进制读<br>&emsp;使用<strong><code>open(filename, mode)</code></strong>方法创建对象，操作完后需要手动调用<strong><code>close()</code></strong>方法关闭以释放其所占用的系统资源。为了更加方便对文件进行读写操作Python提供了<strong>with</strong>关键字，<strong>with</strong>关键字在文件操作完后会自动关闭对象不用手动调用<code>close()</code>。<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with <span class="function"><span class="title">open</span><span class="params">(filename, <span class="string">'r'</span>)</span></span> as fd:</span><br><span class="line">    fd.<span class="function"><span class="title">read</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;Python读取文件内容常用函数有：<code>read()</code>、<code>readline()</code>、<code>readlines()</code>和<code>xreadlines()</code></p>
<ul>
<li><code>read()</code>：一次性读取所有内容并将其放到一个字符串变量中</li>
<li><code>readline()</code>：逐行读取并存入列表中</li>
<li><code>readlines()</code>：一次性读取所有内容并存入列表</li>
<li><code>xreadlines()</code>：返回一个迭代器用于循环操作每一行</li>
</ul>
<p>&emsp;Python2.3后支持文件对象迭代功能，所以更推荐使用以下方法遍历文本：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with <span class="function"><span class="title">open</span><span class="params">(<span class="string">'filename'</span>)</span></span> as file_fd:</span><br><span class="line">    <span class="keyword">for</span> each_line <span class="keyword">in</span> file_fd:</span><br><span class="line">        <span class="function"><span class="title">do_things</span><span class="params">(each_line)</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="八、错误与异常"><strong>八、错误与异常</strong></h2><h3 id="处理异常"><strong>处理异常</strong></h3><p>&emsp;使用<code>try...except</code>处理异常<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="keyword">int</span>(raw_input(<span class="string">"Please enter a number: "</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    except (RuntimeError, TypeError, NameError, ValueError):</span><br><span class="line">        print <span class="string">"Oops!  That was no valid number.  Try again..."</span></span><br></pre></td></tr></table></figure></p>
<p>异常处理流程：</p>
<ul>
<li>执行try子句（try和except关键字之间的语句，即<code>x = int(raw_input(&quot;Please enter a number: &quot;))</code>）。</li>
<li>如果未发生任何异常，忽略except子句且try语句执行完毕，无触发异常。</li>
<li>如果在try子句执行过程中发生异常，跳过该子句的其余部分。如果异常的类型与except关键字后面的异常名匹配, 则执行 except 子句，然后继续执行try语句之后的代码。</li>
<li>如果异常的类型与 except 关键字后面的异常名不匹配，它将被传递给上层的try语句；如果没有找到处理这个异常的代码，它就成为一个未处理异常，程序会终止运行并显示一条如上所示的信息。</li>
</ul>
<h3 id="引发异常"><strong>引发异常</strong></h3><p>&emsp;使用<strong><code>raise</code></strong>可手动引发异常<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'An exception flew by!'</span></span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure></p>
<h3 id="自定义异常"><strong>自定义异常</strong></h3><p>&emsp;继承<strong><code>Exception</code></strong>类创建自定义异常<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self.value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyError(<span class="number">2</span>*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> MyError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'My exception occurred, value:'</span>, e.value</span><br></pre></td></tr></table></figure></p>
<h3 id="else_与_finally"><strong>else 与 finally</strong></h3><p>&emsp;<code>try...except</code>还支持<strong><code>else</code></strong>和<strong><code>finally</code></strong>语句。</p>
<ul>
<li><strong><code>else</code></strong>：当<code>try</code>子句中没有抛出异常时则执行<code>else</code>子句。<code>else</code>子句只能出现在所有<code>except</code>子句之后</li>
<li><strong><code>finally</code></strong>：不管异常是否发生，总是会执行<code>finally</code>子句。通常用于释放外部资源</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def divide(x, y):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="literal">result</span> = x / y</span><br><span class="line">    <span class="keyword">except</span> <span class="type">ZeroDivisionError</span>:</span><br><span class="line">        print <span class="string">"division by zero!"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print <span class="string">"result is"</span>, <span class="literal">result</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print <span class="string">"executing finally clause"</span></span><br></pre></td></tr></table></figure>
<h2 id="九、类"><strong>九、类</strong></h2><h3 id="命名空间"><strong>命名空间</strong></h3><p>&emsp;命名空间是从名称到对象的映射。目前为止，命名空间主要通过Python<strong>字典</strong>实现，键是变量名，值是对于的变量值。<br>&emsp;命名空间例子：</p>
<ol>
<li><strong>内置命名空间</strong>：Python内置的函数和异常等，任何模块均可访问。</li>
<li><strong>全局命名空间</strong>：每个模块所拥有的命名空间，记录模块的变量，包括函数、类和导入的模块等。模块的全局命名空间在<strong>读入模块定义时</strong>创建。</li>
<li><strong>局部命名空间</strong>：每个函数所拥有的命名空间，记录函数内的变量和参数等。函数的局部命名空间在函数<strong>被调用时</strong>创建，在函数<strong>返回</strong>或引发内部<strong>没有处理的异常</strong>时被删除。</li>
</ol>
<p>&emsp;不同命名空间中的名称(如函数名)无任何关系(即使是名称相同也可以)。比如A模块中存在一个函数名为<code>maximize</code>的函数，B模块同样也存在是完全没问题的，调用是需指定模块名<code>A.maximize</code>、<code>B.maximize</code>。<br>&emsp;Python查找命名空间的顺序：</p>
<ol>
<li>当前函数的局部命名空间搜索</li>
<li>父函数的局部命名空间搜索</li>
<li>模块的全局命名空间搜索</li>
<li>内置命名空间搜索</li>
</ol>
<h3 id="类定义"><strong>类定义</strong></h3><p>&emsp;类定义最简单形式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ClassName:</span><br><span class="line">    <span class="tag">&lt;<span class="title">statement-1</span>&gt;</span></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="tag">&lt;<span class="title">statement-N</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;进入类定义后，会创建一个新的命名空间，所有的赋值会成为此命名空间的局部变量。类定义正常结束后，一个<strong>类对象</strong>便创建了。</p>
<h3 id="类对象"><strong>类对象</strong></h3><p>&emsp;类对象支持两种操作：</p>
<ul>
<li>属性引用</li>
<li>实例化</li>
</ul>
<p>&emsp;为方便解释，先定义一个类<code>MyClass</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">"""A simple example class"""</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="属性引用"><strong>属性引用</strong></h4><p>&emsp;<strong>属性引用</strong>标准语法为<strong><code>obj.name</code></strong>。有效的属性名为在类对象被创建时该类的命名空间中的所有名称。<br>&emsp;<strong><code>MyClass.i</code></strong>、<strong>MyClass.f</strong>为有效的属性引用，分别返回一个整数和一个函数对象。<strong><code>__doc__</code></strong>也是有效对象，返回一串字符(<code>A simple example class</code>)</p>
<h4 id="实例化"><strong>实例化</strong></h4><p>&emsp;类的<strong>实例化</strong>使用函数符号。可以把类对象看成是一个无参数的函数，该函数返回这个类的一个新实例。<br>&emsp;创建<code>MyClass</code>类的一个新实例，并将该对象赋给局部变量<code>x</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="function"><span class="title">MyClass</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;实例化操作会创建一个空对象，若希望创建的对象在初始状态时能自定义动作，则可定义一个<strong><code>__init__()</code></strong>的特殊方法<br>&emsp;一旦定义了<strong><code>__init__()</code></strong>方法，在实例化创建新的类对象时会自动调用<code>__init__()</code>方法。<code>__init()</code>方法可带参数，在类实例化操作的参数将传递给<code>__init__()</code>方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line">x = MyClass(<span class="string">'mogl'</span>)</span><br><span class="line"><span class="keyword">print</span> x.name</span><br><span class="line"><span class="comment">#mogl</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;当通过实例化操作创建了一个实例对象后，可进行属性引用。有效的属性名大致分为两种：<strong>数据属性</strong>和<strong>方法</strong><br>&emsp;简单的说，数据属性可理解为类当中的变量；方法可理解为类当中的函数</p>
<h3 id="方法对象"><strong>方法对象</strong></h3><p>&emsp;一般情况下，方法被绑定后就可直接调用。以之前定义的类<code>MyClass</code>为例，在定义完类后，实例化创建类对象后可直接调用方法<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#实例化创建类对象x</span><br><span class="line">x = <span class="function"><span class="title">MyClass</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">#直接调用方法<span class="function"><span class="title">f</span><span class="params">()</span></span></span><br><span class="line">x.<span class="function"><span class="title">f</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">#不直接调用：x.f是一个方法对象，可存储后调用</span><br><span class="line">xf = x<span class="class">.f</span></span><br><span class="line"><span class="function"><span class="title">xf</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;类里面的函数<code>def f(self)</code>是有参数的，但调用时却没有传递参数，这和类的方法有关。方法会将实例对象作为函数的第一个参数传递给函数，所以方法定义时带有<code>self</code>参数。当调用<code>x.f()</code>时等同于<code>MyClass.f(x)</code>。</p>
<h3 id="类_&amp;_实例"><strong>类 &amp; 实例</strong></h3><h4 id="可变对象不做类属性"><strong>可变对象不做类属性</strong></h4><p>&emsp;实例变量用于对每一个实例都是唯一的数据<br>&emsp;类变量用于类的所有实例共享的属性和方法<br>&emsp;可变对象(列表/字典)不应用作为类变量，因为所有实例化后的类对象都共享同一个可变的类变量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    tricks = []					<span class="comment">#tricks作为类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">		<span class="comment">#self.tricks = []		#应当将tricks作为实例变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_tricks</span><span class="params">(self, trick)</span>:</span></span><br><span class="line">        <span class="string">"""docstring for add_tricks"""</span></span><br><span class="line">        self.tricks.append(trick)</span><br><span class="line"></span><br><span class="line">d = Dog(<span class="string">'Fido'</span>)</span><br><span class="line">e = Dog(<span class="string">'Buddy'</span>)</span><br><span class="line">d.add_tricks(<span class="string">'roll over'</span>)</span><br><span class="line">e.add_tricks(<span class="string">'play dead'</span>)</span><br><span class="line"><span class="keyword">print</span> d.tricks</span><br><span class="line"><span class="comment">#['roll over', 'play dead']</span></span><br></pre></td></tr></table></figure></p>
<h4 id="类属性_实例属性"><strong>类属性 实例属性</strong></h4><p>&emsp;Python是动态语言，类实例化后的实例可任意添加属性。如果实例属性和类属性具有相同的名称时，实例属性将屏蔽掉类属性。<br>&emsp;Python默认是通过一个字典来保存实例的所有实例属性(通过<code>instance.__dict__</code>可查看)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for Man"""</span></span><br><span class="line">    age = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">a = Man()</span><br><span class="line">b = Man()</span><br><span class="line"><span class="keyword">print</span> a.age, b.age, Man.age</span><br><span class="line"><span class="comment">#30 30 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实例a添加实例属性age</span></span><br><span class="line">a.age = <span class="number">40</span></span><br><span class="line"><span class="keyword">print</span> a.age, b.age, Man.age</span><br><span class="line"><span class="comment">#40 30 30   #a实例属性age覆盖Man类属性</span></span><br><span class="line"></span><br><span class="line">Man.age = <span class="number">50</span></span><br><span class="line"><span class="keyword">print</span> a.age, b.age, Man.age</span><br><span class="line"><span class="comment">#40 50 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> a.__dict__</span><br><span class="line"><span class="keyword">print</span> b.__dict__</span><br><span class="line"><span class="keyword">print</span> Man.__dict__</span><br><span class="line"><span class="comment">#&#123;'age': 40&#125;</span></span><br><span class="line"><span class="comment">#&#123;&#125;</span></span><br><span class="line"><span class="comment">#&#123;'__dict__': &lt;attribute '__dict__' of 'Man' objects&gt;, 'age': 50, '__weakref__': &lt;attribute '__weakref__' of 'Man' objects&gt;, '__module__': '__main__', '__doc__': 'docstring for Man'&#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="slots"><strong><strong>slots</strong></strong></h4><p>&emsp;一般使用<code>__slots__</code>常见的目的有2个：</p>
<ol>
<li>减少内存的使用<br> &emsp;正如上面所说，Python默认会使用字典存储实例的所有实例属性。但一旦需要创建大量实例时，每个实例都会产生一个字典用于存储其自身的实例属性，这样便会占用过多的内存资源。<code>__slots__</code>能使Python不使用字典而且只提供一个固定集合的属性空间，所有的实例都用此空间。</li>
<li>限制添加新属性<br> &emsp;为了限制实例添加新属性，可使用<code>__slots__</code>来限制该类能使用的属性。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'gender'</span>)		<span class="comment">#只能使用name和gender属性，这些属性不存字典而是统一空间中</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">a = Man(<span class="string">'mogl'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="keyword">print</span> a.name, a.gender</span><br><span class="line">a.age = <span class="number">100</span></span><br><span class="line"><span class="keyword">print</span> a.age</span><br><span class="line"></span><br><span class="line"><span class="comment">#mogl male</span></span><br><span class="line"><span class="comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#  File "tmp.py", line 92, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#    a.age = 100</span></span><br><span class="line"><span class="comment">#AttributeError: 'Man' object has no attribute 'age'</span></span><br></pre></td></tr></table></figure>
<h3 id="继承"><strong>继承</strong></h3><p>&emsp;类的其中一个重要特性是<strong>继承</strong>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">DerivedClassName</span><span class="container">(<span class="type">BaseClassName</span>)</span>:</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-<span class="type">N</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;子类的类对象创建后，父类会被保存用于属性引用，当在子类中无法获取请求的属性时会向父类进行搜索。假若父类又是其他类的子类，那么会再向其父类进行搜索，不对递归进行。<br>&emsp;子类能重写父类的方法。若在子类中想要调用父类方法可<strong><code>BaseClassName.methodname(self, arguments)</code></strong></p>
<h4 id="多继承"><strong>多继承</strong></h4><p>&emsp;Python支持一定限度的多继承形式。<del>对于多继承使用<strong>深度优先规则</strong>，从左到右进行搜索。当<code>DerivedClassName</code>中找不到属性时，首先搜索<code>Base1</code>，然后递归搜索<code>Base1</code>的父类，在然后搜索<code>Base2</code>以此类推进行搜索。</del>自Python2.3起采用<strong>C3</strong>算法，按照<strong>MRO(Method Resolution Order)</strong>进行搜索，可使用<code>Class.__mro__</code>查看<strong>MRO</strong>的搜索顺序。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DerivedClassName(Base1, Base2, Base3):</span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">    &lt;statement-N&gt;</span><br><span class="line"></span><br><span class="line">print DerivedClassName.__mro__</span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器"><strong>迭代器</strong></h3><p>&emsp;在Python中利用<code>for</code>语句可方便的遍历很多对象，迭代器是这一用法的关键。<code>for</code>语句在对象上调用<code>iter()</code>，<code>iter()</code>函数返回定义了<code>next()</code>方法的迭代器对象用于逐一访问所有元素，当没有后续元素时，<code>next()</code>方法引发<code>StopIteration</code>异常通知<code>for</code>终止循环。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = <span class="string">'abc'</span></span><br><span class="line">&gt;&gt;&gt; it = <span class="function"><span class="title">iter</span><span class="params">(s)</span></span></span><br><span class="line">&gt;&gt;&gt; it.<span class="function"><span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="string">'a'</span></span><br><span class="line">&gt;&gt;&gt; it.<span class="function"><span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="string">'b'</span></span><br><span class="line">&gt;&gt;&gt; it.<span class="function"><span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="string">'c'</span></span><br><span class="line">&gt;&gt;&gt; it.<span class="function"><span class="title">next</span><span class="params">()</span></span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<p>&emsp;假若需要自定义类遍历，则只需要定义一个<code>__iter__(self)</code>方法并返回含有<code>next(self)</code>方法的对象即可，如果类中定义了<code>next(self)</code>方法则<code>__iter__(self)</code>可只返回<code>self</code><br>&emsp;Python使用内置的<code>iter()</code>函数，<code>iter()</code>函数通过调用<code>__iter__(self)</code>方法获得对象的迭代器。有了迭代器才能遍历每个元素，遍历时Python使用内置<code>next()</code>函数，<code>next()</code>函数通过调用<code>next(self)</code>方法对迭代器对象进行遍历。<code>__iter__(self)</code>只会被调用一次来获取迭代器，<code>next(self)</code>会被调用多次以遍历每个元素(<code>next(self)</code>方法中需要注意设置结束条件来触发<code>raise StopIteration</code>以避免死循环)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.index = self.index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.data[self.index]</span><br><span class="line"></span><br><span class="line">rev = Reverse(<span class="string">"spam"</span>)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> rev:</span><br><span class="line">    <span class="keyword">print</span> char</span><br></pre></td></tr></table></figure></p>
<h3 id="生成器"><strong>生成器</strong></h3><p>&emsp;官方文档中对<strong>生成器</strong>解释为：生成器是创建迭代器的一种简单而强大的工具。写起来像正规的函数，只是需要在返回数据时使用<strong><code>yield</code></strong>语句而非<code>return</code>语句。每次调用<code>next()</code>时，生成器会返回之前的状态并继续往下执行代码。<br>&emsp;在我个人看了，<strong>生成器</strong>就是一个特殊的迭代器，只不过<strong>生成器</strong>会<strong>自动</strong>的创建<strong><code>__iter__()</code></strong>方法和<strong><code>next()</code></strong>方法，所以比起自己实现迭代器类简洁方便。另一个特殊点是<strong>生成器</strong>会<strong>自动保存局部变量和执行状态</strong>，生成结束时自动抛出<code>StopIteration</code>异常(遇到<code>return</code>会抛出<code>StopIteration</code>异常)。<br>&emsp;简而言之，一个带有<strong><code>yield</code></strong>语句的函数就是一个生成器。当调用生成器时并<strong>不会执行任何函数里的代码</strong>，只有在调用<strong><code>next()</code></strong>函数时(<code>for</code>自动调用<code>next()</code>函数)时才开始执行函数中的代码。但代码执行的流程不是像普通函数一样一次性从头到尾执行，而是当遇到<strong><code>yield</code></strong>语句时产生中断并返回迭代值，然后保存当前执行状态，直到再次调用<code>next()</code>函数时才恢复上次中断状态并从上次<code>yield</code>语句的下一句继续执行。(<code>yield</code>保存状态并暂停函数的执行，<code>next()</code>从其暂停处恢复并继续往下执行函数代码。)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(data)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> data[index]</span><br><span class="line">        <span class="comment">#print data[index]      #普通函数写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#reverse('spam')    #普通函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成器可迭代调用</span></span><br><span class="line"><span class="comment">#即可迭代又免于class Reverse()的繁复</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> reverse(<span class="string">'spam'</span>):</span><br><span class="line">    <span class="keyword">print</span> char</span><br></pre></td></tr></table></figure></p>
<p>&emsp;关于<strong><code>yield</code></strong>和<strong>生成器</strong>更多内容可参考如下几篇文章</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/" target="_blank" rel="external">Python yield 使用浅析</a></li>
<li><a href="https://www.oschina.net/translate/improve-your-python-yield-and-generators-explained" target="_blank" rel="external">提高你的Python: 解释‘yield’和‘生成器’</a></li>
<li><a href="http://blog.jobbole.com/28506/" target="_blank" rel="external">Python关键字yield详解</a></li>
</ul>
<h4 id="生成器表达式"><strong>生成器表达式</strong></h4><p>&emsp;生成式表达式类似与一个<code>yield</code>值的匿名函数。生成式表达式本身看起来像列表表达式, 但不是用方括号而是用<strong>圆括号</strong>包围起来：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; mylist = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; gen = (x for x in mylist)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; gen</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0xb70a116c</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="协程_&amp;_yield"><strong>协程 &amp; yield</strong></h4><p>&emsp;协程又可称为微线程(coroutine)，进程、线程需要由系统来进行调度，而协程是在代码里显示调度的，<strong>主动让出CPU时间</strong>，因此避免了进程/线程切换时的开销能充分利用并发优势，但协程是针对单个CPU的是一个线程执行的。<br>&emsp;Python2中使用<code>yield</code>来实现不完全的协程。<code>yield</code>不仅能从生成器内返回状态而且还能从外部传递信息给生成器内部，一般的做法是通过将<code>yield</code>关键字赋值给变量，并调用生成器固有的<code>send()</code>方法将消息传入生成器内部。生成器在遇到<code>next()</code>方法时才会继续执行而<code>send()</code>方法能起到和<code>next()</code>方法同样的作用，其实<code>next()</code>相当于是<code>send(None)</code>。如果没有变量接收<code>yield</code>关键字，那么<code>send()</code>传递的消息将被丢弃。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">consumer</span><span class="params">()</span></span>:</span><br><span class="line">    thanks = <span class="string">'Thanks'</span></span><br><span class="line">    while <span class="number">1</span>:</span><br><span class="line">        food = yield thanks</span><br><span class="line">        print <span class="string">"consumer get %s"</span> % food</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="function"><span class="title">product</span><span class="params">()</span></span>:</span><br><span class="line">    c = <span class="function"><span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line">    #先调用<span class="function"><span class="title">next</span><span class="params">()</span></span>让<span class="function"><span class="title">consumer</span><span class="params">()</span></span>执行到yield等待接收food</span><br><span class="line">    first_rep = c.<span class="function"><span class="title">next</span><span class="params">()</span></span></span><br><span class="line">    print <span class="string">"first repose: %s"</span> % first_rep</span><br><span class="line">    <span class="keyword">for</span> food <span class="keyword">in</span> [<span class="string">'rice'</span>, <span class="string">'soup'</span>, <span class="string">'meat'</span>]:</span><br><span class="line">        response = c.<span class="function"><span class="title">send</span><span class="params">(food)</span></span></span><br><span class="line">        print <span class="string">"product get response: %s"</span> % response</span><br><span class="line">    c.<span class="function"><span class="title">close</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">product</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="id">#first</span> repose: Thanks</span><br><span class="line"><span class="id">#consumer</span> get rice</span><br><span class="line"><span class="id">#product</span> get response: Thanks</span><br><span class="line"><span class="id">#consumer</span> get soup</span><br><span class="line"><span class="id">#product</span> get response: Thanks</span><br><span class="line"><span class="id">#consumer</span> get meat</span><br><span class="line"><span class="id">#product</span> get response: Thanks</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>consumer()</code>是一个生成器，在<code>product()</code>中创建对象后调用<code>c.next()</code>启动生成器</li>
<li><code>product()</code>生产<code>food</code>后通过<code>c.send(food)</code>将消息传递给<code>consumer()</code>，程序切换到<code>consumer()</code>中继续执行。</li>
<li><code>consumer()</code>通过<code>yield</code>获取<code>product()</code>传入的消息，处理后(<code>print</code>)又通过<code>yield</code>返回结果(<code>thanks</code>)</li>
<li>最后调用<code>c.close()</code>关闭协程</li>
</ol>
<h3 id="super()"><strong>super()</strong></h3><p>&emsp;在类的继承中，子类会在初始化时调用<code>__init__(self)</code>方法，会将<code>self</code>和该子类的实例对象绑定而忽视父类。当使用子类实例对象调用父类的属性或方法时便会提示该属性/方法不存在。为了避免此问题的出现，就会在子类(新式类)中使用<strong><code>super(subclass, self).__init__()</code></strong>(Python2写法)(<code>super()</code>是在Python2.2之后新式类中才支持的，之前的Python版本的经典类只能用父类名调用)。<br>&emsp;一般提到<code>super()</code>便会很自然的和<strong>父类</strong>联系起来，但其实<code>super()</code>和父类<strong>没有必然的联系</strong>。<code>super()</code>指向的本质上是<font color="red">MRO的下一个类</font>，MRO的下一个类并不一定就是父类。<code>super()</code>的实现大概如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>	<span class="title">super</span><span class="params">(class, instance)</span>:</span></span><br><span class="line">    mro = instance.__class__.mro()</span><br><span class="line">    <span class="keyword">return</span> mro[mro.index(<span class="class"><span class="keyword">class</span>) + 1]</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong><code>instance</code></strong>：此参数是用于获得<code>instance</code>实例的MRO(Method Resolution Order)</li>
<li><strong><code>class</code></strong>：此参数主要用于定位当前类在MRO的位置</li>
</ul>
<p>&emsp;为了说明<code>super()</code>指向的是MRO的下一个类，而MRO的下一个类并不一定是父类。请看如下例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"In Class A"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"In Class B. Before super()"</span></span><br><span class="line">        super(B, self).__init__()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"In Class B. After super()"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"In Class C. Before super()"</span></span><br><span class="line">        super(C, self).__init__()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"In Class C. After super()"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line"><span class="keyword">print</span> d.__class__.mro()</span><br><span class="line"></span><br><span class="line"><span class="comment">#In Class B. Before super()</span></span><br><span class="line"><span class="comment">#In Class C. Before super()</span></span><br><span class="line"><span class="comment">#In Class A</span></span><br><span class="line"><span class="comment">#In Class C. After super()</span></span><br><span class="line"><span class="comment">#In Class B. After super()</span></span><br><span class="line"><span class="comment">#[&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;先记住实例<code>d</code>的MRO为<strong><code>[&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;type &#39;object&#39;&gt;]</code></strong>，此段代码的执行流程如下:</p>
<ul>
<li>类D实例化<code>D()</code>。当类在进行实例化是会自动调用方法<code>__init__(self)</code>，于是尝试调用类D的<code>__init__(self)</code>方法，发现类D没有<code>__init__(self)</code>方法，根据类继承规则，会查找类B中是否存在<code>__init__(self)</code>方法，发现类B有此方法于是执行类B的<code>__init__(self)</code>方法，打印<code>In Class B. Before super()</code></li>
<li>执行类B<code>__init__(self)</code>方法中的第二句<strong><code>super(B, self).__init__()</code></strong>。根据<code>super()</code>的实现本质：<ul>
<li><strong><code>self</code></strong>：<code>super(B, self)</code>，通过<code>self</code>参数获得实例的MRO。由于已实例化，此<code>self</code>表示的是实例对象<strong><code>d</code></strong>，于是获得<code>d</code>的MRO：<strong><code>D-&gt;B-&gt;C-&gt;A</code></strong>。</li>
<li><strong><code>B</code></strong>：<code>super(B, self)</code>，通过<code>B</code>参数获得当前类在MRO的位置并返回此位置的下一个类<strong><code>C</code></strong>。<br>&emsp;综上，<code>super(B, self).__init__()</code>其实等价于<code>C.__init__()</code>，于是执行类C的<code>__init__()</code>方法，打印<code>In Class C. Before super()</code><br>&emsp;假若<code>super()</code>总是指父类的话，那么<code>super(B, self).__init__()</code>便会等价于<code>A.__init__()</code>方法，便会打印”In Class A”。然而实际并不是，所有再次强调<code>super()</code>指的是<strong>MRO中的下一个类而非父类。</strong></li>
</ul>
</li>
<li>执行类C<code>__init__(self)</code>方法的第二句<strong><code>super(C, self).__init__()</code></strong>。简而言之，<code>self</code>指<code>d</code>，<code>C</code>指当前类位置，返回<code>A</code>。执行<code>A.__init__()</code>，打印<code>In Class A</code></li>
<li>沿路返回执行完剩下的语句</li>
</ul>
<h2 id="十、装饰器"><strong>十、装饰器</strong></h2><p>&emsp;<strong>装饰器</strong>在Python中是个比较重要的东西，Stackoverflow上有个比较详尽的解答——<a href="https://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484" target="_blank" rel="external">Decorator</a><br>&emsp;Python为了能简洁明了地使用装饰器，专门有个语法糖用于装饰器的使用。一般Python中使用装饰器如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="decorator">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment">#code</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;实际上这是一种”简写”，完整的形式大概如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="decorator">@wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment">#some code</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#被装饰函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#code</span></span><br><span class="line"></span><br><span class="line">myfunc = decorator(myfunc)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;首先定义了一个装饰器函数<code>decorator(func)</code>，将被装饰函数作为参数传入装饰器函数中<code>decorator(myfunc)</code>，最后将装饰器函数<code>decorator(func)</code>的返回值赋值回给原来的被装饰函数对象<code>myfunc</code>。因为需要赋值回给原来的函数，所以装饰器函数<code>decorator(func)</code>的返回值需是一个函数对象<code>wrapper</code>。<br>&emsp;将装饰器函数<code>decorator(func)</code>返回值赋值回给原来的函数对象<code>myfunc</code>这种做法会引发一个问题。被装饰函数<code>myfunc()</code>被重新赋值后其实已经是另外一个函数<code>wrapper(*args, **kwargs)</code>了。原来<code>myfunc()</code>的<code>__name__</code>和<code>docstring</code>已经被重写了。当执行<code>print myfunc.__name__</code>时所得到的结果是<strong><code>wrapper</code></strong>而非所期待的<strong><code>myfunc</code></strong>。为了解决这个问题，Python提供了一个简单的函数<code>functools.wraps</code>。其实这也是个装饰器函数，于是就有了<strong><code>@wraps(func)</code></strong>。</p>
<h3 id="累加装饰器"><strong>累加装饰器</strong></h3><p>&emsp;装饰器可多个进行累加，使用Stackoverflow那篇回答中的三明治例子就能很生动形象的加以解释，在火腿上添加面包和佐料两个装饰器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bread</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="string">"""面包装饰器(用于添加面包)"""</span></span><br><span class="line">    <span class="decorator">@wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&lt;/''''''\&gt;"</span></span><br><span class="line">        func()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&lt;\______/&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ingredients</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""佐料装饰器(用于添加番茄和沙拉)"""</span></span><br><span class="line">    <span class="decorator">@wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"#tomatoes#"</span></span><br><span class="line">        func()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"~salad~"</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@bread</span></span><br><span class="line"><span class="decorator">@ingredients</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sandwich</span><span class="params">(food=<span class="string">"--ham--"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> food</span><br><span class="line"></span><br><span class="line"><span class="comment">#sandwich = bread(ingredients(sandwich))</span></span><br><span class="line">sandwich()</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;/''''''\&gt;</span></span><br><span class="line"><span class="comment">##tomatoes#</span></span><br><span class="line"><span class="comment">#--ham--</span></span><br><span class="line"><span class="comment">#~salad~</span></span><br><span class="line"><span class="comment">#&lt;\______/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="装饰器的参数传递"><strong>装饰器的参数传递</strong></h3><h4 id="向装饰器内的装饰函数传递参数"><strong>向装饰器内的装饰函数传递参数</strong></h4><p>&emsp;Python中可以使用<strong><code>*args</code></strong>和<strong><code>\*\*kwargs</code></strong>，将被装饰函数中的参数<code>myfunc(&#39;mogl&#39;)</code>传递给装饰器函数<code>decorator(func)</code>中的装饰函数<code>wrapper(*args, **kwargs)</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="decorator">@wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"get args"</span>, args, kwargs</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"My name is"</span>, name</span><br><span class="line"></span><br><span class="line">myfunc(<span class="string">'mogl'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get args ('mogl',) &#123;&#125;</span></span><br><span class="line"><span class="comment">#My name is mogl</span></span><br></pre></td></tr></table></figure></p>
<h4 id="向装饰器传递参数"><strong>向装饰器传递参数</strong></h4><p>&emsp;向装饰器本身传递参数,可通过包裹函数实现。先创建包裹函数并在包裹函数内创建装饰器,然后再将参数传递给包裹函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_arguments</span><span class="params">(name)</span>:</span>		<span class="comment">#用于接收传递给装饰器的参数(接收参数name)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span>			<span class="comment">#实际装饰器，用于接收被装饰函数(接收参数被装饰函数对象)</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"decorator_arguments: %s"</span> % name</span><br><span class="line">            </span><br><span class="line">            <span class="decorator">@wraps(func)</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>	<span class="comment">#装饰函数，接收被装饰函数自带的参数/添加装饰</span></span><br><span class="line">            	<span class="keyword">print</span> <span class="string">"In wrapper(), args: %s, kwargs: %s"</span> % (args, kwargs)</span><br><span class="line">            	<span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@decorator_arguments('mogl')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(full_name)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">myfunc(<span class="string">'moguoliang'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#decorator_arguments: mogl</span></span><br><span class="line"><span class="comment">#In wrapper(), args: ('moguoliang',), kwargs: &#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="装饰器类"><strong>装饰器类</strong></h3><p>&emsp;为了使得装饰器有继承的特性，一般可用类来构建装饰器，以类而非函数的方式构建装饰器。<br>&emsp;一个类装饰器主要有两个成员方法<strong><code>__init__()</code></strong>和<strong><code>__call__()</code></strong></p>
<ul>
<li><code>__init__()</code>：给某函数进行装饰时被调用</li>
<li><code>__call__()</code>：调用被装饰的函数时<code>__call__()</code>被调用<br>  &emsp;<code>__call__()</code>是Python提供的一个方法，它可让类实例的行为表现得想函数一样(可调用/可将函数作为参数传递给另一函数)。简而言之，即使得<code>x()</code>等价与<code>x.__call__()</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#装饰器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=<span class="string">'mogl'</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"In Decorator.__call__(), name: %s"</span> % self.name</span><br><span class="line"></span><br><span class="line">        <span class="decorator">@wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"In wrapper(), args: %s, kwargs: %s"</span> % (args, kwargs)</span><br><span class="line">            self.extend()</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#演示类的继承特性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorSubclass</span><span class="params">(Decorator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email, *args, **kwargs)</span>:</span></span><br><span class="line">        super(DecoratorSubclass, self).__init__(*args, **kwargs)</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"DecoratorSubclass argument email=%s"</span> % self.email</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"In DecoratorSubclass.extend()"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@Decorator()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(fullname)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">myfunc(<span class="string">'moguoliang'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@DecoratorSubclass('fatesai@gmail.com')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc2</span><span class="params">(fullname)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">myfunc2(<span class="string">'moguoliang'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#In Decorator.__call__(), name: mogl</span></span><br><span class="line"><span class="comment">#In wrapper(), args: ('moguoliang',), kwargs: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#In Decorator.__call__(), name: mogl</span></span><br><span class="line"><span class="comment">#In wrapper(), args: ('moguoliang',), kwargs: &#123;&#125;</span></span><br><span class="line"><span class="comment">#DecoratorSubclass argument email=fatesai@gmail.com</span></span><br><span class="line"><span class="comment">#In DecoratorSubclass.extend()</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="十一、上下文管理器"><strong>十一、上下文管理器</strong></h2><p>&emsp;上下文管理器(Context Manager)是Python2.5开始支持，规定在进入或离开特定代码块时会执行特殊的操作。最普遍的用法是对文件的操作，使用<code>with</code>语句自动关闭打开的文件。<br>&emsp;在对文件进行操作后，需要关闭打开的文件但经常会忘记导致文件描述符一直累积占用资源。上下文管理器可在文件操作结束后<strong>自动</strong>执行关闭文件的操作。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#使用try...finally实现</span><br><span class="line">try:</span><br><span class="line">    f = <span class="function"><span class="title">open</span><span class="params">(<span class="string">"test.txt"</span>, <span class="string">"r"</span>)</span></span></span><br><span class="line">    print f.<span class="function"><span class="title">read</span><span class="params">()</span></span></span><br><span class="line">finally:</span><br><span class="line">    f.<span class="function"><span class="title">close</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">#使用上下文管理器</span><br><span class="line">with <span class="function"><span class="title">open</span><span class="params">(<span class="string">"test.txt"</span>, <span class="string">"r"</span>)</span></span> as f:</span><br><span class="line">    print f.<span class="function"><span class="title">read</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="上下文管理器的实质"><strong>上下文管理器的实质</strong></h3><p>&emsp;一个上下文管理器对象至少要实现<strong><code>__enter__()</code></strong>和<strong><code>__exit__(type, valve, traceback)</code></strong>方法。以<code>wiht</code>语句为例子大致了解上下文管理器的执行过程：</p>
<ol>
<li>遇到<code>with</code>关键字先加载<code>__exit__()</code>方法以备用调用</li>
<li>执行<code>with</code>关键字后的语句<code>open(&quot;test.txt&quot;, &quot;r&quot;)</code>获取一个文件对象的上下文管理器</li>
<li>执行<code>__enter__()</code>方法，方法的返回值将传递给<code>as</code>后的<code>f</code>变量</li>
<li>执行<code>with</code>代码块的子句<code>print f.read()</code></li>
<li>执行<code>__exit__()</code>，若<code>with</code>代码块子句有异常则将<code>type, value, traceback</code>传递给<code>__exit__()</code>，无异常则传<code>None</code>；<code>__exit__()</code>接收值后若返回<code>False</code>则将异常抛出交由外层处理，返回<code>True</code>则忽略异常。</li>
</ol>
<h3 id="自定义上下文管理器"><strong>自定义上下文管理器</strong></h3><h4 id="基于类实现上下文管理器"><strong>基于类实现上下文管理器</strong></h4><p>&emsp;基于类的实现最简单的方式就是直接定义好<code>__enter__(self)</code>方法和<code>__exit__(self, type, value, traceback)</code>方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileContextManage</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, file_name, method)</span>:</span></span><br><span class="line">        self.file_obj = open(file_name, method)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.file_obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, traceback)</span>:</span></span><br><span class="line">        self.file_obj.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> FileContextManage(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fd:</span><br><span class="line">	<span class="keyword">print</span> fd.read()</span><br></pre></td></tr></table></figure></p>
<h4 id="基于生成器实现上下文管理器"><strong>基于生成器实现上下文管理器</strong></h4><p>&emsp;Python有<code>contextlib</code>模块专门用于使用生成器来实现上下文管理器。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib import contextmanager</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def file_context_manage(file_name, <span class="function"><span class="keyword">method</span>):</span></span><br><span class="line">    fd = open(file_name, <span class="function"><span class="keyword">method</span>)</span><br><span class="line">    <span class="title">yield</span> <span class="title">fd</span></span><br><span class="line">    <span class="title">fd</span>.<span class="title">close</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="title">with</span> <span class="title">file_context_manage</span><span class="params">(<span class="string">'test.txt'</span>, <span class="string">'r'</span>)</span> <span class="title">as</span> <span class="title">fd</span>:</span></span><br><span class="line">	print fd.<span class="keyword">read</span>()</span><br></pre></td></tr></table></figure></p>
<p>&emsp;<code>contextmanager</code>装饰器返回<code>GeneratorContextManager</code>对象，即<code>file_context_manage</code>函数被装饰后实际上是一个<code>GeneratorContextManager</code>对象。<code>yield</code>只能返回一个值，此值相当于<code>__enter__()</code>的返回值，<code>yield</code>后的语句相当于<code>__exit__()</code>方法内的语句。</p>
<h2 id="十二、描述符"><strong>十二、描述符</strong></h2><p>&emsp;<strong>描述符</strong>是Python2.2之后引入的，<strong>描述符</strong>其属性的访问被<strong>描述符协议方法</strong>覆写，即<strong>描述符</strong>将对象属性的获取、赋值和删除转化为调用<strong>描述符协议方法</strong>。<strong>描述符协议方法</strong>有三个：</p>
<ul>
<li><strong><code>__get__(self, instance, owner) --&gt; return value</code></strong></li>
<li><strong><code>__set__(self, instance, value) --&gt; return None</code></strong></li>
<li><strong><code>__delete__(self, instance) --&gt; return None</code></strong></li>
</ul>
<p>&emsp;简而言之，<strong>描述符</strong>就是实现了<strong>描述符协议方法</strong>的对象(<strong>至少</strong>实现<code>__get__()</code>、<code>__set__()</code>和<code>__delete__()</code>方法的其中一个即可)，<strong>描述符</strong>对属性的访问是通过调用<strong>描述符协议方法</strong>的。<br>&emsp;根据实现的<strong>描述符协议方法</strong>的多少又可分成：</p>
<ul>
<li><strong>数据描述符(data descriptor)</strong>：实现了<code>__get__()</code>和<code>__set__()</code>方法</li>
<li><strong>非数据描述符(non-data descriptor)</strong>：仅实现<code>__get__()</code>方法</li>
</ul>
<h3 id="获取属性"><strong>获取属性</strong></h3><p>&emsp;对于<strong>描述符</strong>还有几点需要注意：</p>
<ol>
<li><strong>描述符只能在类级别上进行合法定义，而不能在实例级别上定义，即描述符只能是类属性而不能是实例属性。</strong></li>
<li><strong>数据描述符(data descriptor)</strong>不能被实例属性覆盖，即<strong>数据描述符</strong>对同名实例属性(非描述符)有屏蔽作用。<strong>非数据描述符(non-data descriptor)</strong>和普通类属性相同会被实例属性覆盖。换句话说这是<strong>数据描述符</strong>和<strong>非数据描述符</strong>之间的最主要区别是：相对于实例字典的优先级不同。如果实例字典中有与描述器同名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。</li>
</ol>
<p>&emsp;在没有<strong>描述符</strong>之前获取属性相对较简单明了，但加入了<strong>描述符</strong>后就会变得稍微复杂，为方便对比来看一下没有描述符和有描述符的属性获取过程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    class_attr = <span class="string">"Class attribute"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Class method"</span></span><br><span class="line"></span><br><span class="line">my_instance = MyClass()</span><br><span class="line"><span class="keyword">print</span> my_instance.class_attr</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>不考虑描述符情况(Python2.2之前)<br>  &emsp;Python对象一般都是通过<code>__dict__</code>字典动态管理对象的所有属性。<br>  &emsp;Python的属性搜索都是从<strong>MRO</strong>自下向上搜索<br>  &emsp;当通过<code>my_instance.class_attr</code>方式访问属性时，无描述的情况大致如下：</p>
<ol>
<li>首先在实例对象<code>my_instance</code>的<code>__dict__</code>内查找是否存在属性<code>class_attr</code>，若存在则直接返回。</li>
<li>若不存在则在<strong>MRO</strong>链上的下一个类的<code>__dict__</code>查找，找到则返回否则继续在<strong>MRO</strong>链上的下一个类上查找。直到最后都没找到则返回异常。</li>
</ol>
</li>
<li><p>考虑描述符情况(Python2.2之后)<br>  &emsp;对于实例对象而言，通过<code>.</code>方式获取属性<code>my_instance.class_attr</code>实际上是调用了<strong><code>object.__getattribute__()</code></strong>方法(每次引用属性或方法时都会无条件的调用<code>__getattribute__()</code>)，而<code>__getattribute__()</code>方法又会根据<strong>对象</strong>或<strong>类</strong>调用不同的<code>__get__()</code>方法</p>
<ul>
<li><strong>对象</strong>：<code>obj.x</code>，调用<code>type(obj).__dict__[&#39;x&#39;].__get__(obj, type(obj))</code></li>
<li><p><strong>类</strong>：<code>class.x</code>，调用<code>type(class).__dict__[&#39;x&#39;].__get__(None, type(class)</code></p>
<p>&emsp;最终<code>my_instance.class_attr</code>会被解析成<strong><code>type(my_instance).__dict__[&#39;class_attr&#39;].__get__(my_instance, type(my_instance))</code></strong>——&gt;<strong><code>MyClass.__dict__[&#39;class_attr&#39;].__get__(my_instance, MyClass)</code></strong><br>&emsp;通过<code>my_instance.class_attr</code>方式获取属性时，考虑描述符情况的大致过程如下：</p>
</li>
</ul>
<ol>
<li>查找<code>MyClass</code>中是否覆写方法<code>__getattribute__()</code>。若覆写则返回<code>MyClass.__getattribute__(my_instance, &#39;class_attr&#39;)</code>；否则执行<code>2</code></li>
<li>依次在<code>MyClass.__mro__</code>链上的类的<code>__dict__</code>中查找<code>class_attr</code><ul>
<li>完全没找到<code>class_attr</code>，查找<code>MyClass</code>中是否存在<code>__getattr__()</code>方法，存在则调用<code>MyClass.__getattr__(my_instance, &#39;class_attr&#39;)</code>获取实例中的<code>class_attr</code>属性。若不存在<code>__getattr__()</code>或<code>__getattr__()</code>方法获取实例属性失败(实例无此属性)都将抛出<code>AttributeError</code>异常。</li>
<li>找到<strong>第一个</strong><code>class_attr</code><ul>
<li>3 判断<code>class_attr</code>是否是<strong>数据描述符</strong><ul>
<li>是：返回<code>Descr.__get__(class_attr, my_instance, MyClass)</code></li>
<li>否：查找实例的<code>__dict__</code>是否存在<code>class_attr</code>，存在则返回并<strong>结束</strong>；不存在则执行<code>4</code>。(存在之所以直接结束是因为实例属性可覆盖非数据描述符(<code>4</code>)和类属性<code>5</code>)</li>
</ul>
</li>
<li>4 判断<code>class_attr</code>是否是<strong>非数据描述符</strong><ul>
<li>是：返回<code>Descr.__get__(class_attr, my_instance, MyClass)</code></li>
<li>否：执行<code>5</code></li>
</ul>
</li>
<li>5 <code>class_attr</code>为普通类属性且<code>my_instance</code>不存在该实例属性(<code>3</code>-否)，返回类属性<code>class_attr</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="设置属性"><strong>设置属性</strong></h3><p>&emsp;引入了描述符后设置属性<code>my_instance.class_attr = &#39;test&#39;</code>的大致过程如下：</p>
<ol>
<li>查找<code>MyClass</code>类中是否覆写方法<code>__setarrt__()</code>。若覆写则返回<code>MyClass.__setattr__(self, &#39;class_attr&#39;, value)</code>；否则执行<code>2</code></li>
<li>依次在<code>MyClass.__mro__</code>链上的<code>__dict__</code>中查找<code>class_attr</code><br> &emsp;对于第一个找到的<code>class_attr</code>，若<code>class_attr</code>是数据描述符(data descriptor)，则返回<code>Descr.__set__(attr, my_instance, value)</code> <strong>结束</strong>；否则则意味着<code>class_attr</code>是非数据描述符或类属性或找不到<code>class_attr</code></li>
<li>在实例<code>my_instance</code>的<code>__dict__</code>设置<code>class_attr</code>属性</li>
</ol>
<h3 id="删除属性"><strong>删除属性</strong></h3><p>&emsp;引入了描述符后删除属性<code>del my_instance.class_attr</code>的大致过程如下：</p>
<ol>
<li>查找<code>MyClass</code>类中是否覆写方法<code>__delarrt__()</code>。若覆写则返回<code>MyClass.__delattr__(self, &#39;class_attr&#39;)</code>；否则执行<code>2</code></li>
<li>依次在<code>MyClass.__mro__</code>链上的<code>__dict__</code>中查找<code>class_attr</code><br> &emsp;对于第一个找到的<code>class_attr</code>，若<code>class_attr</code>是定义了<code>__delete__</code>的描述符，则返回<code>Descr.__delete__(attr, my_instance)</code> <strong>结束</strong>；否则则意味着<code>class_attr</code>是没定义<code>__delete__()</code>的描述符或类属性或找不到<code>class_attr</code></li>
<li>若实例<code>my_instance</code>中存在属性<code>class_attr</code>则删除，否则抛出AttributeError异常</li>
</ol>
<h2 id="十三、元类"><strong>十三、元类</strong></h2><p>&emsp;<strong>元类(metaclass)</strong>是用来创建<strong>类(class)</strong>的，即<strong>元类(metaclass)</strong>是类的类。也就是说<strong>元类(metaclass)</strong>的实例化是<strong>类(class)</strong>，<strong>类(class)</strong>的实例化是<strong>类实例对象(object)</strong>。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class =<span class="function"> metaclass(</span><span class="function">)</span>		<span class="comment">#元类(metaclass)创建类(class)</span><span class="instruction"></span><br><span class="line">instance </span>=<span class="function"> class(</span><span class="function">)</span>		<span class="comment">#类(class)创建实例(object)</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;在Python中默认使用<strong>type</strong>这个内建的元类(metaclass)来创建所有的类(class)。可使用<strong>type</strong>函数创建类，规定格式如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">type</span><span class="container">(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</span></span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;所以使用<code>class</code>关键字创建的类其实和调用<code>type</code>函数创建的类是一样的。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#例子<span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(</span><span class="class"><span class="keyword">object</span>):</span></span><br><span class="line">	pass</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> = <span class="class"><span class="keyword">type</span>(</span><span class="symbol">'MyClas</span>s', (), &#123;&#125;)</span><br><span class="line"></span><br><span class="line">#例子<span class="number">2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(</span><span class="class"><span class="keyword">object</span>):</span></span><br><span class="line">	name = <span class="symbol">'mog</span>l'</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> = <span class="class"><span class="keyword">type</span>(</span><span class="symbol">'MyClas</span>s', (), &#123;<span class="symbol">'nam</span>e': <span class="symbol">'mog</span>l'&#125;)</span><br><span class="line"></span><br><span class="line">#例子<span class="number">3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(</span><span class="class"><span class="keyword">object</span>):</span></span><br><span class="line">	pass</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>(</span><span class="type">MyClass</span>):</span><br><span class="line">	sub_name = <span class="symbol">'mogl_chil</span>d'</span><br><span class="line"></span><br><span class="line"><span class="type">MySubClass</span> = <span class="class"><span class="keyword">type</span>(</span><span class="symbol">'MySubClas</span>s', (<span class="type">MyClass</span>,), &#123;<span class="symbol">'sub_nam</span>e': <span class="symbol">'mogl_chil</span>d'&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="__metaclass__"><strong>__metaclass__</strong></h3><p>&emsp;<strong><code>__metaclass__</code></strong>用于指明该类在创建时使用的元类，若没有<code>__metaclass__</code>则默认使用<code>type</code>来创建类，所以我们可以使用<code>__metaclass__</code>来自定义元类(metaclass)。<br>&emsp;当使用关键字<code>class</code>创建类时，Python会做如下操作：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(</span><span class="class"><span class="keyword">object</span>):</span></span><br><span class="line">    __metaclass__ = xxxxx</span><br></pre></td></tr></table></figure></p>
<ol>
<li>遇到<code>class</code>关键字，<code>class MyClass(object)</code>说明需要创建一个名为<code>MyClass</code>的类</li>
<li>Python在<code>MyClass</code>类定义中寻找是否存在<strong><code>__metaclass__</code></strong>属性，Python对<code>__metaclass__</code>的搜索按照<strong><code>class.__metaclass__ -&gt; bases.__metaclass__ -&gt; module.__metaclass__ -&gt; type</code></strong>顺序进行，存在则使用<code>__metaclass__</code>指定的元类来创建类<code>MyClass</code>，若最终都没有<code>__metaclass__</code>则使用内建元类<code>type</code>创建。</li>
</ol>
<h3 id="自定义元类"><strong>自定义元类</strong></h3><h4 id="使用类来构建元类"><strong>使用类来构建元类</strong></h4><p>&emsp;使用类来构建元类一般都是继承type，即使用type作为父类然后覆写<strong><code>__new__()</code></strong>方法并返回<br>&emsp;<code>__new__()</code>是在<code>__init__()</code>之前就会被调用的特殊方法, 用来创建对象并返回。<br>&emsp;<code>__new__(self_class, future_class_name, future_class_parents, future_class_attr)</code>方法接收到的参数依次是：当前准备创建的类的对象; 类的名字; 类继承的父类集合; 类的方法集合<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(self_class, future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">"self_class:%s, future_class_name:%s, future_class_parents:%s, future_class_attr:%s"</span> % (self_class, future_class_name, future_class_parents, future_class_attr)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(self_class, future_class_name, future_class_parents, future_class_attr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self_class, future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"class: %s"</span> % self_class</span><br><span class="line">        type.__init__(self_class, future_class_name, future_class_parents, future_class_attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">      <span class="string">"""docstring for MyClass"""</span></span><br><span class="line">      __metaclass__ = MyMetaClass</span><br><span class="line">      name = <span class="string">'mogl'</span></span><br><span class="line"></span><br><span class="line">my_instance = MyClass()</span><br><span class="line"><span class="keyword">print</span> my_instance.__class__</span><br><span class="line"></span><br><span class="line"><span class="comment">#self_class:&lt;class '__main__.MyMetaClass'&gt;, future_class_name:MyClass, future_class_parents:(&lt;type 'object'&gt;,), future_class_attr:&#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.MyMetaClass'&gt;, '__doc__': 'docstring for MyClass', 'name': 'mogl'&#125;</span></span><br><span class="line"><span class="comment">#class: &lt;class '__main__.MyClass'&gt;</span></span><br><span class="line"><span class="comment">#&lt;class '__main__.MyClass'&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用函数构建元类"><strong>使用函数构建元类</strong></h4><p>&emsp;除了使用类来构建元类外，也可以使用函数来构建元类，这需要使用到<code>type</code>函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_metaclass</span><span class="params">(class_name, class_parents, class_attrs)</span>:</span></span><br><span class="line">    my_type = type(class_name, class_parents, class_attrs)</span><br><span class="line">    my_type.name = <span class="string">"mogl"</span></span><br><span class="line">    <span class="keyword">return</span> my_type</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for MyClass"""</span></span><br><span class="line">    __metaclass__ = my_metaclass</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> MyClass.__metaclass__</span><br><span class="line"><span class="keyword">print</span> MyClass.__class__</span><br><span class="line"><span class="keyword">print</span> MyClass.name</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;unbound method MyClass.my_metaclass&gt;</span></span><br><span class="line"><span class="comment">#&lt;type 'type'&gt;</span></span><br><span class="line"><span class="comment">#mogl</span></span><br></pre></td></tr></table></figure></p>

				</div>

				

					<div class="content-tag">

						 <a class="tag-link" href="/tags/python/">python</a>

					</div>

				

			</article>

			<div class="content-nav">

				

				
					<a href="/2016/02/02/docker/" title="Docker笔记">Next &rarr;</a>
				

			</div>

		</div>


	</div>

	<div class="row">
	<p class="theme">Powered: <a href="http://hexo.io/"  target="_blank">Hexo</a>, Theme: <a href="https://github.com/samwhelp/hexo-theme-nadya" target="_blank">Nadya</a> remastered from <a href="https://github.com/nadymain/hexo-theme-nadymain" target="_blank">NadyMain</a></p>
</div>

	<!-- <div class="row">
	<p class="theme">Powered: <a href="http://hexo.io/"  target="_blank">Hexo</a>, Theme: <a href="https://github.com/samwhelp/hexo-theme-nadya" target="_blank">Nadya</a> remastered from <a href="https://github.com/nadymain/hexo-theme-nadymain" target="_blank">NadyMain</a></p>
</div>
 -->

</body>
</html>
